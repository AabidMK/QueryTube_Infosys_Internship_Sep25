video_id,transcript,transcript_type
8XwoR5rzseI,"Have you ever wondered how certain types in Python are iterable? For example, you iterate through something like a list or a string and you can write it in a for loop, right? You could say for number in and then the list and you can grab all of the values that exist inside of it. Well, the reason why those are iterable is because they have the iter and the next method defined on them. Now, if something defines the iter method, that means it can be used directly inside of something like a for loop. Also, a list comprehension. And there's a bunch of other places where the iterator can be used because what happens implicitly when you use a for loop in Python is you actually call the it method on whatever you're trying to loop through that returns some value and then you continually call the next function on that value until stop iteration is raised.",unknown
uu1UY9oRAKk,"how to make money from coding. Having a highv value skill that allowed you to contribute something to the marketplace is what you need to start with. And then you start to realize quite quickly, damn, I can build this up, build this up, build this up to the point where you're making just so much money, it's actually unbelievable. Let's start with number one, freelancing. Now, freelancing pretty much just means you're kind of on your own and you just do random side jobs. You do gig work. Maybe you're doing some hourly work for a company. Maybe you're finishing some project here. But you can work for whoever you want whenever you want. Next, tutorials. Now, obviously, if you have a big social media presence like mine, you can just post tutorials and you get paid by AdSense and whatnot. But a lot of companies actually need people to make tutorials for specific frameworks, libraries, languages, whatever it may",unknown
APLbIeLU9QY,"the default dictionary function. And this allows you to create a dictionary object that has a default value. What that means is that when you try to access a key that does not exist, rather than getting a key error, you're going to get whatever the default value is, which is dictated by the return of whatever the function is that you pass to the constructor. So just to make this clear, what I can do is define a function. So I can say define, and then we'll just go with default funk like that. And what I could do is just return a value say like 20 if that's what I wanted the value to be. And now rather than passing the int, I would just pass my default function. Notice I'm not calling it. And now anytime I try to access a key that does not exist, we're going to call this function, get this value, and use that as the default value. In order to illustrate that to you, I'm just going to get rid of the below example here, and I'm going to try to print out the word count at the key zero. Now, currently the key zero does not exist inside of my word count dictionary. This is just an empty dictionary.",unknown
S6OZ3r5LqJc,"How do you write code that other people are going to be working on, not just code that's strictly for yourself? Once you've got those core skills down, then it is really time to dial in on a road map in a specific area of software development. And that's what we'll get into now. Now, I have four road maps for you in this video. The first is data science, machine learning. The second is front-end development. The next is back-end development. And the last is mobile development. Now, make no mistake. There are hundreds of different road maps you can follow along with, and I can't possibly put them all in this video. But these four are very popular and the ones I see a lot of people having success with.",unknown
YESrXVkcCHY,"I have gone over a lot of AI tools on this channel. I've made probably 30 plus videos at this point covering those various tools. So, in this video, I want to talk to you about which ones I actually use on a day-by-day basis as a developer, what tools are open on my computer and are getting the most use. Stick around. I'm going to go through a bunch of them and you're probably going to learn about some new ones that you've never seen before. So, let's start with some of the obvious ones. I have cursor and windsurf. Now, cursor is typically my go-to IDE, especially if I'm working on something that is a hybrid project. So, it has a backend, a front end, and a lot of different components. Then I have uh Windsurf, which is another editor that I use. I was using Windsurf a lot when it first came out because I found that it did actually perform better than cursor. But now, Cursor has just accelerated extremely fast. And to be honest, I mostly use cursor on a day-by-day basis because I find that now it is better than Windsurf. Again, these things change. Maybe Windsurf will come out with an update and then I'll start using it again. At the beginning, it had a bunch of features that cursor didn't have and then cursor pretty much copied all of them and added them to the IDE. And that's how it is. Now, if you want tutorials on these tools and you're not sure what they are, essentially they are AIDS, which means you can go in this window and do something like, hey, you know, change the title of my website. You can pick your model. In this case, I'm using GPT5. And it's just going to go ahead and start actually writing code for you, making changes, and then allowing you to view those changes inside of the editor. Now, because I am a real developer, I still like to have control of the code. I like to modify things myself, move around the files, and I'm very comfortable in these type of editors. So, that's why I prefer to use this most of the time when I'm developing. However, there are a lot of other AI tools that aren't full IDE that I'm going to talk about later in this video. Now, the next tool on my list is by far the one that I use the most, and that is Chat GPT. Pretty straightforward. I'm sure all of you use this, but I want to explain to you what I use it for and why it gets the most amount of use. Now, I use Chat GPT for pretty much everything. Whether it's writing emails, responding to queries, reviewing contracts, helping me manage Dev Launch students, reviewing resumeum√©s, just building in a lot of context, and getting really accurate replies. It helps me script videos. It helps me do accounting things. It helps me answer random questions like I'll take a photo of, you know, something in my bedroom or something and be like, ""What is this thing? Why is this wall outlet look like this?"" You guys get the idea. But the thing is, because I've been using Chat GPT for so long, like since it came out, it knows everything about me. It knows what car I drive. It knows where I travel. It knows the plans that I have because I feed it all of this information, which is probably not a good thing security-wise, but it happens anyways, so I might as well take advantage of it. So when I go to Chad GBT and I ask it something, it has such relevant context that a lot of these other AI tools just simply cannot have because I haven't been using them for 2, three, four plus years. So because of all of that context, it's something that I stick with pretty much every single day. And even though it's not as good as a lot of the other tools at specific tasks, it's just my go-to tool. I use it on my phone, I use it on the computer, and I have it open multiple hours per day almost always in a second monitor. That's why and how I use it. Let's move on to the next one. Now, the next tool on my list has been a total gamecher for my coding productivity and just productivity in general, and that's Whisper Flow. Now, this is hands down the fastest and most accurate dictation tool that I've ever used. Now, it runs in the background and with a quick keyboard shortcut, you can start dictating in real time. Now I use it on Windows, Mac, and even on my iPhone because it has like a iOS keyboard extension. And unlike the built-in voice modes or the OS level dictation, Flow works in any application. It's quicker, more accurate, and even saves a history of all of the dictations, which I find extremely useful so that I don't lose long prompts that I'm speaking. And for me, this is legitimately three times my productivity. Now, I can normally type honestly probably around 60 70 words per minute. not a great typer. But with Flow, I can stream my thoughts at almost 200 words per minute. I'll show you in the tool here. You can see I think it's like 190 is my average uh words per minute in the tool. Now, that means that my AI prompts are way more detailed and contextual without me having to slow down. Now, I use this everywhere. So, Cursor, Windsor, Lovable, Chat GBT, WhatsApp, Discord, literally everything. I'm just always speaking into my computer now, especially when I want to write longer messages. And there's something new that's in this tool as well. In cursor and windsurf, flow can actually tag variables and files as you dictate. So rather than the normal voice mode, which is pretty much just giving you text in the editor, this knows what application you're working inside of and then it can actually tag individual files and use the built-in features in that tool, which is very useful for providing the right context for the AI. Now, Flow also has extras like a custom vocabulary, built-in notes, team sharing, but honestly, the biggest thing is that it just works every single time I want to use it. And honestly, if you're not using voice right now, you're missing out on massive productivity gains. And more importantly, you're probably not providing the best prompts that you could be to your AI models. I know for me, when I speak, I always give more detail because I'm just not as lazy as if I have to type it out. Now, full disclosure, I was able to partner with FL on this video, but I've been using them well before the partnership. I've been using them for months now, and if you guys want to try it out for free, you can do so from the link in the description, and I'm going to be going over a full tutorial of this tool soon. Now, the next AI tool on my list is Deep Agent by Abacus AI. Now, this is something that I use whenever I need really complex, longunning agentic tasks where I can go out, search the internet, build an app, generate a PowerPoint, make a document, etc. There's a lot of use cases. I've made a lot of videos on this on the channel, so I'm not going to dive extremely in-depth, but just to quickly show you a few things I've got this to do for me. I moved into a new apartment recently, so I got it to do the full interior design for that apartment based on the floor plan and kind of the preferences that I send to it. I got it to build a full application uh that actually is a road map tracker for my Dev Launch students. So, I'm not going to run through the whole app, but essentially it's like a custom platform that I can use to generate a road map that I can give to students. And then I gave it a bunch of other tasks. One notable one is that again, I moved into this apartment and I noticed there's a lot of construction around me. So, I wanted to see, okay, how long are these buildings going to take to be built? You know, how tall are they going to be? Are they going to block my view? Are they going to be noisy? So, I just told Deep agent, hey, this is my address. This is the apartment. This is the floor that I'm on. you know what buildings are near me that are going to be built soon. Give me the timeline. Give me the floors. Tell me if it's going to block my view, etc. Again, took a very long time. Ran and was able to actually do that with very high accuracy, which I'm not able to really do with something like chat GPT. I'm sure there's other AI tools that can do this as well, but my experience is deep agent works really well for these very complex tasks. So, that's what I use it for. Now, the next tool on my list is Warp. This is essentially an AI terminal. I mean, they're branding it as like an agentic AI editor, but really it's a terminal with a bunch of AI inside of it. And this allows you to actually generate code as well as run commands. And it's really good for automation tasks or whenever you don't want to really dive into the code and you more so want to work purely kind of on the back end without a ton of visuals and be automating a lot of stuff. So recently, I made a full Discord bot for example using this because there's a lot of deployment, a lot of configuration, containerization, etc. that you need to do. So it works really well in this terminal environment where you can just switch it to a normal terminal and you can like run a command and then you can like open a file directly inside of here if you want to look at it or I can switch it to agent mode and I can say you know tell me what files are here and then it will determine sorry the commands and the tasks that it should actually run. Something interesting about this is that you can run agents in parallel. So I can open up a new tab here and say, ""Hey, how are you?"" or something, right? And now both of these are running actually at the exact same time. Or well, this one already finished, but you can run multiple of them at the same time. Kind of like multi-threaded agents, which I find is cool. And again, it's what I like for kind of the terminalbased AI editing. It's not the only thing that I use. Like I said, I still use cursor. I still use Windsurf. I use a lot of the other tools. when I'm working more in a deployment or a backend environment then I'll open up warp and I'll use it as an agentic kind of terminal where it can suggest commands for me especially for like containerization kubernetes etc and it's quite useful now the next tool that I use is lovable now this is only what I use when I want to generate simple frontends I do not build entire full stack applications with lovable even though you can do that I simply use it for like landing pages basic design or spinning up relatively simple sites. Now, you guys might have seen recently that I actually launched my Dev Launch vault. vault.devaunch.us is the URL if you want to check it out. And I used Lovable to actually generate the entire landing page for that. Then I brought it into Cursor and I made a few adjustments. So, you can see like I'm inside of the Lovable editor right now. You can see there was a bunch of prompts that I went through and eventually I got it to create what I think is a really slick simple website just to promote again this kind of new product that we're launching which is a simple course for the people that can't afford devaunch essentially. I'm genuinely not trying to sell it to you. I'm just trying to show you that I use Lovable to do that. I got it to generate like the privacy page, the disclaimer, the company info, and I've used it for some other simple websites as well. Again, typically when it's a few pages, it's relatively basic. it doesn't have a ton of data or backend and then what I do is once it starts getting a bit more complicated I take the code from GitHub I put it into cursor and then I do the rest of the serious development workable is really good for those simple design things again I don't think it's the best for like really complex applications which is why I don't use it for that but for quick landing pages as you can see I've made a few here it's pretty good next AI tool on my list is one that I genuinely cannot live without and that is TL DV now this is essentially a meeting recorder where anytime I join any kind of Google meet or Zoom or whatever, this AI bot automatically joins for me and records the meeting. Now, it doesn't just do that. Obviously, it generates the AI summary and notes. It also allows me to provide a template so that based on the meeting type that I'm having, I can have notes based on that template. And then it gives me the full transcript. And oftent times what I end up doing is copying the transcript into another tool like chat GBT and then having it analyze that for me so that I can get kind of immediate answers and use that for for example crafting a video or coming up with a road map or helping a student or whatever. Now it has automations built in. So I'm able to connect this with Zapier for example. So anytime a meeting is finished it automatically does a zap or whatever and then it sends that recording to Discord so my other team members can view it. And I have I just use this all the time. I literally use it multiple times per day. It connects to all of my meetings. I know there's a lot of AI kind of recorders out there, but for me, this one works extremely well. They've never sponsored my channel. I'm just mentioning it because like this is what I genuinely use and that's the part of the video or that's the point of the video. This next tool is one that I've been using more recently and this is called Blitzy. Now, this tool is significantly different than a lot of the other AI tools that you've used before because it emphasizes spending a lot of time writing a prompt and understanding the context of the project before it does any work. So, rather than running in a few minutes or an hour, this tool typically takes 1 to 3 days to actually come up with a response and it's specifically designed for software development. So, let me show you a quick example. Essentially, what will happen with Blitzy is you'll upload your existing codebase. In my case, I uploaded my previous startup codebase which was quite large. It will generate a massive like 200 plus page technical doc with all of the information, all of the architecture, all of the flowcharts and diagrams. You can see like it just generates a massive amount of context and really understands the project deeply. And then you can press one of these buttons here and you can like add a feature or refactor the codebase or whatever you want to do. But when you do that, you're expected to write a very detailed um prompt or instruction essentially what you would pass like a junior developer and then it will go away and essentially start executing that task and take about 5 minutes per file to run. So I've done tasks here that took four days. I've done tasks that took 8 hours, 9 hours, but it's very very comprehensive and I've had it generate over 200,000 lines of code even though they promote that it can generate over 3 million. So, just an interesting tool, something worth checking out, and I've been using it recently, especially because these kind of context documents are just extremely interesting to look through. Next tool on my list is Zapier. Now, this isn't really an AI tool, but I figured I'd mention it because it connects to a lot of my AI tools. Now, this is essentially something that you can use to build visual flows and run all kinds of automations based on triggers or events. So in this case, I was talking to you about the TLDV meeting recorded and then like sending a message in Discord. So I have this hooked up to my TLDV. I have these filter conditions like make sure this is a dev launch strategy call for example because that's the one I want to run this automation on. And then send a message in the channel where it says hey like this meeting was finished or completed. This was the date. This is who it's with. You know you can watch the meeting here. And then I have another message I can't show you because it has some sensitive data, but it sends me a direct message with essentially information that I need in order to proceed to the next step with the student. So, Zapier, super cool. I have like 100 plus Zaps in here. Again, they're kind of confidential, so I can't show them all to you, but something I use a lot. All right, so that is a pretty detailed list of most of the AI tools that I actually use. Now, in terms of frameworks, I use a lot of AI frameworks to build AI agents and build my own AI tools. And I'm going to quickly go through them. Now, I pretty much always use Python and then I use Langchain, Langraph, and then I have some notes, so let me look to the side of my screen. I use LiveKit. This is for uh like voice agents. I use VPY. Same thing for voice agents depending on the type of ones I'm trying to build. I use Deepgram Graham, another one for voice agents. And then I use all kinds of other tools like Injest, for example, for AI orchestration, uh, and probably a bunch of other ones that I'm forgetting, but those are the main frameworks. And typically I'm working with Langchain or Langraph and then connecting it up to something like a Chroma DB database and some other various kind of like helper modules and libraries. There are so many AI tools out there. I use a lot of them, but these are the ones that came to the top of my head when I was thinking of crafting this video. Hopefully, you found it useful. You learned about an AI tool that maybe you've never seen before, and now you're going to go play around with it and kind of have some more productivity or some more usefulness, I don't know, from these tools. Anyways, if you guys enjoyed the video, make sure to leave a like, subscribe, and I will see you in the next one. [Music]",unknown
7V7cf24aNTM,"bug bounties. Now, what this means is if you find a bug or an exploit in the software and you report it to them, they'll pay you. So, they'll give you a flat fee amount uh based on the type of bug, the severity of the bug, etc. Now, famously, Google had some bug bounties that were like a million dollars. I remember I was at uh ETH Denver and I was sitting beside some guy in like the cafeteria and I was asking him what he does and he said, ""Oh, I do bug bounties."" I was like, ""What do you mean you do bug bounties?"" He's like, ""Yeah, literally all I do every single day is I just go and I like hack different websites and companies and I get paid to do that."" I'm like, ""Like like you make a living doing that?"" and he's like smiled and like looked at his friend and uh he was like, ""Yeah, like the last one I did was $250,000 for a bug bounty.",unknown
DlKR3zSwUv8,"A lot of people when they get into AI engineering, they realize that it's really software engineering but just using AI, right? Like having some AI as a component of it. And one of my friends actually is an AI engineer. He's currently working for a large startup. He makes a ton of money. And when I ask him about this, what he tells me is that his job is about 20% working with AI, right? Fine-tuning, prompt engineering, maybe, you know, pulling in some model or training it on some custom data. The other 80% is really just software engineering and building the system around these AI models to have them work reliably in production. That's the hard part. And if you can get good at that, you will be a good AI engineer.",unknown
d_LbQwoWI7I,"If you're interested in becoming an AI engineer, then watch this video. I'm going to give you a complete road map, a step-by-step guide on how to break into this field for beginners. I'm going to try not to use a ton of fancy terms. I'm going to make this very clear and easy to understand. And I'm going to explain practically how you actually could become an AI engineer in 2025 and beyond. Okay, so let's start by defining what an AI engineer is. Now, this is actually pretty difficult. It's not something that I can give an 100% answer on and that's because this role is constantly changing. AI is evolving extremely fast and all kinds of companies have a different idea of what an AI engineer should be. So in this video I want to focus on a very practical pragmatic AI engineer which really means that you're responsible for implementing AI into software systems. It doesn't mean that you're going to build an AI model from scratch. It doesn't mean that you're going to become the next OpenAI and train something like, you know, GPT5. That's really reserved for people that are significantly smarter than probably all of us that have done massive amounts of academic research, PhDs, you name it. That's not what I'm talking about here. And that's actually really much more machine learning and like AI research than it is practical AI engineering. Most of the AI engineering roles that I'm aware of involve using existing tools, things like Langraph or Langchain, maybe doing something like fine-tuning an LLM, doing some prompt engineering work, understanding how to use these APIs, which LLM is better for a specific task. That's really what I'm talking about here. So to summarize it, it means you are actually really practically building systems that use typically existing AI models or kind of base LLMs. You may be doing something on top of that or enhancing the system. But a lot of this is actually core software engineering work that just happens to revolve around using AI, right? AI really being all of these crazy models like LLMs or existing machine learning models that people much smarter than us have already built. So with that in mind, let's get into the road map. Now the reality here is that if you are doing this, you are going to be using Python. Python is just the number one language when it comes to machine learning and AI. It's very easy to learn. It's used in this field massively and all of the main frameworks are written in Python. So, you're going to need to learn Python. And what that means is that you need to have a really strong foundation in Python and programming in general. This means you should understand loops. You should understand variables. You should understand functions. You should know more specific Python features, even more advanced features, things like decorators, generators, potentially meta classes. You should understand packages, modules. I have all kinds of Python road maps out there. But the point is, you're probably going to have to spend at least two months here learning Python, getting good at it, and just learning standard software engineering with Python before we can dive into AI and ML. This is not a beginner field. It takes a good amount of time to get good at this. So, make sure that you have a really strong Python foundation. Now, once you built a strong foundation in Python, there's a whole list of tools that you're going to need to learn that are very likely going to be used for an AI engineering rule. Now, the first is Git and GitHub. That's for version control and essentially saving and checkpointing your code. You're going to need to understand how to use various IDEs or editors, things like PyCharm, cursor, VS Code, etc. You're likely going to need to understand basic bash commands or terminal commands. So, how to navigate a command line interface, just something that's pretty common when it comes to being a programmer or software engineer of any type. Then you'll need to understand things like virtual environments and how you isolate dependencies for your Python projects. And then lastly, things like Jupyter notebooks so that you actually can run and experiment with different Python code. Okay, so that's most of it. And then additionally, I will mention that having a math background or a computer science degree would obviously be helpful here. However, it is not a requirement. And in fact, most of these AI engineering roles that I've seen don't actually require a lot of advanced mathematics. Like I said, in most cases, you're actually using existing models and building systems around that as opposed to really developing the models or the LLMs on your own. So once you've built a core foundation in Python and the core software engineering tools, the next thing that we want to move into is understanding LLMs. Now this is one of the main things that you're going to be using, especially in today's age. You know, in 6 months it might change, but for now it's LLMs. And that means that you need to understand what an LLM is, the architecture of it, how it actually works on a lower level. So you know you get some input, how do you actually generate some output and then you should be aware of a lot of the different LLMs that exist and when you should use which one. For example, why would I use Gemini over using GPT5? Why would I use Claude or why would I use a thinking or reasoning model? These are all important things that you need to understand. Now, beyond that, you want to start learning how to use the APIs for these various LLMs. So, I'm talking about things like the OpenAI API where you're able to actually interact with GPT models and send a request to them and get a response back. Same thing like maybe with the Deepseek API or the cloud API is not too hard to do that, but it's something that we need to have a foundation and understand how to do essentially. After that, I'm going to recommend looking into tools like Olama or like Docker Model Runner. This allows you to run LLMs locally on your own computer. And again, it's important to understand how to do that. Essentially, in this section, you want to understand what LLM are. You want to start using them, and you want to start interacting with them from code. Now, let's keep going here, but I want to share with you the reality when it comes to learning these skills. Now, AI engineering is one of the fastest growing tech roles today. There's thousands of job postings asking for real hands-on AI skills where just reading articles or watching tutorials isn't going to be enough. Now, studies show that you only retain about 20% of what you passively consume. But when you learn by doing, writing code, building projects, and getting hands-on experience, your retention can jump to 75 to 90%. Now, that's exactly why I recommend Data Camp, who's sponsoring today's video. Now, I've personally used Data Camp for years to level up my Python and AI skills. And their associate AI engineer track is built for developers who want to get into AI fast with a hands-on project focused approach. And its curriculum mirrors almost exactly what I'm sharing with you in this video. Now, with Data Camp, you'll write real Python code in your browser, get instant feedback, and build practical skills step by step. Now, here's what's inside this track. You have core AI building blocks. everything from Python foundations to APIs, vector databases, and LLM workflows. You have practical AI projects like building chatbots, summarization tools, and automation scripts that you can actually show off in a portfolio. And you have job ready skills like deployment basics, prompt engineering, and understanding how to integrate AI into real applications. Plus, there's a direct pathway to earn an industry recognized AI engineer certification that you can showcase on your resume and on LinkedIn. Now, I wish that this existed when I started out. It would have saved me months of trial and error. Instead of jumping between random tutorials, this gives you a clear guided path to become a job ready AI engineer. And right now, you can get 25% off using my link below. So, if you're serious about learning AI the right way by building, experimenting, and coding from day one, this is the best place to start and you can check it out. Okay, now let's move on to the next section in this list, which is AI frameworks. Now, it's one thing to understand Python to be able to use LLMs, but as you start getting more advanced, you'll need to create more advanced AI systems and typically AI agents. Now, I have a few frameworks on my list that you need to be very comfortable with. Obviously, there's a lot more and you can continue to learn more frameworks, but these are the core ones for AI engineering. Now, the first one is going to be Langchain. Langchain allows you to really easily create AI applications and call into popular LLMs like GPT, Claude, etc. Now, this will let you do things like create AI agents, have tool calling capabilities, utilize vector databases, create retrieval augmented generation programs, which we'll talk about later, and it's really the starting ground for using AI a little bit more professionally. Now, after Langchain, we have Langraph. Now, Langraph is much more complicated than Langchain. It's kind of the level up. And this allows you to do orchestration of AI agents and AI systems in general. Rather than just having kind of this passive AI agent that responds to events, you can actually have essentially a flow or a graph. That's why it's called lang graph that you can run an AI system through to get the exact desired outcome that you want. Now I'm describing this very briefly because there's a lot to go into but I would recommend start with lang chain build a few applications with that then move on to lang graph and you'll see the benefits of it and how you can create this graph and have a lot more control over what your agents and AI systems are doing. Now after that or even kind of at the same time depends on what you're building I recommend looking at transformers and hugging face. Now, HuggingFace is kind of like an open- source platform that has a ton of different models already available for you to use. So, you can have an image classification model or a sentiment analysis model or whatever you want. It's probably already available on there and you can use it within Python by using the transformers and kind of the hugging face packages. Now, you can download the model, you can fine-tune it, you can run it exactly as it is. It's very useful and I recommend looking into those packages. Now, of course, there's other ones like NumPy and Pandas, which are always going to be good to know and a strong foundation, and some built-in modules like the OS module, the SYS module, the path liib module, but those aren't as important. Okay, now let's move on to building projects. Once you've learned these frameworks or really while you're learning these frameworks, you should be working on building some AI projects. Now, I have three simple ideas for you. Obviously, go above and beyond this. Don't just stick with these, but I think these are at minimum what you need to build during this road map. Now, the first is going to be a simple AI to-do list. Essentially, you want to have an AI agent that will be able to create to-do list items, remove to-do list items, give you a summary, check them off, etc. Right? Pretty straightforward, but an application that you need to learn how to build. The next application I recommend is an AI web scraper. Now, I actually have many tutorials on this channel going over how to do that, but it's very interesting to see how these work. And it kind of combines some core Python skills with some AI skills, which I think is really valuable. And the last project idea I have is something like an AI content helper. So, an AI that can collaboratively help you build out content ideas, look at past experience, pull in data from something like YouTube or LinkedIn or Twitter, and give you recommendations. Now, look, there's a lot of other stuff that you can build. I'm just giving you three simple ideas that I would recommend you attempt or at least something like that so you understand kind of the core AI foundation and you know how to build kind of basic AI applications. Now let's move on to the next topic. The next topic on my list is advanced LLM skills. Now once you know how to use the LLMs on a simple level and within some of these frameworks, you need to move on to some more advanced topics. Now I have some content on my monitor here, so I'm just going to read it off. The first thing that I have is prompt engineering. essentially how do you create the best prompts and how do you reliably get an LLM to act in the way that you want. Then we move on to fine-tuning. Now this involves taking an existing foundation model, so essentially a large model that's already been trained and passing it a smaller amount of data and fine-tuning it on that particular data or a particular task. An example of this could be taking an existing model. to something like Mistl, you know, smaller model that's open source that you could run on your own computer and passing it maybe 10,000 examples of hockey scores or hockey information and having it predict specifically based off that data. What you can do is you can essentially bias these models. You can pass them some information to fine-tune them and they can have significantly better results in a particular task with a limited amount of training data by using some of the base knowledge that they already know. That's not the best explanation of fine-tuning, but you know, hopefully you get the idea. Now, the next thing on my list is embeddings and vector databases. Now, rag or retrieval augmented generation is a really big topic in the LLM and AI engineering space, and you need to understand what embeddings are, how you store data in, for example, a vector database, how you retrieve that data, and how retrieval augmented generation works within an LLM or within some kind of AI system. To put it simply, this means kind of extracting relevant information and passing it to an LLM to augment the information that it has so it can give you a better reply. This is extremely useful and it's one of the most practical use cases of LLMs by being able to feed it your own data or very custom data when it needs it. Next topic I have is context windows. Pretty straightforward, but you should understand the size of the output and input for these various models. why you would use a particular model, the type of data it can accept or that it can output. Moving on, we have architecture. This obviously gets a little bit more complex where we're diving into lower level concepts like how is this model actually designed? How are the layers set up? How is it actually outputting something? Um, again, this kind of goes with context windows as well and just generally the kind of layout and architecture of these more advanced models which I myself am not an expert in. Then we have things like MCP servers. How do we build an MCP server? How do we deploy an MCP server? How do we write an MCP client? How do we connect MCP servers to our AI models? Should understand everything about them because it's really the next wave of AI and what a ton of companies are pushing out right now. Okay, that's it for that topic. Let's move on to the next one. The last topic on my list here is LLM ops or LLM operations. Now, it's one thing to have an LLM system or have some AI system running on your own computer. It's another thing to have this working in production reliably and with a bunch of users. AI in general is notorious for working sometimes but not all the times. And when we're creating software systems that are scaling to maybe millions of people, it's very important that if we are going to use AI that we build it correctly so it works reliably. So in this section I'm talking about things like Docker and Kubernetes, LLM orchestration, things like testing, things like retries, fallbacks, observability, logging, building advanced systems around these AI models or these um just general models that you have and then things like using fast API, database design, overall architecture of a program. Again, it's one thing to actually have a system that works on your local computer. It's another thing to have this working in production, be deployed, have observability into what's actually going on, have logging, and being able to write things like fast API endpoints to protect various resources to assign credits or rate limiting to users. There's so much more than simply AI. And that's why a lot of people when they get into AI engineering, they realize that it's really software engineering, but just using AI, right? Like having some AI as a component of it. And one of my friends actually is an AI engineer. He's currently working for a large startup. He makes a ton of money. And when I ask him about this, what he tells me is that his job is about 20% working with AI, right? Fine-tuning, prompt engineering, maybe, you know, pulling in some model or training it on some custom data. The other 80% is really just software engineering and building the system around these AI models to have them work reliably in production. That's the hard part. And if you can get good at that, you will be a good AI engineer. Okay, so that is my AI engineering road map. Let me know what you think of it in the comments down below and I will see you in another video. [Music]",unknown
wEZD-aSsmhk,"AI frameworks. Now, it's one thing to understand Python to be able to use LLMs, but as you start getting more advanced, you'll need to create more advanced AI systems and typically AI agents. Now, I have a few frameworks on my list that you need to be very comfortable with. Now, the first one is going to be Langchain. Langchain allows you to really easily create AI applications and call into popular LLMs like GPT, Claude, etc. Now, after Langchain, we have Langraph. Now, langraph is much more complicated than lang chain. [Music]",unknown
T_k3v9gU3jg,"Understanding LLMs. Now, this is one of the main things that you're going to be using, especially in today's age. You know, in 6 months, it might change, but for now, it's LLMs. And that means that you need to understand what an LLM is, the architecture of it, how it actually works on a lower level. So, you know, you get some input, how do you actually generate some output? And then you should be aware of a lot of the different LLMs that exist and when you should use which one. For example, why would I use Gemini over using GPT5? Why would I use claude or why would I use a thinking or a reasoning model? These are all important things that you need to understand. Now, beyond that, you want to start learning how to use the APIs for these various LLMs. So, I'm talking about things like the OpenAI API where you're able to actually interact with GPT models and send a request to them and get a response back. Same thing like maybe with the deepseek API or the cloud API.",unknown
P85C5igr7bA,"Today, I'm giving myself a challenge. I want to see if I can build an entire application in just a few hours with the assistance of AI and then actually push it out into production and deploy it. Now, a lot of times on this channel, you guys watch really in-depth tutorials from me. In those situations, I already have the code written and I'm just walking through it line by line. Rather than doing that, I want to show you what my real development process looks like. So from planning, building errors, then eventually into deployment and how I do that as an experienced developer with the assistance of AI. So this will be a shorter video, more of kind of a highlight reel of me building this application, but I think it will be interesting and hopefully I can share a lot of best practices and tips with you. So with that said, let's hop over to the computer and get started. So like the video title says, I'm not going to be using VS Code or Cursor for this video. I'm going to be using Warp. Now I've talked a lot about Warp on this channel. I've demoed them. have gone into in-depth tutorials and they are a long-term partner of this channel. However, I've never really built a full-scale application with it. So, I decided today we can try that out and see if this tool is actually capable of doing that. Now, if you're not familiar with Warp, this is an agentic development environment. It looks kind of like a terminal. And their basic philosophy is that we're really moving more towards prompting rather than writing a ton of manual code. So, rather than having 80 90% of the screen taken up by a code editor, most of it should be actually interfacing with the agent. And then of course they have the ability to edit code, a bunch of other features, etc. But it's pretty cool and I'll kind of show you how it works in this video. Anyways, let's get started with my project idea. Now, before I jump into anything, I always like to come up with a pretty detailed plan. Have a good idea of the tech stack that I'm going to use as well as what I actually want to build. I always start with an MVP, so a minimum viable product or the minimum number of features that make what I'm building valuable, and then I'll add more to it later. So, in my case, I want to build a Discord bot. Now, I have a Discord server right now for my dev launch program. We have a bunch of students in there and for every student, we create a private channel and it's very difficult to manage all of those private channels, make sure that we create them properly. But more importantly to have kind of a history or a log of everything that was said in those channels and pick up the context when we have, you know, 50, 60, 70, 80 students, etc. So, my idea here is to make a Discord bot that can help me with some of those actions. So it can log and store all of the messages that are sent on Discord by who, in what channel, at what time, and then I want to connect an LLM to that so that I can quickly summarize all of the messages or ask questions about kind of a chat or a student and get really detailed information back. So that's kind of my basic idea. And what I want to do now is start fleshing this out. So I'm going to go into warp. I've just created a new um what do you call it? A directory here. So, I'm just going to tell it here create a new readme file where I can start putting my plan. Keep it empty. Okay. So, when I do it, by default, it's going to know that it needs to go into agent mode here. And then it should make a new file for me inside of this folder. And then I'm going to start kind of using the voice mode here with inside of warp, dumping my thoughts, and then starting to come up with a more structured plan. That's because I find these models always perform better when we have a document that outlines what we want to do. And then I also want to start creating some rules for this project in terms of the text stack that we're going to use, uh, the code process, how we're going to split up files, etc. to make sure this actually stays clean because I'm not trying to vibe code here. I'm just using AI kind of as an assistant. So, what I'm going to do here is just type ls. We see the readme file. If I want, I can open this by just controllclick. We can see that it's empty right now. And then I'll go on the left hand side and I'll start going into voice mode and kind of asking it what I want. Okay. So, I'm going to go voice input. And I'm just going to essentially stream my thoughts, kind of what I'm thinking, and then have it give me a structure. Okay, so I just used the voice mode here. I got a pretty detailed prompt, and I'm going to go ahead and press enter, and I'm going to ask it to create the plan here with 03 because it can actually do kind of a plan before it starts um creating all of this stuff. And you can see it's going to analyze our Discord bot requirements and create the structured plan for me. All right, so let's wait for that plan and then I'll be right back. All right, so I can see it's made the plan here. So I'm just going to open up the file, make sure it looks good. I'm going to adjust any of the stuff that I need and then we'll continue from there. All right, so I just took a second here and I generated a rules file for this particular project. Usually best practice when you're doing any AI coding just so that I have all of the stuff specified. So I want to use Python 3.11, always use UV. I want to have all the text stack in here just to make sure that I have as much context as possible and that the model's not going to steer wrong. Now that I've done that, I also show you that if I go to MCP servers here in Warp, I created the GitHub MCP server connection. So, I'm just going to ask it to initialize a new git repo for me just so that I can start storing everything um and not lose any of my work. So, I'm going to say init a new remote get repo for me for this project. I'm going to let it do that and then we're going to move on. And also, if while we're doing that, we can proceed without the plan. I can actually open up a new window here and start doing some coding as well because I'm able to have multiple agents running in parallel here. So, I can start doing some work in another tab while I wait for this to go. And we can see here that it might ask me to run the tool. So let's go ahead and press on run. Uh and I'll continue from there. So the setup is pretty much done. I've got the rules file. I connected to my MCP server. I have the plan generated. I know at a high level what it is that I want to do. Now what I'm going to do is start building this step by step. So rather than trying to code the entire thing at once, I want to start by just being able to connect to a Discord server and just log some of the messages. So we'll start with a basic kind of database connection and just actually receiving some messages. Then we'll start adding the various commands. So, same thing. I'm going to go in voice mode here because I prefer using the voice input and I'm going to tell it to begin with that step and then we'll proceed after that. So, from this point, I'm going to throw the face cam off just cuz it's easier to work without the lights on. And what I'm going to do now is start connecting to the Discord server. So, I'm going to make a kind of sample Discord server in a second so that I can test this out before I put it in my production one. And then it's giving me a few steps that I need to follow here. So, I'm going to leave that open in one tab. And from here, I'm also just going to have a look at some of the code to make sure that this is what I want. So, let me open up the main.py, for example. I'm also going to open up the bot.py. Okay, so we just have this. Hello from Discordbot. Okay, let's close this one here. And I want to just quickly read through this. I also can, of course, modify this code if I want to. Okay, so this looks fine for right now. I also want to open up the requirements.txt file. So, let's open that in warp. And this has a bunch of stuff that we don't need. It has all these hashes. So, I'm just going to tell it to clean that up and then we'll go from there. So, I successfully got the bot in my test Discord server here. Now, what I'm going to do is just type uvun and then bot. py and let's see if this works. Uh, and we got an error. Okay, so let's debug from here. So, I just forgot to do one of the settings here when I was setting up the bot. I needed to enable some of the privileged intents. So, it looks like it slid in. Let's say hello world. Okay, and it picked up that message. YouTube test tech with Tim. Hello world. Okay, let's go here. Let's make a new channel. You know, Tim channel or something. Okay, let's go another test. Looks like it's working. Okay, we can see the bot is connected and that's a good start. All right, so we've got the logging set up. Now, I want to start storing this stuff in the database and kind of move on to the next step of my plan. So, let's shut this down for right now and let's keep going from here. So, I just enhanced this a little bit just to get a bit more information. And so we have the metadata. Let's test again. And we can see that we're kind of getting all of this stuff printing out. So I can see the user as well as the channel that they're typing in the, you know, type of the message, etc. Okay, cool. So let's shut that down. So moving on now. I want to start setting up the database. So I actually just set up a database here in Lenode. This is typically what I use for databases. So, what I'm going to do is copy all of this information, give it over to Warp, and tell it to start logging and storing all of the messages based on the database schema that we set up in the plan. Uh, and then we'll have the database kind of deployed and ready to go. And then later, we can deploy out the full uh kind of bot application. So, it's been a few minutes here, but I have successfully got the database connection to work. There was a little bit of debugging I had to do there because the connection was messing up. I had to add my IP address as a valid connection. We can see we got the logging here. And now we're actually storing messages in a Postgress SQL database. So if I go here, hello world, what is up? You can see that the bot grabs that, picks it up, what channel it was in, and then stores it. Let's do one in here, hello world. And then same thing, picks up the general channel, and then it should store that for us as well. Okay, cool. So what I want to do now is I want to start setting up some of the commands so to test to make sure the messages are correct. So I'll start setting up some filters where we can get the past messages for a user and for a channel. And then once that works, we can add the AI component, start summarizing it, storing it in the database, etc. Okay, so let's go ahead and get that started. All right, so I've been working away here and I just got one of the first commands to work, which allows us to see the history of messages. So for example, I can go exclamation point history, you know, at Tim and then I can do something like let's look in the general channel. So we can filter by channel and by person. When I do this, it should give me all the messages by myself that are in that channel. We can see that it pops up here. We can also do something like history limit equals 2. This will just give us the two most recent messages. So let's see right here. And we get the two messages. Okay, so that's a pretty good start. At least we can get the recent messages. We can filter by channel. Now that we have that, what I want to do is add the AI component where essentially we can just ask a question like, what has Tim been talking about in this particular channel? And then it will give us the response back. So, let me add that and I'll be right back. All right. So, it's been a little bit of time here and I was able to get the AI integration working now in terms of summarizing the different messages. So, again, a little bit of back and forth here, but now you can see I have this summarize command. I can pass a channel or I can pass a name. I can pass some limits. And then it gives me kind of this nice embedded message. which I got to make it look a bit better. But, you know, we have key decisions, main topics discussed, you know, multiple commands related to viewing chat history, summarizing messages because that's what we were doing. And then I just made a new channel where I was just talking about some crypto stuff just to make sure this is going to work. And then if I go here, you can see it says mentions Bitcoin reaching 100K, you know, excitement and interest in crypto uh currency, etc., etc. So, that is pretty cool. That's kind of the main thing that I wanted to get. Now I'll add one more command that allows me to kind of like ask a question about the chat so it can give me direct feedback. And then from there I think we're good to go ahead and deploy this and actually start using it in production. All right. So a few prompts later we got this new feature where I'm able to do this ask command. We can see Tim's birthday is on July 20th. I just put that in the channel. And then if I do something like you know ask and then I'm going to have to do the channel. So Tim channel how old is Tim? Uh let's see if it can give us that result. We're just using a simple LLM call here. This should just take one second. And it says Tim is turning 25 years old. Boom. There you go. So, the ask feature is working. Okay. So, that to me is pretty good. Obviously, there's a few, you know, modifications we could make. We could improve it, but for now, I want to move to the deployment. So, we already have the database deployed. And pretty much what we need to do is just deploy the bot on some service where it will be running 24/7. So, we have a few different options on how to do that. What I think I'm going to do here is just use Railway. I used this in a previous video. It's very straightforward to do the deployment of a Python application. So, let me actually go here. Let's open up a new tab. I'm going to say how can I deploy this app with Railway and I'll get this to give me the instructions on how to do that. So, let's go proceed without a plan cuz I just want it to tell me what to do and then we'll go ahead and start the deployment process. All right. So, it gave me some instructions here. It looks like it should be pretty straightforward here to do it from the web, but I think there are a few files that we potentially need to set up here. So, I just asked it, can you set up my project to have the correct files to work on railway? So, it should hopefully do that. We'll use the MCP server to push this up to GitHub to make sure that we have the uh most valid version here in our GitHub repo. And then we should be good for the deployment. We might need to change a few things in terms of the IP addresses, the environment variable files, etc. And then we should be good to go. All right, so I just finished doing the deployment here and we can see that we're getting the log showing up in Railway. The Discord bot is online and really that's pretty much it. I mean, we just completed the entire application. I really hardly wrote any code manually at all. I pretty much used the AI to do that. And the reason why I was able to be relatively successful here and it didn't take me too long to get this running is because of all of the setup steps that I did, right? planning, adding the rules, going step by step, not trying to generate massive amounts of code at once. Also, I was obviously checking through a lot of the code. So, I would, you know, go into a separate window here, type ls, for example, take a look at some of the files. You can see now at this point, we have the docker file, the initialize the db, the llm, you know, pi project toml blah blah blah. And I was checking these, making some small modifications as I went uh directly here inside of warp. So, overall, I would say this challenge was pretty successful. Obviously, there's a lot more work that we could do on this application, but for now, I'm super happy with that, and I think I'm going to end the video here. Let me know what you guys thought. If you want more videos like this, then definitely leave a comment down below. And I look forward to seeing you in another video. [Music]",unknown
NvJ1bqEgbEk,"AI engineering is one of the fastest growing tech roles today. There's thousands of job postings asking for real hands-on AI skills where just reading articles or watching tutorials isn't going to be enough. Now, studies show that you only retain about 20% of what you passively consume. But when you learn by doing, writing code, building projects, and getting hands-on experience, your retention can jump to 75 to 90%. Now, that's exactly why I recommend Data Camp. Now, I've personally used Data Camp for years to level up my Python and AI skills, and their associate AI engineer track is built for developers who want to get into AI fast with a hands-on project focused approach. and its curriculum mirrors almost exactly what I'm sharing with you in this",unknown
Haa4Tw6MWUk,"If you're interested in becoming an AI engineer, then watch this video. Now, the reality here is that if you are doing this, you are going to be using Python. Python is just the number one language when it comes to machine learning and AI. It's very easy to learn. It's used in this field massively, and all of the main frameworks are written in Python. Now, once you built a strong foundation in Python, there's a whole list of tools that you're going to need to learn that are very likely going to be used for an AI engineering role. Now, the first is Git and GitHub. That's for version control and essentially saving and checkpointing your code. You're going to need to understand how to use various IDEs or editors, things like PyCharm, Cursor, VS Code, etc. You're likely going to need to understand basic bash commands or terminal commands. So, how to navigate a command line interface. Just something that's pretty common when it comes to being a programmer or software engineer of any",unknown
ebfKOXkegeY,"what an AI engineer is, which really means that you're responsible for implementing AI into software systems. It doesn't mean that you're going to build an AI model from scratch. It doesn't mean that you're going to become the next OpenAI and train something like, you know, GPT5. That's really reserved for people that are significantly smarter than probably all of us that have done massive amounts of academic research, PhDs, you name it. That's not what I'm talking about here. So to summarize it, it means you are actually really practically building systems that use typically existing AI models or kind of base LLMs. You may be doing something on top of that or enhancing the system, but a lot of this is actually core software engineering work that just happens to revolve around using AI.",unknown
1y_VE_3_320,"I just found an AI agent that doesn't just read your code, but it spends days understanding it and then spits out a 200page technical spec before touching a single line. Now, I've been messing with it for the past few days, and it's been able to generate over 130,000 lines of code from a single prompt. Anyways, let me hop over to the computer here and show you how it works. So, the tool that I'm talking about here is called Blitzy, and it works a lot differently than all of the other AI code editors or models you've probably seen before, and it's actually designed to work with them, not against them. Now, the philosophy here is rather than doing all of these small iterations and kind of minor changes one by one. Blitzy can actually generate hundreds of thousands up to actually 3 million lines of code changes based on a single prompt. And it's able to do this by deeply understanding your codebase and generating really in-depth technical specs and documentation before it actually goes and makes these changes. Now, this works in a few days. So, I'll send a prompt and then I'll wait, you know, one or two days and I'll get the result back depending on how many files are being changed. It's not a super fast agent like something cursor where it's, you know, modifying the code in a few seconds or a few minutes. And I want to walk you through the platform because it's really interesting. Now, full disclosure here, the Blitzy team did reach out to me about a month ago to sponsor a video. Since then, I've been messing around and playing with the platform. And while they did want to sponsor this, it is genuinely very unique. I've never seen something like this. They do have a free tier, so you can mess around and play with it. And genuinely, I think this is extremely interesting, which is why I want to show it to you because it does something I've never seen before, specifically around the really deep context and the technical specification, which is pretty mind-boggling. Anyways, let me hop over into Blitzy here and I want to show you how I've been using it, the code that it's been generating and give you kind of a platform overview so you can see how it works. So, I've just signed into my Blitzy account here and you can see that I have an existing project which I'll go through in a second. From here, you can also make a new project and you can either start from a new product or from an existing product. In my case, I'm much more interested in the existing product because a lot of the current AI tools work to go from like zero to one or a quick MVP or an idea, but they fall apart when they need to understand a really large codebase. So, the way that I've been testing Blitzy and the stuff I'm going to show you in this video is actually on the code base that I generated for my previous failed startup. You guys might know about a year and a half, two years ago, I was working on a tech startup. I wrote hundreds of thousands of lines of code to build a mobile application which was kind of like a cognitive training app for athletes. I'll put a few kind of screencasts on video so you can see what the app looked like. That startup ended up failing. But I wanted to see how this tool would perform on that codebase, something that I obviously understand very well and if we would be able to jump in there and start being productive right away on a very massive codebase, not something that's, you know, a quick YouTube tutorial project. So anyways, I'll dive into that in a second, but I want to show you the flow on creating a new project. So if I go here and I select existing project, I can give this a title. Let me just call this, you know, startup app or something. And I'm just going to show you what actually happens when you do this, you can see the flow. So you can add this directly from GitHub. So in my case, I'm going to select my organization. So just for demo purposes, I'll choose this online chess game. I'll select the master branch and then go ahead and press continue. Now what it's going to ask me to do after this, so it's just loading the codebase here, is give it some context on the project. So you can see that it's prompting me here just to give a bit of additional information. So obviously the more data we provide about the project, the better the result is that we're going to get. We don't have to put anything here, but we can insert files or code blocks or mermaid documents or we can do all kinds of formatting or tables. And what I'll do is I'll just give it some really quick context and we'll go from there. So, I'm just going to say something like, ""This is an online multiplayer chess game made with Python, Pygame, and websockets. I made this during a 12-hour coding live stream. There's definitely a lot of messy code. There's no testing, and this was meant to just be a demo project. Okay, so we'll just give it a little bit of context here so it kind of knows what I was building. And then what I can do is go directly to build the text spec. So, this is the important part of Blitzy. I'm going to approve this prompt and press on continue."" And now what it's going to start doing is ingesting this codebase, understanding all of it and writing an extremely detailed technical specification that outlines everything that's used, the tech stack, the files, the testing coverage, the uh what is it, the back end, the front end, like it generates literally a 200page document, which I'm going to show you in 1 second. And you can see that this will take a bit of time. Usually it takes between 1 to 3 days. In my case, it took about a day for the previous project. And I want to show you for my startup codebase cuz I just wanted to go through the flow here what that text spec looks like. So I just opened up my existing project in Blitzy. And this is the tech spec. Now the start of the tech specs. So all of these kind of 0 whatever is the most recent change that just made because I just got it to actually add some advanced testing which I'll show you in a second. But if I scroll through here, you can see and I'll go into a few sections smaller in a second. It's literally like this extremely detailed um technical specification that also includes all of these different flowcharts. So it explains like how my app launches which I verified is correct. App launch user authenticated. If no, go to the authentication system. Select the provider Facebook, Google, OOTH, whatever. Uh validate the token. If there's no token, go to the display error. Go back here. Otherwise, Firebase O profile setup. Enter the name. Right? So I have these kind of onboarding steps in my application. And then it has all of these different kind of decisions that we go through. And it's very useful to actually see this, right? And something that a lot of devs are not going to make themselves. Then it says the daily training workflow and that explains exactly how that works and all of the different events that we have and how this is set up. Same thing here in terms of like the workout complete and how we actually uh calculate the scoring because our app was called velocity and we had like a velocity score for all of the users. And you can see there's all this stuff here. We had like an anti-cheing thing there. We have the social actions. So following user, workout post, like post, view profile, etc. We have all of these sequence diagrams in terms of all of the different architecture and components that we have like fire store, cloud functions, cloud messaging, firebase analytics. Like it's insane just how detailed this specification actually is. And it includes things like our firebase services, our ooth providers. I'm not going to go through everything, but this was really interesting for me to read through because it showed me in, you know, a lot of detail and visually what the architecture of my application actually was. And even though I probably should have made these diagrams myself, obviously I didn't when I was coding this out as a startup. And now I have all of them here. And this is how the app is able to understand and have this really deep context. So I mean, I can keep scrolling here and you guys see it's kind of just neverending context and documentation. And keep in mind obviously this is a lot because I built you know a really large application. I spent about 2 years coding this out and that's why we have all of these different diagrams. Okay. So that's that right? So it took you know a day or so to generate this um what do you call it document and what will actually happen with Blitzy is while you're adding new features and generating new code it will continue to update this document for me so that it always has the kind of most recent state of the application. So let's say we've got the technical spec out of the way. Right. Again, it takes a bit of time, but I've already done that for the video. What we can do next is we can obviously start coding stuff, right? And generating features. So, for example, we can go to build here. And then from here, we have the ability to do these six things or have a custom kind of feature. So, we can add a feature, refactor the codebase, fix vulnerabilities, etc. I've used most of these. Again, I did this previously. I was working with this tool for about a month because it does take a bit of time to actually generate this code. So, for example, here I went to build and then I pressed on document code. And then I gave this a really detailed prompt asking it to actually document all of the features of my codebase that I didn't have documented. Now I don't have the prompt on hand with me because this was a while ago, but I want to show you the pull request that Blitzy actually made on my repository. So you can see what it looks like. So here's the pull request that I was talking about. You can see it happened 2 weeks ago from when I'm filming this video. And what is it? I asked it just to document the main features I believe of my backend. So, if I go here to files changed, we'll see that it actually generated all of these different specifications for me. We can view this in the uh what is markdown editor in a second to see what these diagrams look like. But we have, for example, in my feed, you know, a new readme file that was added. If we keep going, we have inside of profile a new readme file. Inside of notifications, a new readme file. It's not showing it because it's too big. And it has all of this in-depth documentation explaining how all of these features work. Again, I thought it would be more important to document the back end. So that's what I asked it to do first. Now let me just open this up in the markdown editor so you can see what it actually looks like. All right. So this is a bit better here and you can see that it explains for example how my feed system works using a fan outright design that includes daily timebased buckets. We have advertisements a content system how we fetch the feed the feed fill system. This was a pretty complex um system that I had to build for this application. Gives me the sequence diagrams gives me what happens when a post is created and essentially how we do this. again the real-time update mechanism in terms of how we're doing the reads and the writes and the real-time components and breaks all of that down. If we continue and we go to like profile for example again we have another readme file gives us the nice table explains all of the uh what do you call it features of the profile exactly how we update the profile I'm not going to go through everything but the point is that this worked quite well for the documentation and then it added all of these individual files that I wanted for all of my backend features again we have one here for social we have read me and we have these kind of in-depth charts that we can navigate through download look at etc okay so that was the first thing that I did with Blitz Now the second thing that I did with Blitzy was a little bit of refactoring and fixing all of my types. So I did this project in Typescript and as you probably know if you work in Typescript a lot of times the types can be very complicated and we oftent times skip them and we just go and put like the any type for example to kind of avoid the type checking and oftent times you're going to get some linting errors and you'll have some eslint problems etc. I definitely had that in this codebase. So I wrote a very detailed prompt. I'm going to show you some tips on how to write the prompt in a second. By the way, that asked it to essentially fix all of the TypeScript compilation errors and do a little bit of refactoring for me. So, you can see that in this pull request that it generated, it did 24,000 lines of code, right, or additions and 16,000 deletions, which is a lot. And then, if we go to files changed, we can see everything that it fixed. So, again, it redomented everything, gave me the project guide. If we click into an individual file, you can see we have all of our exports defined and all of our modules for the typing system. If we go here, we're importing the correct components, right? So, we had, you know, text from the wrong thing. So, it fixed that for us. Again, same thing. If we go here, it's fixing all of our types for us. And it's just making kind of all of these changes within all of these different files. Again, I can't go through everything for you, but you can see that it is fixed now. So, that we didn't get any of those errors. And that's the next task that I asked it to do. Now in terms of generating the prompt the approach here with blitzy is that when you do this right so once you give it action blitzy will complete probably 80% of this but there is going to be some kind of bugs there will be some errors there are going to be some things that you need to do as a developer and this isn't meant to replace the development team it's just meant to augment all of the kind of annoying work that should be able to be handled by an AI agent in fact if we go back to the original poll request you'll actually see that there's always some kind of commit here that adds a project guide. Now, if I go to this project guide, which you can see inside of the Blitzy documentation folder, this is something that's included in all of the work that Blitzy does to tell you as the developer what it actually did. So, what it completed and what you need to do next. So, if we scroll through here, you can see we get an executive summary. We get a breakdown of the development hours. Tells us essentially that this is 94% complete. And if we keep going, we can see all of the completed work. We can see this matrix where it tells us for example the functions timed out. So that's something that we would need to fix. And we can keep going all the way down to the bottom and it will tell us first of all all of the key achievements as well as what the next steps are for the human developers. So this is very helpful as a developer because it's telling you what the current status of the project is and what you need to immediately do next in the immediate term, shortterm and then medium-term, right? In some cases longterm, etc. So you can see we need to resolve the cocoa pods configure production environment. You get the idea. But this is a document that you should look at when you use this tool because again it gives you a very quick and accurate snapshot of what's been completed and what to do next and where you need to step in as an experienced developer. So Blitzy takes the approach that 80% of the work can be done by this and then the other 20% can be done by you. So what you would do is you would then open up the application after it's done all of these changes, right? You would obviously review the code just like you would for any other pull request. You could open this in a tool like cursor. You could fix some of the bugs, any of the runtime errors, etc. And then you would be good to go. So that's kind of the approach they're taking. I just want to make that clear. I know a lot of people see this and they get really scared. Oh, you know, my job as a developer is gone. But the thing is, you need to be a developer to really be able to use this tool effectively, to know what to ask for, to know how to review the code, and to fix all of those bugs that inevitably will come up when you use something like this. and they admit that which I think is great and they work in tandem with some of the other AI code editors like you could import this into cursor for example and debug some of the smaller components. Now in terms of how I generated the prompts blitzy actually has this GPT um I think it's literally called a GPT yeah in chat GPT that is the Blitzy prompt engineer. So what you can do is you can just go here. You can essentially say your kind of crappy version of the prompt which is like you know refactor everything and fix all of my TypeScript types and then it will generate a proper prompt for you. So actually let me show you how we do that. Okay. So you can see I put my you know crappy version of the prompts like refactor my codebase to make sure we're using the correct TypeScript types that we don't have any linting errors. All right. And then I'm going to go ahead and press enter. And then it will actually generate a much better version of this based on the best practices for prompting. And Blitzy also has a bunch of documentation you could go through on that in terms of talking about how to prompt properly, where to put the emphasis, things that you should include, things that you shouldn't include, etc. So, let's see the result that we get here. Okay, so you can see from that, you know, pretty crap prompt. I obviously should have given some more details here. It gave me this whole detailed prompt that goes over all the best practices on how you should prompt this model because you should spend actually a good amount of time here generating the prompt. Considering you're going to wait for a day, 3 days, you know, sometimes longer than that depending on how many files this is touching, you should spend a few minutes at least reviewing the prompt. Make sure that it specifies all of the correct context, all of the important information. So in this case it says you know you must do all of this. You must not do all of these things. Here's the technical approach on how to go about doing this. And then here are you know critical code areas that you want to avoid or be careful with. Here are protected areas blah blah blah. You get the idea. Okay. So obviously you would review this adjust it make sure that it makes sense for your codebase. But that's how I did this. When I generated the prompt I used this GPT which they provide. Now, the next thing that I did after I did all of the refactoring is, let me pull up this is I actually got it to make a new feature. So, again, this is another pull request, 13,000 lines that it modified, and I asked it to complete a feature that I never finished, which was my activity feed. So, essentially just a feed feature that showed what everyone was doing, what scores they got, what games they were playing, etc. in the app. Unfortunately, I can't run this for you because of some keys and issues, you know, with this being, you know, two years old essentially. But we can look at all of the files that it changed. And if we go here, you can see that it was working on the feed, working on the modules, on the notifications, registration. Makes sense because it needs to change quite a few things on the back end in order for this to actually work properly. Now, it also went ahead and made some code quality changes as it's specified in the PR. And you can see that it fixed some of the indentation levels and stuff for me. And if I didn't want it to do that, I could have specified, hey, you know, don't do that in the prompt. But obviously in my case, I didn't do that. So went through here, built the feed feature, and you can see all of the changes that it made mostly on the back end, which makes sense to me. Again, I don't want to go through this like super in-depth because it's not going to make sense to you considering this is not your codebase. But the point is that it's able to make a lot of changes. Okay. Now the last thing I did with Blitz Cy was I wanted to give this a real true test and see okay how many files can this actually change and this is where I asked it to essentially test my entire codebase. So again I use that GPT that you saw before. I asked it to do comprehensive test coverage essentially and then if we go here you can see that it changed 300 plus files which is actually a little bit laggy here in GitHub. It added all of the GitHub actions test flows for example. If we keep going through here, you can see that it created the test files for the back end, for the front end, test.tsx, welcome screen.t test.tsx, etc., etc. And then it actually made sure that all of these tests ran and worked properly. And there you go. Right? I mean, that's what it was able to do. Again, I can't scroll through all of this is literally 300 plus files. Anyways, the point is this was able to do a massive amount of code changes, which is kind of the last thing that I wanted to test with this tool. This particular one, I believe, took four days because it was touching a just massive amount of files. You can see it literally did 385 commits on this branch. Um, and then we were good to go. So, those are just a few examples of the use cases of this. Obviously, I did some simple stuff. I did some complex stuff. I wanted to test it out in different areas and see how it actually performed and worked. And then, if you go to build, obviously, there's some other stuff that you can do here, although I did cover most of it when I was testing this and for this video. Now, overall, this is extremely impressive to me, especially just the really deep context and understanding is very valuable. I mean, it's actually just interesting to read through the technical specification and see how you designed this, what architecture you used, all of these kind of visual diagrams, especially when you've been working on software for, you know, years at a time. And the fact that it can do that is something that I haven't seen pretty much any other AI tool be capable of. And this is really taking a different approach where it's, you know, be more methodical, think through the prompt, ask it something where you're going to expect that it takes 1 2 3 days to complete. And that means that you have to be a lot more careful in the way that you're prompting and a lot more precise. And then ultimately, you get a better result that is just significantly more work done. Similar to as if I had an engineer on my team and I said, ""Hey, get this done."" I would have to be specific in what I wanted them to do. They would go out and do it and then in a few days they would come back to me, right? and I would have the result. That's kind of the way that I view this tool. Anyways, this is super cool. Definitely recommend you guys check it out from the link in the description. With that said, I'm going to wrap up the video here. If you enjoyed, make sure to leave a like, subscribe, and I will see you in the next one. [Music]",unknown
yonxXVSAl70,"Today I'm going to show you one of the coolest features that Python has. Dunder or magic methods. Now dunder stands for double underscore and they look something like this. Double underscore a knit and then double underscore. Now you've probably seen this method before if you've done object-oriented programming in Python, but there are a ton of other ones and these are reserved or special methods in Python that map to some kind of behavior. So in the case of a nit, you probably know what this does. It's used to construct or create a new object. So when we define this init method, we're defining what we want to happen when a new instance of an object is created. Here, look at this quick example. We have a rectangle. We define some init. And this now means that when I define something like rect and I pass values two and three, we're going to implicitly call this init function or this init method. And we're going to create or initialize the object.",unknown
Je_KYIM9QJc,"If you want to become a full stack developer, then this video is for you. Now, this is one of the most confusing fields that you can get into within software development because every tutorial uses a different stack. There's so many languages and technologies. It feels like you need to learn everything and it's just extremely overwhelming. So, that's why I'm going to break it down for you in this video. And look, the reality is that you need to pick a niche, which we're going to talk about here. Focus on a core set of skills and then learn the skills that you need to know no matter what type of development you do. So, I'm going to give you a few different options here and break it down step by step. So, after this video, you hopefully have a lot more clarity. So, let's quickly break down what a full stack developer is. Now, for most applications, you're going to have both a front end and a backend. Now, a front end is the interface. It's what the user sees. So think something like a website or maybe an app on your phone and the back end is handling the data and the logic of the application. So if you're a full stack developer that usually means that you're working on both the front end and the back end. Now in reality most full stack developers are going to lean or specialize in either front end or back end. So me for example, you could call me a full stack developer because I can write code on the front end and the back end. But in reality I would lean more towards backend. That's what I prefer and that's what I'm better at. That's totally fine. And when we say full stack developer, it just means that your role is working on both the front end and the back end. That's it. Now, one of the most challenging parts about becoming a full stack developer is actually picking your stack. Now, what is a stack? Well, for any project, you're typically going to have again your front end, your backend, and then something like a database. And you might have some other components as well. Now, for each of those different components, you're going to use a different technology or a different framework. So for example, a really popular stack is the MER stack. This stands for MongoDB, Express, and then React Native. So these are the three main technologies that you're using in your project. You might have something like a LAMP stack. There's all these other different kinds of stacks that exist out there. And as a full stack developer, you're typically going to specialize in one of these stacks. So you're going to learn a front-end language or framework, a backend language and framework, and then something related to a database, right? So you need to pick one of these and you don't want to get lost going between so many different stacks. So the first step here is to pick a stack. I'm going to give you a few options for these in a minute. But once you have the stack, then you can start learning those different technologies so you'll actually be job ready. So again, stack just a set of different technologies and tools. Many developers know multiple stacks. When you're starting out, I recommend just sticking with one. And just by the way, the stack that you pick does have importance obviously, but it's not as important as the core skills that you'll learn as a software engineer. If you can build a great application in a mer stack, a lot of those skills are going to translate over into various other stacks. So don't get caught up on this step. Just pick one and then move on to actually start learning. You can always change later. Now, for the rest of the video, I'm going to go through a ton of tools and technologies that you should learn as a full stack developer. Now, you could learn all of the topics that I'm going to go through here on your own, but I personally always find that it's significantly easier and a lot faster if you run through a proper course that has a well-defined curriculum. Now, that's why for today's video, I partnered up with SimplyLearn. Now, SimplyLearn is one of the leading online platforms for tech and business education. They've got a full catalog of hands-on courses and learning programs. And the full stack development program with Genai delivered by SimplyLearn in partnership with Purdue University online is seriously well put together. It has live instructor-led classes, not just videos, and they're built in collaboration with some of the world's top universities and companies. Now, this curriculum is project-based, career focused, and covers topics like front-end, backend, restful APIs, version control, and a whole lot more, which honestly really closely mirrors what I'm about to say in this video. Now, they've got thousands of five-star reviews, recommendations from Switch Up, Core Support, and Forbes, and tons of student success stories from people who completely shifted careers after finishing the program. Now, if you're serious about getting into full stack development, check out SimplyLearn's programs. Visit the link in the description or use the pinned comment to get started and take the first step towards your next big career move. Thanks to SimplyLearn for sponsoring this video. Now, let's continue. So, on your journey to become a full stack developer, there's some core web development concepts that you're going to need to understand regardless of which stack you use. Now, first is how the web works. So, HTTP requests, responses, status codes, etc. Next is the client server model. So, you have a front end. This makes a request to a backend. The backend handles some logic. It maybe passes this to a database. Sorry. This is called client server architecture and it's a topic you need to look at. Next, APIs and JSON. So APIs expose data. JSON is the main language of communication and you need to understand these concepts. Then we have things like DNS and hosting and just basic internet plumbing. So at a high level you should understand some basic networking concepts and what happens when you actually go to a website. Sure, you visit a URL, but what happens then? What is DNS? How do you get redirected? These are all important concepts. Now, once you've learned the basics of the web, I do recommend starting out your journey here with front end. Now, like I said before, when you're a full stack developer, you have a lot of choices. But no matter what choice you go with, you are going to need to know some of the following topics that I go over here. So, the first thing that I recommend that you do if you want to get into this is learn HTML, CSS, and JavaScript. Okay? learn the fundamentals of these three languages. HTML for creating web pages, CSS for doing styling, and then JavaScript for all of the real actions of the web page, right? Anything dynamic. Now, after you do that, I suggest picking a modern web framework. Now, these are going to tie into the stack decision, but again, it's not a huge deal. Just learn one of them. You can always move on to another one later. So, you have a few different choices here. You have React, which is personally my favorite, something like Vue. You also have other frameworks like Nex.js. This is kind of a meta framework on top of React. And then you have things like Angular and there's a few other front-end frameworks as well. Now within these frameworks, you want to learn things like components, props, state, routing, forms, asynchronous calls, and then you can move on to things like CSS frameworks where you learn either Tailwind or Bootstrap. Now, there's a few other ones as well. Again, I'm not going to list every single possible stack and technology in this video. The point is there's a list of core skills that you need to know no matter what you pick. And that's mostly what I'm trying to cover here. Now, once you've learned a front-end framework, it's time to move on to talk about the back end and start learning some back-end technologies. Now, the first thing you're going to need to do here is pick a language that you want to work with for the back end. Now, the easiest language you could go with here is JavaScript because you've already learned it for the front end. Now, within JavaScript, you can use something called Node.js, which allows you to run JavaScript code on the server rather than the client. Client would be the front end, server would be the back end. So you could learn something like Express for example and this would allow you to create back-end servers with JavaScript. Now another popular option would be something like Python. A lot of people like this as a second language. You can use something like Django, Fast API or Flask to again make websites and backend APIs in Python. You also have other options like Go, C and Java. But I suggest if you're just starting out to pick either Python or JavaScript. That's going to be the fastest option for you. But if you have a particular stack in mind, then of course you have to pick the appropriate language for that stack. Now regardless of which language you learn, you need to learn topics like routing, controllers, middleware, error handling, and then understanding authentication topics. So things like JWT tokens and sessions. You're also going to have to know how to build restful APIs. So representational state transfer. This is a very common topic when it comes to backend. And optionally learning about things like GraphQL. Then you're also going to want to look at things like file uploading, background jobs, rate limiting, and more advanced API concepts. The overall idea here is that you need to pick a language. You pick a framework within that language. Then you learn all of these topics where you can have a backend connected to a front end. And ideally on your back end, you have some layer of authentication. Of course, there's a lot of other stuff to go over here, but start with front end, move on to backend, and then go to the next topic that we'll get into now. So this section is where I can be a bit more concrete. As a software engineer, there's a set of tools that you just need to know. So, I'm going to go over a bunch of them and these are specifically relevant for full stack developers. Now, first is Git and GitHub. You need to understand this no matter what type of development you do. This is talking about version control. So, how you save various versions of your code and work with other developers. You need to learn things like branches, merging, and pull requests. Then, the terminal or commands line interface. As a developer, you need to be comfortable navigating and running scripts from the command line and being able to use commands like cd, ls, pwd. If that doesn't mean anything to you, then you need to learn this topic. Again, command line and kind of uh terminal, right? That's what we'll call it. Next, package managers. Now, whether you're using JavaScript, you might be learning something like npm or if you're learning Python, you might be learning something like pip. But you need to understand how to manage dependencies of your projects. then Postman or Insomnia for API testing. Now, when it comes to writing APIs, you need a way to test these APIs, sometimes without having a front-end. And I highly suggest learning a tool like Postman, which will allow you to actually test the APIs and see the responses you're getting from them. Then you also want to look at things like extensions for your editors. So whether you're using VS Code, Jet Brains, etc. Understanding how to use these tools the best is going to help you significantly. and learning about things like debugging and various integrations with git or llinters and formatterers is going to be really helpful inside of your IDE. Of course, there's some other tools that you could learn, but pretty much all of these will apply to any area of development. So, you need to get good at them. And now we move on to databases. Now, again, as a full stack developer, you're touching pretty much every area of the code. And while you might not need to be an expert here, you definitely need to understand this. So, when we talk about databases, there's three main things that I want to go over. We have SQL or structured query language. We have no SQL no structured query language and OMS object relational mappings. Now SQL databases would be things like Postgress SQL or MySQL and you need to understand basic SQL syntax and what makes a SQL database. So tables, relationships, how you structure data in that format. Then I also recommend learning about NoSQL. This is typically a document store database. It works a little bit differently. And an example of a NoSQL database is something like MongoDB. So you should be comfortable working with both and understand the trade-offs between a SQL and a NoSQL database. So you're going to learn CRUD operations. So creating, reading, updating, and deleting. And then understand things like schemas, indexes, joins, and relationships. Now after that, I recommend looking into something called an OM. Now an OM allows you to write native code. So something in Python or JavaScript that translates automatically to the equivalent SQL code. This is what's used quite often rather than actually writing raw SQL queries. And you can learn something like Prisma if you're working with JavaScript or Node or something like SQL Alchemy if you're working with Python. You also have something called Mongus if you're working with MongoDB. And then lastly, there are a few small design principles you can learn like normalization, foreign keys, etc. Again, don't need to be an expert here, but you should understand databases because that's going to be a part of your stack. Now, after you've learned databases, we get into deployment. Now, this is usually a designated role at a company for a DevOps engineer, but again, as a full stack developer, you're often thrown into all areas of the code. So, it's important to understand some key components here. All right. So, when we talk about deployment, we're talking about continuous integration, continuous deployment, hosting, and then potentially containerization, which I'll talk about in a second. All right. All right, so you should know the basics of CI/CD again standing for continuous integration and continuous deployment where you're able to automate basic deployment workflows using things like GitHub actions. You should be comfortable using platforms like versel, render, railway or maybe digital ocean for hosting for example front-end user interfaces. Versel for example is very popular for really quickly hosting react applications or view applications etc. Now after that we can talk about things like containerization. Now containerization is a way of deploying applications. It's a little bit more advanced and this involves using things like Docker and Kubernetes. Now this isn't something that I think everyone needs to dive into right away but it's a good topic to learn if you have some time. Now other than that I also recommend understanding environment variable files, secrets and build pipelines and then having some basic monitoring under your belt. So understanding how to do things like logging and understanding errors and uptime of your application. Again, this is kind of a vague topic, but just generally, you should know how to deploy a basic application or be familiar with some of these concepts. So, I know that was a lot of stuff, so I'm going to kind of summarize it a little bit here into a learning path that I would suggest for you. So, you're going to start by picking a stack. Okay? This could be React plus Node plus Postgress SQL. This could be a Pythonbased stack. This could be a Cbased stack. Again, it really depends on what you want to do. And I can't tell you the stack in this video unless I was able to talk with you and get some more information. Now, once you've picked a stack, again, you got to pick one and stick with it. You're going to follow tutorials to learn this stack in the order that I said, front end, backend, database, deployment, etc. tools, right? And what you're going to do is start building variations based on those tutorials. Now, focus on completing projects, but not being absolutely perfect. The more projects you can build here and the more applications you can spin up in your desired stack, the better of a developer you're going to become. So, you should start by building a basic CRUD app. This is create, read, update, delete. Think of something like a to-do list application where you're creating entries, reading them, updating them, and deleting them. Next step, you would move on to something with authentication. So, you're actually authenticating the users, and identifying which user is which. then you can move on to a full application where you build something like a blog site or social media site or a clone of a popular tool. Now, I also recommend if possible contributing to open- source projects and getting real hands-on experience. In fact, if you're struggling with this and you really want some guidance, consider checking out my program Dev Launch from the link below where we actually help developers one-on-one and we tell them exactly what they should be doing. Anyways, that is a quick kind of synopsis and summary of the video. That's all I have for you here. That is a road map to become a full stack developer. Of course, we could get a lot more detailed. If you have questions, leave them in the comments down below. And I look forward to seeing you in another video. [Music]",unknown
M5oJY_VfNkE,"If you want to learn web development fundamentals, you need a lightweight solution, or you prefer having full control over your application structure, go with Flask. It's excellent for APIs, small to medium-sized web applications, and developers who like to understand how everything works. And then lastly, you can pick Django when you're building something substantial, userdriven websites, content management systems, e-commerce platforms, or any application that needs robust authentication, admin interfaces, and a ton of other features. This is the professional choice for serious web applications and what a lot of companies",unknown
LNCZ7JaoKns,"In 2025, just being a good developer isn't enough. You can be the best Python developer on the planet, but if you don't know how to position yourself, communicate your skills, and leverage the right tools, then you're going to get buried in all of the noise. Now, the market is saturated. Everybody knows Python and JavaScript. Everybody has a CRUD app. Everyone's portfolio has the same weather app and the same to-do list. So, if you want to stand out, you need more than just code. You need a strategy and an entirely different set of skills. Now, I know this firsthand because over the past eight months, I've mentored hundreds of developers one-on-one through Dev Launch. And here's the pattern that I keep seeing. They don't lack technical skills. They don't need to learn one more framework. What they actually lack is the knowhow to get hired. And that's exactly what I want to share with you in today's video. For most of you watching this, you don't need a bunch of new skills. You're not missing a ton of bullet points on your resume. you simply do not know how to get in front of the right people and actually land a job. So with that in mind, what do employers actually want? Well, simply put, they want someone who's a lowrisk hire, someone who can start today and start adding value from day one. They're not looking for the passionate developer. They're looking for someone that they can prove will be a safe, high value hire. Now, as someone who's hired plenty of people myself, I just hired someone yesterday. Trust me, making the wrong hire is extremely expensive. Now, employers know this, which is why they make you jump through endless hoops, assessment, interviews, and go through all of these processes just to potentially get a job. Now, the takeaway here is that you need to present yourself as the no-brainer candidate, the one that they don't need to gamble on, the one that they don't need to train heavily, that they know will deliver from day one. And that's what the rest of this video is going to focus on, how you can present yourself as that. So when someone reads your profile, they don't go, ""Oh, maybe I'll take a chance on this guy. Maybe he'll be great."" They'll go, ""I know 100% because of the evidence that's provided. If I hired this person, they will deliver value, and I'm not making a mistake."" That's the thing that companies are looking for, a risk-free hire. Now, I want to talk about how to actually stand out in this market. And one of the most important ways to do that, which we're going to continue to talk about, is to specialize. Now, in fact, let's take cyber security. Companies desperately need people who can think like attackers and break into their systems before criminals do. Now, that's where Try Hackme, the sponsor of this video, comes in. Now, it's the world's largest hands-on cyber security training platform that over 5 million people globally are already using to master ethical hacking. So, instead of just reading about security, you're literally hacking into virtual banks, breaking into servers, finding hidden files, all through your browser with zero setup required. Now, here's the thing. You're actually doing the work, not just memorizing theory. The labs are built like real attacks that hackers would use in the wild. This is literally me hacking into a fake bank account and transferring $2,000 into my account. Isn't that insane? And the best part is that there's no downloading sketchy software or spending hours configuring virtual machines on your computer. You literally just click a link and you're hacking already. And right now during their hack to win event through September 10th, every room you complete earns you raffle tickets for prizes like laptops and tech gear and much more. Hit the link below and use the code Tim 25 for 25% off their annual subscription and start building the skills that coding boot camps just won't teach you. So like I mentioned, I want to talk about exactly how to stand out. And I have five main ways to do that. Starting with to specialize. Now, as I discussed, it's extremely important to pick a niche. You need to be known as a front-end developer or a back-end developer or a machine learning engineer, an embedded C++ engineer. It doesn't matter what it is, but you need to pick something. You can't simply have a general resume that states that you're great at every single programming language, every single framework, that you could do any developer job. Now, even if that's true, people simply don't believe you and they would rather hire someone who's extremely tailored to the specific role. Now, let me give you a concrete example, right? I'm hiring staff for Dev Launch. I just wanted to hire someone who's going to be a technical recruiter and essentially help our students tailor their resume and their LinkedIn. Now, when I'm looking at different applications, I don't want to hire just a normal software engineer. Sure, that person could do the job. they might be a fantastic candidate, but I literally just threw out every single resume that started with software engineer because I want to hire a technical recruiter. I want someone who does exactly what I'm looking for, which is r√© reviews, LinkedIn reviews, and helping students pick their specialization and set up their branding. So, while you might be really good at this thing, if your resume and your profile isn't tailored to that specific role, I'm not even going to consider you. I'm not even going to read through the bullet points because I want someone specific. Now, the same thing obviously applies to developers. If I'm looking to hire a back-end engineer, I'm not going to hire someone who has full stack on their resume. Even though you might be the best back-end engineer that exists on this planet, if it doesn't clearly state that in the first few lines of your resume or your LinkedIn, I'm not even going to look at you. This is how companies hire. They want someone who is an exact fit. Again, a low-risk person to bring in that doesn't waste company resources. So, keep that in mind. You need to specialize. And if you're not going to do that, you at least need to tailor all of your resumes and applications to the exact type of role that you're applying to so you look like you are an exact fit. Nobody wants a generalist. They want someone who is very, very good at the specific role they're hiring for. Now, the next major way to stand out in this market is to build a personal brand. Now, I'm not saying this is easy, and I know that most of you are not going to do this bluntly, but that's why you're going to stand out if you do this, because developers hate to do anything related to sales or branding or marketing or posting online or being on social media. So, if you're one of the few developers that's willing to put yourself out there a little bit, then you're going to stand out massively and you're going to have a ton of opportunities. Now, think of all of the developers that you know, right? All of them have some kind of personal brand and post on social media a massive amount of times. Think about Instagram, think about Tik Tok, think about YouTube, whatever, right? All of the developers that you probably know that you don't know maybe in real life realize that having a personal brand is the number one asset that they can possibly have. So, they focus a massive amount of energy into building that personal brand where they can make obviously a lot of money from that, but they also can generate a ton of opportunities. I can tell you when I started this personal brand and I started posting on YouTube and making some tutorials. This was very small. It was a part-time thing. I was doing it while I was in high school and even then I was generating opportunities where people wanted to hire me for freelance work. They wanted to bring me in for a job interview. They wanted me to maybe sell something for them, right? Whatever it was, because there was evidence that I actually knew what I was doing and I stood out from all of the other developers. You have to imagine, right? If I'm looking through 100 LinkedIn profiles and trying to hire a developer, if I see one that has 5,000 followers, even 2,000 followers, that posts a little bit, that shares a project that they've done, that just shows me something else, they stand out, right? Because there's more evidence of what they're capable of doing. I hope this makes sense. But when I say personal brand, I don't mean become a social media influencer. I simply mean do something, post something, share something about yourself that gives me more information on you so that when I look you up, I can see more than just an empty LinkedIn profile and a boilerplate resume. Now, the next way to stand out here goes handinhand with the personal brand. And this is to provide an enormous amount of evidence of your skills. Now, if you're more of a junior developer, you're just coming out of school, for example, this could be through a really impressive project, right? something that you put on your resume that's deployed that someone could check out. Ideally, something that real users have actually touched, that's evidence that you actually know what you're doing and you know how to build software. Now, if we talk about the personal brand, if you're posting, you know, once a month talking about stuff that you're working on, insights that you have as a developer, new frameworks that you're checking out, a project that you worked on, that's evidence that you know what you're doing, right? That you're actually a developer. If you've been a developer for 20 plus years and you've worked seven different jobs, that's an enormous amount of evidence that you know what you're doing. If you graduated university and you have four internships and you worked at some top tech companies, for example, that's a great amount of evidence and a reason you might get called in for an interview. The point is that anytime you want to demonstrate you have some skill, you need to be able to back it up. It's not simply good enough to just list that you know something. People just simply will not believe you. Anytime I bring someone in for an interview, if they don't back up what they're saying with some kind of proof or evidence to demonstrate they actually know what they're doing because they've done it in the past, I simply dismiss anything that they say. For example, if I ask you, okay, what's your best programming language? And you just tell me, oh, Python. And you don't tell me why Python is your best programming language or where you've used it, a number of projects that you've worked on, I don't believe you. Whereas, if you ask me and I say, Python is my favorite programming language. I use it all the time. I've been writing in it for 10 plus years. I have over 1,000 YouTube videos where I've written Python code. I've deployed over 500 projects. I've worked on in a production environment. You get the idea. I believe you because there's so much evidence that I just have to. That's what you want to aim for. And again, it's not easy to build up this evidence, but you need to look at your profile and just look at yourself objectively and say, can I actually back up what I'm saying? Can I prove that I know these things that I have listed on my resume or in my LinkedIn profile? If not, then you need to start building that evidence. Now, the next major way to stand out as a developer is to be professional and to be prepared. Okay, now this is going to sound crazy and I know a lot of you probably aren't even going to believe me here, but I have interviewed a lot of people. I've looked at a lot of applications. I cannot tell you how many people don't spend even an extra 2 seconds to make sure that they have proper grammar if they're answering a screening question, for example. They respond with a professional email address, not gamertag 73, you know,gmail.com. to show up prepared when we get into an interview means they're dressed nicely, they're in a clean room, their mom's not screaming in the background, I don't hear pots and pans, you get what I'm saying here, the more that you can present yourself as a professional, the more serious I'm going to take you as someone who's potentially going to hire you, right? If you show up really well dressed, prepared, you have some really great questions that you want to ask me, you exactly understand the role, you've looked me up on social media, you know what I've done in the past, you know the type of company that you're going into, you can explain clearly your skills, answer common interviewing questions without, you know, bumbling around and mumbling and not knowing the answer, then immediately I just take you more seriously. even if your answer isn't great, even if you're not as good as some of the other developers, I'm going to just intrinsically believe more of what you're saying and want to work with you. So, just as a developer, because I know so many of us don't do this, and it's crazy to me how many people don't do this. Be professional, be prepared, do that little bit of work, put in some effort. I know that it's annoying when you're applying to a thousand plus jobs and nobody's getting back to you, but spend the extra 10 seconds to send a personalized message to make sure your sentences start with a capital letter, to use proper English. There's really no excuse today when we have AI tools, for example, that can literally do all of this for you. Now, the last and arguably most important way that you can stand out as a developer is understanding how to communicate. Now, this means that you can talk properly, you can maintain eye contact, you can ask good questions, you can speak fluent English. I know that's going to sound crazy, and I know a lot of us don't have English as a first language, but if you walk into an interview and English isn't strong for you immediately, people are going to think less of you just because of the way that you're talking. Look, I don't like that that's the reality. It shouldn't be the case, but it's just the way that human beings work. And I can tell you as someone who tries actively not to do this, it still happens, right? If someone forgets a word, if someone's speaking with really poor grammar, you just think less of them, you think they're not as qualified as someone else, especially in a professional setting. So, it's something you really, really need to work on. Now, that also goes with the uming and the aing and the pauses or the lack of confidence. No matter what you say, you need to speak confidently. Like, you actually believe yourself. There's so many times that I talk to different students and when they tell me something, they don't even believe what they're saying. How am I going to believe you if you don't believe the words coming out of your own mouth, right? Even if you're not 100% confident, even if you're embellishing a little bit, whatever you say, you just need to say it like it's the truth. Otherwise, people purely won't believe you. Now, look, there's so many other things. I can make a whole video on how to communicate properly as a developer. If you want that, let me know in the comments down below, and I most likely will. The point is that you need to speak calmly, clearly, and with confidence. If you can do that in an interview situation or just in life in general, that is going to make you stand out tremendously because most developers simply cannot. Now, this leads me to essentially a mindset shift that I realized kind of early on in this career that I want to share with you that I think will change the way that you look at things. Now, that is that life is all about sales. It's literally just sales. The people who land the best jobs, earn the most amount of money, build the best relationships, it doesn't matter. They share one thing. They know how to sell themselves and how to communicate with confidence. But developers, right, we love the excuses like I'm an introvert or I don't like social media or I just want to write code. I don't want to focus on those things. But the reality is that these are excuses and they don't get results, right? Actions get results. So that's why with most of my students, one of the first things that we work on is building confidence and learning to present themselves effectively. And here's the crazy thing. Because so few developers do this well, it really doesn't take much to stand out in this area. It's like a few weeks of practice. So if you're not actively working on this, essentially how you sell your skills, how you convince someone that you're actually the right person for the job, then you need to start that now because it's massively holding you back. So that's going to kind of conclude this video. And I want you to remember that in 2025, coding is just the baseline, right? The developers who are winning are the ones who combine their technical skills with branding, communication, and an overall strategy. Now, that's what gets you hired. Lastly, a big shout out to Try HackMe again for sponsoring this video. Make sure to check them out from the link below. And with that said, I'll see you in another video. [Music]",unknown
d64R3Zs7RIE,"fast API. Now, if you're just looking to build a backend, okay, so just handling the logic, the data authentication, for example, but you're not doing the front end, so all of the HTML, the CSS, the user interface, then definitely look into using fast API. It is the easiest and best way to make an API in Python. That's my opinion, but I use it literally all the time, and it can automatically document the APIs for you and handle things like data validation very, very easily. So when you use fast API, you're not usually spinning up a front end.",unknown
XZXZt9rxDPk,"have a streamllet form demo. I have some text inputs. So something like you know I can enter my name here. We can provide feedback. Hello world. We can do something like enter our date of birth. So we can go back here to for example let's just do like this 2014 whatever. So if you look inside of this code you can see that we have for example text input text area date input time input radio buttons. Notice that we just uh specify which radio buttons we want. We have select boxes, something like male, female, other. We have a slider, and we can specify the different options we want to have on that slider. Now, one thing to know about the forms, you can see we've provided this with the width statement here, is that this kind of avoids the issue of constantly rerunning your script anytime a widget changes. When you put something inside of the form, like you've seen here, Streamlit will actually collect all of these inputs before it reruns the application. What will happen is only once you press the submit button inside of the form will it collect all of this data and then rerun the app. So you're not going to have, you know, constant reruns every single time you're updating something within one of these forms.",unknown
C-0PuF06_jk,"charts that we can render. So for example, I can use something like a pandas data frame and I can generate some random values and associate those with columns A, B and C. And what I can do here is create something like an area chart. So what I've done is said okay ST.UB header area chart and then I'm rendering an area chart from this chart data. And you can see we get an area chart popping up here with our labels A, B, and C. Notice I didn't need to pass any options here. I didn't need to define the scale. It just rendered it probably exactly what I'd like. And you can see here that I can kind of zoom in and interact with the chart, make it bigger. Can click on this and save this as an image. This is just all built into this default component. Now, if we go down here, we can do something like a bar chart. So, that's what you can see. So, right here, we say ST.bart, and then we've got a bar chart popping up. This is kind of what it looks like. We have the ability to do a line chart, which is this one right here. We can do a scatter chart or a scatter plot. That's what I typically call it. You can see that we've rendered some random data points for X and Y here.",unknown
wI6ufTULIj0,"In this video, I'll show you how to build a full stack application with Nex.js, but more importantly, how you can build an MCP server for that application and then connect it to various AI tools. We all know MCP is huge. All kinds of companies are coming out with MCP servers and this is a relatively new thing. So, a lot of people don't understand how to build these servers, but more importantly, how to build them correctly with proper authentication. So, in this video, I'll show you how to set up a fully authenticated app. We're going to use clerk to do that, which is probably the easiest way. And then we're going to authorize our MCP server as well with the same credentials for our application. Anyways, let me go over to the computer here. I'm going to explain to you what it is that we're going to build and show you a quick demo and you'll get a better sense of what the purpose of this tutorial is and why you should follow along. So, I'm on the computer now and I'm going to dive into a quick demo. Now, first I just want to note this is not a beginner tutorial. You should have some experience with Typescript, React, and Nex.js JS. While I will be explaining a lot of what I'm doing, I'm not going to go over core concepts like what a component is or how the type system works, etc. Anyways, you can see that we have a very simple application here. I'm signed in with Clerk and because I'm signed in, I have a few bookmarks. Now, I just made this a very simple application because the point is to teach you about MCP, less so building out a really complex app. And anyways, if I want, I can add a bookmark. So, I could put a URL, I could put a title, some notes. And the point is that while you're working with AI tools, a lot of times there's some documentation that you may want to save a link to some site. And so we want to have kind of this bookmark manager where we could view it in our browser and we can use it like a normal web app, but then we can also connect it to our AI tools, which I'm going to show you in a second. Okay. So, you can see here that I have my three bookmarks. Again, I'm signed into this account. And now what I'll do is I'll go over to Cursor. Now, inside of Cursor, I have the project open. It's running. And what I'm going to do is just go to my MCP settings and show you that I'm connected to this MCP server. Now here we have two tools, get user bookmarks and create bookmark. And if I do something like what are my bookmarks for example, it should call that tool and we should see the same bookmarks. So let's wait one second here. Okay. And you can see that we have the three bookmarks which are the same as the ones that I had here. Now, just to do the same thing, I'm going to say, can you add a bookmark for the React docs, for example, and then what it should be able to do is actually create a new bookmark for us. So, it's going to call that MCP tool. Okay, so it said it added a new bookmark. And now, if I come here and I refresh, we'll see that we get a new bookmark popping up in our bookmark manager. Now, the interesting part is that this is fully authenticated, which means that if I go back to my MCP settings here. So, for example, if I maybe turn this off, let's go to edit and let's just delete this and let's maybe add a new one and just call this, you know, MCP server. Now, you're going to see that it's loading tools and it says it needs to log in. So, what will happen is I'll press this button. It's going to open up a website for me, which is going to prompt me to actually log into this service or to this application. So, I'll go through the login flow. Press allow. Okay. And then when I open cursor back up here, let's wait a second. We should see that we get the login. Okay. And it says it wants to open this URL. Okay. We'll press open. You'll see all of the logs are running here. And then all of a sudden, we connect to our tools and we get our user's data. So, I'll explain how this works in much more depth later on. But the point is we built an application, right? Our bookmark manager. It works as a normal web application. But then we created an MCP server so that we can share this data and kind of operations with an AI tool. So now you can just sign into this MCP server anywhere you use AI or any AI tool you have like claw desktop cursor whatever doesn't matter and we can start saving working with bookmarks and then we can add this MCP server in multiple places and most importantly it's authenticated to our account so we're gating access just to our data and then other users can sign in with their accounts and just get access to their data. It's the same thing as signing in with like a GitHub MCP server or something along those lines, but it's super smooth and we do that with a proper OOTH flow, which I'm going to explain in this video. Anyways, I hope that demo makes a little bit of sense. Again, it will make more sense as we keep going. Now, let me hop over to the code editor and let's get started. All right, so I just opened up Cursor here, which is the IDE that I'm going to be using for this video. Now, I would recommend that you use the same, but you just need to use something where you'll be able to actually test an MCP server. So, you need some type of MCP host. Now, I've just made a new folder here called Bookmark Manager. And before I start diving into all of the setup steps, I quickly want to explain to you the overall architecture and what it is that we're actually going to be doing in this video. So, first things first, I'm going to assume that you have some experience with MCP. If you don't know anything about MCP, then I'm going to put a video on screen which will be helpful context to understand before we go forward. Okay. Now on screen here I just have a few diagrams that I'm going to go through and I'm going to explain how MCP works with authentication because that's a part that most people miss. So first let's understand some of the core concepts. Now we have an MCP host. This is essentially an AI application. It's something like cursor or claw desktop. Now with inside of the MCP host there's multiple MCP clients. Now each one of these clients will have some kind of connection to an MCP server. The point is you have a host which is an entire application. In that host, there can be multiple MCP clients that are connecting to different types of applications and those clients really are just communicating with an MCP server. So in our case, we're just going to have a single MCP server, but this means that we can just plug this in to any type of AI application and start managing our bookmarks. Okay, so that's the basics on MCP. Now, I want to go to authorization, which is what we're going to be doing in this video. Now, fortunately, this isn't going to be as complex as it looks because we're going to be using Clerk to do this. By the way, massive shout out to Clerk for sponsoring this video and being a long-term partner of the channel, but they're free. You don't need to pay for them, and they just make it really easy to do off. I've been using them long before they sponsored the channel. Anyways, we have a client. Okay, the client is our MCP client, which runs inside of the MCP host. Now what's going to happen is this client once it connects to the MCP server is it's going to send a request and it's not going to have any authorization token. Now the MCP server is going to say hey you're not authenticated. I don't know who you are and it's going to send a request back that essentially tells the client hey you need to authenticate. You need to sign in in order to use this server. Then what's going to happen is the client is going to look in this response to see how to authenticate. It's then going to send a request to this endpoint which is expected to live on the MCP server. It's well-known/OTH protected resource. So, we're going to write that later. I'll show you how that works. Now, this is going to return a URL that indicates what server we need to go to in order to authenticate because we need to open up some kind of URL essentially like in our browser so the user can sign in and they can get the token. So essentially in these steps right here, what's going to happen is the client will open up this authorization server URL. Then the client or us in this case, the user will sign in. We will then get all of the metadata related to the authorization. Okay, we're then going to send a request to get a token. We're going to receive the access token back and then once we have the access token, we are authenticated. Essentially, the client will store that access token and continue to use that to communicate with the MCP server. So now after this whole flow, the client has a token. This is its like grants essentially, right? It's rights to use the MCP server and in every request it sends that token that then allows the MCP server to identify who we are and to allow us to perform the operations that we need to. That's the flow. I'm going to show you how to build it. Again, it looks complicated, but it's really not that difficult with the tools that we're going to use. And with that said, let's go back over here to the uh code editor and start working on our Nex.js application. Okay, so let's open up our terminal here and we're going to start writing a few commands just to initialize the application and there's a few packages that we need to install. So we're going to type npx. This means you need to have Node.js installed for this to work. And we're going to type create next- app at latest. Okay. And then we're going to put a dot because we want to do this in the current directory which is the bookmark manager. I'm going to go yes. Would we like to use ESLint? Yes. Would we like to use Tailwind? No. Do you want to use the source directory? Yes. Do you want to use app router? Yes. Do you want to use Turboac? Yes. Do you want to use the import alias? No. And then there we go. It went ahead and created this for us. Okay. So, it's going to take a second. It's installing the dependencies that we need. And then after this, we're going to install a bunch of other dependencies as well in order to uh be able to use these packages that I was discussing like Clerk and then the MCP server, all of that kind of stuff. Okay. So, while that happens, what I'm going to do is I'm going to go to the Clerk website. Now, if you haven't heard of Clerk before, this is just pretty much the best way to handle authentication and user management for your applications. It has a ton of different features, but it makes it extremely simple to build off into your app. And in our case, also to connect to an MCP server. Works for all types of applications, not just Nex.js apps. So, what I'm going to do is I'm going to go to Clerk. I'm going to make a new account if I don't already have one. In this case, I do. I'll leave a link to Clerk in the description, by the way. And I'm going to go to my dashboard. Okay. Now, from here, I'm going to make a new application. So, again, you're going to have to follow along with this. Let's make a new app. I'm going to call this my bookmark manager. Okay. And I think we can do a space. Yeah, that's fine. And then we can enable all of these different authentication providers. So, you can see that if you want to work with Google or GitHub or whatever, you literally just check this and then all of a sudden your app will work with all of these other providers. Now, sometimes there's a little bit of setup you need to do, but it's very, very straightforward. You can sign in with Slack. You can sign in with Bitbucket, HubSpot, Coinbase. So, you have all these different providers um at once. In my case, I'm just going to go with email. But, of course, you can enable as many of these as you want. Okay. So, I'm going to create the application here. So, let's continue. And then it's going to give me setup steps for all of the different types of applications that I could be using. And you can see there's a bunch of other ones here. In our case, we're using Nex.js. So, what we're going to do is just uh follow some of these setup steps here, get the basic setup done for Clerk, and then we'll set up the rest of our packages. Okay, so let's actually move this over to the right side of our screen. Okay, so I just set up my Windows here. We're going to go over to Nex.js. We're going to copy this install command. We're going to paste that in our terminal. I know you can't really see it, but it's just npm install atclerk/next.js. While that's happening, we're going to make a new env file. So, we're going to make a file called env in our root directory. We're going to copy this and paste it here. Obviously, you don't want to leak these values because these are your keys for clerk. So, go ahead and save that env file. We're going to create a middleware file. This is going to go in our src folder. So, we're going to go src. We're going to make a new file. We're going to call this middleware.ts. Okay. We're going to copy this file and just paste it inside of here. And make sure it's like this. So, it's outside of the app directory, but inside of the src directory. And then it's going to show us here how we can set up either our app router or how we can set up our pages router depending on what we're using here uh with the clerk components. Now, I'm going to write these manually actually because our pages are going to look a little bit different, but you can see that we have a clerk provider. We can use a simple component to see if we're signed out or if we're signed in. And then if we go here to the app router, we can see that we have components for like the signin button, the sign up button, right? Right. And then this will show the kind of sign-in pages or sign up pages depending on what you click on. You'll see it's very very straightforward. But that's literally all that we need to set up clerk. Now what we're going to do is go back into our code editor and we're going to start setting up the rest of the stuff we need for the various other packages. So we're going to type npm install and then this is going to be at clerk/mcp-tools. We're going to do atverell and then this is going to be slashmcp-adapter and then at prisma slashclient. We're going to use prisma for the database and then the other two are obviously for handling the mcp. Okay, so let's go ahead and press enter here and install this. Now, I also want to note that there obviously is a lot of code here. There's a lot of setup. If you're getting lost at all, I will have all of the code linked in the description so that you can simply copy different components. And for example, for all of the styles for this project, I'm just going to have you guys copy them in rather than manually writing all of the CSS because I really don't think there's too much value in that. Okay, so that's almost it. After that, we're going to type npm install-d and then prisma. Now, this is going to install Prisma as a developer dependency, which we need. And then we're going to start setting up all of our backend related logic. So, the API endpoints, the database, the types, some utility files. then we can start building the UI. Okay, so let's start by typing npx prisma and nit. If you've never used prisma before, it's a very simple database that we can use. It works really well with Nex.js. So that's what I'm setting up. And in this case, it's just going to be using SQLite behind the scenes. So we're going to type npx prisma init to initialize a new database in this project. It should create a new folder for us called Prisma. And then we can start setting up the different kind of database schemas, which you'll see in a second. All right. All right. So now you should see a new Prisma folder. It has schema.prisma inside of it. We're going to change this slightly and we're going to add the schema in just one second, but there's a few other steps that we need. So from inside of this file, what we're going to do is we're just going to write essentially the model that we want to have in our Prisma database. We're just going to have one thing that we're saving, which is simply a bookmark. So it's very straightforward. So we're going to write model bookmark. And then what we're going to do is specify all of the fields that we want to have in this model or in this database model. So I'm going to say ID. This is going to be of type string. And then we're going to say at ID and then at default. Okay. And then C UID, which just means it's going to automatically generate a new um ID for us. And that this acts as the primary key for this model. We're also going to have a URL which is of type string. We're going to have a title which is of type string. We're going to have notes. This is going to be string question mark because we may or may not have a note. And sorry, I don't need the colon here. Okay, what else are we going to have? We're going to have a created at date. This is going to be a date time field and this is going to be at default. And then what we're going to do is use the now function. So if we don't pass anything, by default it's just now. We're going to say updated at and this is going to be datetime. Same thing. We're going to say at and this is going to be updated at which just means automatically updated whenever it was updated like put the time there. And then we're going to say user ID string and this is going to be for the clerk reference. So essentially we have an ID for the bookmark. And then we need to store which clerk user actually owns this bookmark so that we know. So that's literally all that we need for this file. We're just specifying a really simple model that we want to have inside of our database. Again using Prisma to do that. Okay. So now we're going to close that and inside of our environment variable file, we're going to make another variable. Now here it's giving us this database URL, but I don't actually want to use this. I want to make it a little bit simpler than that. So I'm going to change this to say file and then I'm going to say colon dot and then slashdev. DB. So this is just for development, but I'm just making it so that we're just going to reference a local file rather than running kind of the Prisma server, which is what it's telling us to do right here. Okay. So now that we've done that, what we're going to do is we're going to generate the uh change to our Prisma database. So we're going to say the following npx Prisma and then generate. What this is going to do is read the schema and then apply that to our database. So let's go ahead and run that. And we can see here that it says it generated the Prisma client and we are good. Okay, next thing we're going to type npx prisma and then migrate and then dev-name and then init. What this is going to do is initialize the database for us. So let's run that command. And we got a quick error because I forgot to change something inside of our schema file. So inside of our schema file here, rather than having Postgress SQL, we're going to change this to be SQL light because we're going to reference a local database file. Uh and I think that should be okay now. So let's change this and run this again. And there we go. Now we're good and it's actually using the file. You can see we have this dev.db file showing up here rather than trying to connect to a remote Postgress SQL database. Okay. So that's pretty much it. By the way, if you wanted to see your database, you could type npx prisma and then studio. If you do that, it should load this in your browser and then you're able to navigate and kind of see all of the data inside of the database. Anyways, that's literally it. We've just set up the database again. We specified the model. We changed this to SQLite. And then we ran a few commands just to initialize everything. Okay, let's close all of that right now. Let's go back into SRC and let's start working on our back end. All right, so from our src folder here, we're going to make a few new folders. We're going to make one called components. That's going to be for our React or Nex.js components. We're going to have one for hooks again for the hooks that we need. We're going to have one for lib. and we're going to have one for types. Okay, now we're going to start inside of types. And inside of types, we're just going to make a new file called bookmark.ts. Now, again, I'm just writing all of the backend logic. So, essentially the database operations here. You'll see how they work when I write kind of some helper functions and the types. And then we connect it up eventually to the backend API, which we'll have in a second. So, for now, we're going to say export interface bookmark. And we're just making a kind of friendly type that we can use in our user interface. So we're going to say ID string. We're going to say URL string. We're going to say title string. We're going to say notes. Okay, let's spell notes correctly. This is a string as well. And then we are going to have created at. This is going to be a date. And we're going to have updated at. And this is going to be a date as well. We're then going to have another interface. So, we're going to say expert interface and this is going to be create bookmark and then data like that. This is going to be what we need to accept to make a new bookmark. To do that, we're going to take a URL, a title. Okay, let's call the title correctly, and some notes, which is a string. Okay, cool. So, now we have the two types that we need. Pretty easy. Now, we're going to go into lib and we're going to make a new file and we're going to call this bookmark and this is going to be -utils.ts because we're going to use the functions that we put in here multiple times. So, first I'm going to say import. Let's spell import correctly and we're going to import the Prisma client from at Prisma/Client so we can connect to our database. We're also going to import the create bookmark data from at types slashbookmark. Okay. Now we're going to say const prisma equals new prisma client. Okay. This should automatically connect to our database for us. And then we're going to start writing the functions that we need to interact with our data. Okay. So we're going to start by saying export async function. We're going to say get user bookmarks. And what this is going to do is it's going to look up in our database all of the bookmarks associated with a particular user based on their user ID which is going to come from clerk which we'll set up later. Okay. So we're going to say get user bookmarks and then what this is going to do is it's going to return a promise. Okay. And there's going to be a specific type here but for now I'm just going to put any. And then later we will actually put the correct type here. I just need to get it which is going to take a second. Okay. Now we're going to do a try accept block. We're going to say try const bookmarks is equal to await. Prisma.bookmark.find many. You can see it's actually giving me pretty much the full autocomplete. Uh so let's just tab into that. We're going to say where the user ID. So user ID like that. And then I'm going to add one more field. I'm going to say order by and we're going to order by created at and then descending. So we get the most recent ones first. Then we're going to return bookmarks. Otherwise, we're going to log the error and then we're actually going to throw it again so that we can pick it up uh what is it? Wherever this is called. So, I'm going to say throw new error failed to fetch bookmarks. Okay, so that is the entire first function. Again, we'll fix the typing later on. Okay, next function. We're going to say export async function and then we need to create a user bookmark. So, I'm just writing again all of the database operations here. So, we're going to say user ID is string and we're going to say the data is the create bookmark data. Again, promise any. We'll fix that later on. Okay, let's go inside of our function here. We're going to have another try block. inside of the try block. The first thing we're going to do is we're going to say if we do not have a URL or we do not have a title, then what we need to do is throw a new error and say URL and title are required. Okay, then we're going to say const bookmark is equal to await prisma.bookmark.create. [Applause] Same thing inside of here. We're now going to specify all of the data for our bookmark. So we're going to say data going to say URL is data URL. We're going to say title is data.title. We're going to say notes is the data.notes or an empty string in case there's no notes there. And then we're going to specify the user ID. Okay. And the user ID is the same as this. Perfect. Then down here we're going to say return bookmark like that. And we're going to write the catch statement. So we're going to say catch error. We're going to console.log the error. So we're going to say error creating bookmark. And then same thing we will throw that new error say failed to create bookmark. All right. Now we are almost done. We're going to write one more function which is going to let us to let us delete a bookmark. Sorry. So I'm going to say export async function delete user bookmark. In order to delete a user bookmark, we need the user ID. And we're also going to need the bookmark ID. So let's go bookmark ID. This is going to be a string as well. Okay, this time the return is actually going to be a promise of boolean essentially indicating whether or not this operation was successful. So again, we're going to go in here. We're going to say try and we're going to start by saying const bookmark is equal to await and then this is going to be Prisma.bookmark.find. And this is going to be first. Now we're going to find the first instance where the ID is bookmark ID. Okay. And the user ID is the user ID and we got to spell the bookmark ID correctly. So let's fix that here. Okay. We're then going to say if not bookmark. So for some reason we didn't find this. Then we're going to throw new error and say bookmark not found or access denied. And then what we're going to do down here is we're going to say await. And this is going to be Prisma dotbookmark.delete. We got to spell bookmark correctly. And where we're going to delete is the following. We are going to say inside of here where and then ID is the bookmark ID. Okay. Then we can return true indicating this was successful. Then we're going to have a catch. We're going to catch the error. Same thing. We're going to say error deleting bookmark and then throw new error failed to delete bookmark. Okay. So that is our delete user bookmark, our create user bookmark and our get user bookmarks. And now we can fix the typing. So actually to fix the typing I need to make a change. So sorry rather than importing the Prisma client from Prismaclac clients, we're actually going to import it from the following which is dot dot /generated/prisma which is the code that's generated automatically for us here in this file. And then we can also just import the bookmark type directly from there rather than having to define it. So now I'm going to say bookmark and I'm going to make this a list because that's what's going to be returned from get user bookmarks. And from here, create user bookmark. We can just return the bookmark as well. Like that. Okay. Now, you might be wondering, why do we still have this type here? It's because we need to have another type that doesn't include the user ID when we're actually showing this on the front end or when we're creating a new bookmark. Whereas here, uh, inside of the database operations, it looks a little bit different, right? It's kind of bookmark with user ID. Anyways, there might be a way to optimize this, but for now, it's fine. and we're just importing that type directly from here uh from Prisma. Okay, cool. So now we have the backend functions written. We have our type and what do we need to do next? Well, we need to actually write the backend API route. So inside of the app folder, we're going to make a new folder called API. Now, if you're not familiar with Nex.js, essentially you could have a full front end and backend in one codebase. In our case, we're going to have an API endpoint here that allows you to either uh delete a book or create a book or get the books for a particular user. So those functions we wrote, we'll use from this uh endpoint. So inside of API, I'm going to make a new folder called bookmarks. Okay. Now, the way that this works is that essentially if you go to our website URL/ API/bookmarks, you'll then be uh routed into whatever file is here, which is going to be route.t ts I'll explain it in a little bit more depth in a second but essentially by doing this now any request that's sent to slap ai/bookmarks will be forwarded kind of to this file where we can write the different uh endpoints like get postput etc. Now I'm also going to make another new folder. This is going to be in square brackets ID. Now what that means is that essentially we're going to handle a dynamic route. So a dynamic route being some bookmark slash some ID. And again when we go into this folder we're going to go inside of this route.ts file. Okay. So let's start from the first file that we created that's kind of in the bookmarks directory directly. And inside of here we're going to do the following. We're going to say import next request. We're going to import the next response. Okay. And then this is going to be from next slash server. We then are going to say import and we're going to import o from at okay at clerk slashnext.js/server js/server and then we're going to say import and we're going to import the get user bookmarks as well as the create user bookmarks from this lib/bookmark utils. Okay, so the file that we just wrote. Now we're just going to have two endpoints here. One for getting one for posting. So if you send a get request to / API/bookmarks, we're going to go into this endpoint right here which is going to allow us to uh what is it? retrieve all of the bookmarks for a user. So I'm going to say export async function get. We're going to create the function body and we're going to do a try catch block. So we're going to say try conster ID is equal to off. This is automatically going to pick up the authenticated user from clerk. Uh we also need to await this just to make sure that we get this correctly. What is going on with my autocomplete? Okay, there we go. So again, this is like how easy it is to use clerk. We literally just call this function and it's going to give us the authenticated user if it exists. We're going to say if not user ID. So if someone is not authenticated then we're going to say return next response and then JSON and we're going to say error unauthorized and the status is going to be 401. Then we're going to say con bookmarks is equal to await get user bookmarks with the user ID. And then we're going to return the next response. Same thing.json JSON, we're just going to return bookmarks with status code 200. Okay. Now, we need a catch. So, we're going to say catch error. And what we're going to do is we're going to say console. Error fetching bookmark. We'll just print out whatever that error is. And then we're going to return a next response.json. Here's the error. Now, for the error, rather than internal server error, we're going to say failed to fetch bookmarks. And the status code can be 500. Okay. So that is the get request. Again, whenever we hit /appi/bookmarks and we send a get request, it will automatically be routed to this function, which is how Nex.js handles it. Next, I'm going to say export async function post. And then for post, I'm going to say request is equal to next request because I need to get the data that is sent along with this post request. Similar to before, I'm going to kind of copy this actually and paste it inside and I'm going to start modifying a few things. So, I'll remove the, you know, getting bookmarks and returning because we don't need that. However, we are going to authorize the user. So, we're going to get the user ID and if that doesn't exist, then we're going to say, okay, it's unauthorized. But now, the way we're going to change this is we're going to say const body is equal to await request.json. Then we're going to say const and we're going to strip out the properties. So we're going to say URL title notes is equal to body. Then we're going to say if not URL or not title then we are going to return a next response.json. Okay. And we're going to have an error. for the error, we're going to say URL and titer title are required and the status is going to be 400. Okay. Now, otherwise, uh, oops, I guess that's actually exactly what we wanted to do. I didn't even mean to hit tab there, but we're going to say con bookmark is equal to await create user bookmark, the function that we wrote before. We're going to pass our user ID as well as our bookmark data. So, URL, title, and notes. And then we're going to return the next response where we're going to return the bookmark and say that this was status 2011 indicating that it was successful. Now for the error here, we're just going to say error creating bookmark. Okay. And make it not plural. And then we're going to say failed to create bookmark like that. Same thing with status code 500. Okay. So that's it for this API. Now we've written this endpoint. So we can actually send a request uh to here or to here again a post request or a get request. Now let's go into this one here and wrap up our backend by simply writing a delete request for an individual uh bookmark. So we're going to say import and actually we can just copy it from here. So let's copy that and rather than having the create user bookmarks and get user bookmarks, we'll bring in the delete user bookmark. Okay, we're then going to say export async function delete. Okay, we're going to say request is the next request. Okay, and then we're going to take in the params. So the params are going to be relative to this the ID here. So the uh what do you call it kind of path parameter for this. And then this is going to say params and then id string. So that's going to be our type here for the delete method. We're going to create the function body. We're going to say try. Same thing. We're going to make sure the user is authenticated. So we're going to say con user ID is equal to await o. Okay. We're going to say if not user ID, then we need to return the next response.json saying they're unauthorized with status code 401. Otherwise, we're going to get the ID. So we're going to say const ID is equal to params. Then we're going to say await delete user bookmark. And we're going to pass in the user ID as well as the ID of the bookmark. And then again the autocomplete is really good. So let's just hit tab. We can say return next response.json bookmark deleted successfully. Status 200. Otherwise we have an error message. Error deleting bookmark. This is the error. And then return next response.json. This is the error again. status 500. Okay, so that is pretty much it. That's going to handle the backend API endpoints, at least the ones for the standard application. We will need to write some more when we handle the MCP server. But for now, we have kind of the functionality so that we could actually call this from the front end and we can delete, we can create, etc. Now, just as a sanity check to make sure that everything is working, I am just going to make a new terminal here and I'm going to type npm rundev. This is just going to run the server for us. So let's run this here and give it a second. And we should see that everything is compiled and ready to go. And then if we wanted to, we could just come here. We could do something like localhost port 3000. And we should see our application loading in a second. So it's compiling. Takes a second. And then you see we have the next.js app. Now, if we go to something like / API slashbookmarks, for example, you can see that it just tells us we're unauthorized because we called that API endpoint and we don't have anything to pass to it. And if I go bookmark one or something, same thing, you know, uh well, in this case, it gave us an error actually saying 405. And actually, it makes sense that we're not getting anything here because we don't have a get endpoint written. We just have a delete endpoint. So 405 I believe is actually just saying that this isn't found or there's some error or something because well we didn't hit an endpoint that is valid. Anyways point is this is working. So we can shut this down for now with control C. And now we can move on and we can start coding out parts of the front end and actually calling some of this back end. Now again we'll get to the MCP server component but it makes sense to build out the whole app first because typically you wouldn't have an MCP server unless you have an app. All right. So, first things first, I'm going to go to my source folder. And for global.css as well as page.module.css, I'm going to bring in a bunch of CSS that I'll have linked in the description in the GitHub repository that you see there. So, essentially, I just don't want to write all of this CSS because it's going to take a really long time. So, I'm just going to copy all of it in right now. So, from page.module.css, I'm going to paste in this. Pretty straightforward. It's actually less than was there before. Uh, and all of this again you can find from the link in the description. You can just navigate in the GitHub directory, find the CSS file, and just copy it. Now, same thing for globals. I'm going to copy in all of this. You can see there's a bunch of styling, and then we'll use these classes as we create the various components uh inside of our files. Okay, now we need to start uh navigating or modifying the layout file as well as the page.tsx file. So for the layout file, it's actually going to be easier here, I think, if we delete most of this. So let's delete all of this. Let's leave the import for global. Let's get rid of these imports up here, and let's import what we need from clerk. So we're going to import the clerk provider. We're going to import the signin button, the sign up button, sign up button. We're going to import the signed in, the signed out, and the user button. This is going to be from and then this is at clerk/n nexjs. Okay, so that's all we need for the imports. Then what we're going to do is render the HTML, render the body. Okay, that's fine. We're going to remove the class name here because we don't need that. And we're going to start creating a few different components. All right. So, let's remove this. Okay. So, we're going to start with a header. In the header, we're going to say this is class name equal to header. Then, what we're going to do is create a div. Okay. Inside of the div, we're going to have an H1 tag. We're going to have the style, which is equal to, and there's a little bit of inline styling for this. So, we're going to say font size 24px. We're going to say font weight bold. And then I'm going to call this the bookmark manager. Okay, that's it for that div. Then we're going to have another div. This div is going to have style. Again, just a little bit of inline styles here. We're going to have display flex. We're going to have gap 15 px. We're going to have align content. And then this is going to be center. And then inside of this div, we are going to have the sign in and signed out button. So we're going to say if you are signed out, then what we want to display is the signin button. Okay. And for the signin button, we want to have a button. Okay. We're going to say class name is equal to btn btn- primary. And we're going to call this sign in. Now we're also going to have the same thing. And this is just going to be the sign up button. So, we're going to say sign up, sign up, and sign up. So, if you are signed out, we're going to show you to sign in or sign up. Then, inside of the same div, we're going to have if you are signed in, we are going to show you a button. We're going to say user button like that. Okay. So, the way that this works is if you are signed out, we're going to show you these. If you're signed in, we're going to show you the user button. The user button is like the user's profile. So, they can log out or they can modify the profile. Uh we can adjust what that looks like inside of clerk. Now, we're going to go main class name, and this is going to be main. And then inside of main, we're just going to render all of the children for this layout component. Okay. And then we need to actually wrap this whole thing, sorry, in the clerk provider, which I forgot. So, we're going to say clerk provider. Okay. Like that. And let's remove this. And then take this ending tag and paste it here and fix the spelling. So now the whole HTML tag is inside of the clerk provider. And then I'm just going to do a format here so that everything is a little bit nicer to read. And you can see we have everything we need for layout.tsx. Okay. Now let's go over to page.tsx and start modifying this because this is where we're actually going to write some logic and have a few different components. And actually before I do that, I think we're going to write one of the hooks that we need for our bookmarks because that's going to make more sense because we're going to need to use it in the component. So let's go to the hooks directory. Let's make a new file and let's call this use bookmark or bookmarks.ts. Okay, so this is going to be some reusable logic. Now for this hook, we're going to say use client because it is a client side hook. We're going to say import use effect and use state from React. Okay. And then we're going to say import bookmark. Okay. And this is going to be create bookmark data from ad types slashbookmark. We're going to say export function use bookmarks. And then inside of here, we're going to write some reusable functions that essentially get all of the bookmarks for a user, store that in state, and then allow us to add and delete the bookmark. So we're going to say const bookmarks set bookmarks is equal to use state and then this is going to be bookmark like that. And we'll start with an empty list by default. We're then going to say const loading set loading equals use state. By default, that's going to be true because it's going to be loading as soon as the app renders. Then we're going to say const error and then set error is equal to use state and this is going to be string or null and then by default for now this is going to be null. Okay. And I need to make sure this type is correct. like that and that null goes inside of here. Okay. Now, what we're going to do is we are going to start writing all of the different functions that we need. So, we're going to say const fetch bookmarks is equal to an async function like that. Then we're going to write a use effect hook. So, oops, I don't want this twice. I want use effect. and then use effect. What we're going to do is we're gonna have an empty dependency array and we're just going to say fetch bookmarks. Okay, so what's going to happen is as soon as this hook loads, we're just going to fetch the bookmarks and then we're going to call this function which will get the bookmarks for us. Now to get the bookmarks, we're going to have a try. We're going to say set error and then null. So when we start doing this, we'll say okay, let's clear any error. We're going to say const response is equal to await fetch and we're going to fetch / API slashbookmarks which should give us all of the bookmarks for this user. We're going to say if not response. So for some reason there is some error then we're going to say throw new error and we're going to say failed to fetch bookmarks like that. Okay. Then we're going to say con data is equal to await the response.json JSON from our API call and we're going to say set bookmarks and we're going to set the bookmarks equal to whatever data was returned. Otherwise, we're going to have a catch. So, we're going to catch uh err and we're going to say set error and then what we're going to do is say the following error fetching bookmarks. And then we're going to put the error like that. And then we're going to say err message there for setting the error. However, I need to do the following so we don't get this type issue. I'm going to say error is instance of error question mark. Then we can show the error message. Otherwise, we can show an error occurred because for some uh case or sometimes this may not actually be type error. It might be a different exception that we're catching. And then we can have a finally we can say set loading equal to false. Okay, so this is how we fetch the bookmarks. Now we need two other functions. One for adding the bookmarks and one for deleting the bookmarks. So we're going to say const and this is going to say add bookmark. Okay, this is going to be an async function. We're going to take in data which is the create bookmark data. Okay, then what we're going to do inside of here is similar to what we had before. We're going to have a try. Okay, we're going to have an accept or actually not an except that's Python. We're going to have a catch of the error like that. Now in the try, we're going to say set error equal to null. We're going to say const response is equal to await fetch and then slash API slash bookmarks. And then we're going to put the type of the request. So we're going to say method is post. We're then going to say headers and this is going to be content dash type application JSON and then we're going to pass the body which is JSON.stringify and then data. We're going to say if not the response okay we're going to throw a new error saying failed to create bookmark otherwise we're going to make the bookmark. So we're going to say new bookmark is equal to await response.json JSON and we're going to say set bookmarks and then previous and then we're going to append the new bookmark into this list. But we're actually going to do it first so that it shows up in the most recent order. Okay, so that's setting the bookmarks and then we can return the new bookmark like that. All right. Now, if there is an error, what we're going to say is const error message is equal to error instance of error show error message. Otherwise, we show an error occurred. And then we can say set error. So, let's do this here. And that should be good for that function. Okay. So, that is adding the bookmark. That function is good. Now, we're going to do deleting the bookmark. So, we're going to say condemark is equal to async. We're going to take in the ID of the bookmark. Okay, what we're going to do here is we're going to say try same thing set error to null. We're going to say const response is equal to await fetch. We're going to fetch / API/bookmarks slash and we're actually going to make these back ticks so that we can embed inside of here the ID because it's a path parameter. So, we're going to embed the ID and then we're simply going to say that the method is equal to delete because that's what we need to do in order to delete this. Same thing, we're going to say if not response okay, then what we want to do is throw a new error saying failed to delete the bookmark. Then we can say set bookmarks and it already knows what we want. We're going to do a quick filter. We're going to c the previous. We're going to say previous filter and then we're just going to make sure that we only get the bookmark that wasn't the one that we deleted or only get the bookmarks, sorry, that weren't the one that we just deleted. Then we're going to say catch on error and same thing as this. We're just going to copy this, paste this here, and that's how we delete a bookmark. Okay, so that's it. Now, we just need to return all this from the hook. So, we're just going to return the bookmarks. We're going to say loading error. We're going to say add bookmark, delete bookmark, and then we're going to say refetch. And this is going to be the fetch bookmarks in case we need to refetch it. Okay, so that's it for the hook. Now we kind of have all of the operations connected to the back end, and we just need to call this hook or use this hook from our front-end components. So page now is what we need to modify. So we're going to get rid of uh use bookmark here. Close that out. Close layout. And now we're going to go into page, which is where we're going to have kind of the homepage. And then render all of our different components. All right. So, let's remove this image because we don't need that from here. And let's essentially just clear everything out from page because we don't need anything. And then we'll write this from scratch. Okay. So, we're going to import the styles, but before that, we're going to make this a use client because we're going to have some forms on this page. We're then going to say import like this. And we're going to import use state from React. We are then going to import the signed in and the signed out component from and then this is going to be at clerk/next.js. We're then going to import the let's spell this correctly. Use bookmarks from at hooks/usebookmarks. We're going to import the types. So we actually just care about the create bookmark data type from our types. Uh and for now that's it. And then get rid of this. We don't need that. Okay. So now we have our home component. Inside of our home component we're going to use the hook. So we're going to say const. And then this is going to be bookmarks. Loading error add bookmark. As you can see delete bookmark and refetch. Okay. So let's take this here. Refetch. Let's spell delete bookmark correctly. That's going to be equal to the use bookmarks hook. And let's just quickly format that. I need to just put something in here. Okay. So that we can format it. And you can see now we're getting that from our hook. Okay. Now we're going to have a few pieces of state. So we're going to say const and we're going to say show add form. Okay. And then set show add form because we're going to have a form that allows us to add a new bookmark. By default, that's going to be false. We're then going to have const is submitting set is submitting is equal to states and then again that's going to be false and we're going to spell submitting correctly and false correctly as well. Okay, now we just need to write a few functions that can handle things like adding the bookmark uh deleting the bookmark loading etc. as well as the rest of the UI page. So let's start with the functions then we can write kind of what's returned from the component. So let's start with const. This is going to be handle add bookmark. Again, the AI is so good. It knows exactly what I want. We're going to say async data create bookmark data. Inside of here, we're going to write the function body. We're going to say try and this is going to be set is submitting to true. We're going to say await add bookmark. We're going to pass our data. We're going to say set show add form false. So after we submit it, we don't want to show the form anymore. We're going to catch any errors. Okay. And then we can just say console.log and then you know failed to add bookmark and we can show whatever the error is. And then we can say finally set is submitting to false. Okay. So that's how we add a bookmark. Now we're going to do the deleting of a bookmark. So, we're going to say const handle delete bookmark equals async id string. Okay. Then we're going to say if and we're just going to put a quick confirm box. We're going to say are you sure you want to delete this bookmark? Okay. If they are sure that they do want to delete this then what we can do is we can say try and then we can say await delete bookmark and we can pass our ID and then we can catch the error and same thing we can just console.log failed to delete the bookmark. All right, so that's it for now for uh adding the bookmark and deleting the bookmark. Let's add a quick loading state as well. So we're going to say if loading. So if we're waiting to fetch our bookmarks, then what we can do is return a quick loading state. So we can return a div. We can say the class name is equal to and this is going to be styles and then loading dash container. Then we can have another div with class name equal to and this is going to be styles loading dash content. Then we're going to have another div. This div is going to have class name equal to styles and this is loading dash spinner. So that's going to be the spinning icon for us. And then we're going to have a quick paragraph tag. And we're just going to say loading bookmarks dot dot dot. Okay. So that's our loading state. And now we need to do kind of the main state of the page. All right. So first thing, let's change the fragment here to be a div. Inside of the div, we're going to have signed in and signed out. So if you're signed in, we're going to show you a form. If you are signed out, then we're just going to tell you that you need to sign in. And then we're going to have signed out here. Like that. Okay, so if you're signed in, we'll show you all of your bookmarks and the ability to add a bookmark. If not, then of course you need to sign in in order to do that. So let's handle the signed out uh part first. So we're going to have a div class name is equal to and same thing. This is going to be styles and this is the sign out dash container. Okay, then another div. Same thing, class name equal to and this is going to be styles and then sign out dash content. And then we're going to have a paragraph tag inside of this one. Paragraph tag is going to say class name equal to again styles. And this is going to be the sign out dash text. And we're going to say please sign in to manage your bookmarks. Okay. And then that's pretty much all that we need there for sign out. Okay. Now we can go to sign in. For signin, we want to display a form and a few components that we haven't written yet, but at least this will be a good start. So we're going to say div class name. The class name here is going to be container. Then we're going to have another div. This is going to be class name equal to and we're going to say styles. And then this is going to be the page- header. Then we're going to have another div. This is going to be class name equal to styles and then header dashc content. Then we're going to have another div class name equal to styles. And then this is going to be the header dash text. Okay. And then we're going to put h1. And we're going to say bookmark manager just so we have kind of like a nice pretty title at the top of the page. We're going to put a paragraph tag. Okay. So, let's add this. And we're going to say, you know, organize and manage your bookmarks. That's fine. Okay. And then let's fix the indentation. That's not what I wanted to do there. And we're going to add another div just below this. The div is going to say class name equal to and this is going to be styles and then header dash button. And then what we're going to do is put a button for the button. We're going to have class name equal to btn btn- primary. And then we're going to have on click equal to a function. And this function is going to call set show add to true. And then this is going to say add bookmark like that. And actually we're going to do this dynamically. So sorry, let me fix this. We're going to say show add form question mark cancel otherwise add bookmark. And we're going to change this to say not set show add form uh or not show add form. Okay. Okay. So, essentially what we're doing is we're having a toggle button here where we're saying, ""All right, if you want to uh sorry, if the form is currently being shown, then you can press the cancel button and get out of it. If it's not, then you can press this button and we'll show the form uh by, you know, adding a new bookmark or by pressing this button."" That's what this is doing right here. I'm just creating a simple header component. So, we have like, you know, a nice title and then a button to add a new bookmark. Okay, we are almost done here. Two more things I need to add. So, first I'm going to add an error component. So I'm going to say error and and and then what I'm going to do here is have a div. So if there's an error, then we'll show the error. We're going to say class name is equal to styles error- message. Okay. Then inside of here, we're going to have a paragraph tag. We're going to say error, and we're just going to display what the error is. Then we're going to have a button, and this button will just let you reset the error. So we're going to say on click is equal to refetch. So, this is going to be retry. And we're going to say class name is equal to btn btn d- primary or actually dash secondary. And then inside of this button, we're just going to say retry. Okay. And let's just format all of this so we can read it. So, we have the error state kind of handled. And then what we need to do is we need to be able to show a form for the uh like kind of ability to add a bookmark and to display a bookmark. Now, those are some other components that we'll need to write in a second. Uh but for now we can just stub it. So we can say show add form and and and we can show a div. This div can have a class name equal to styles and then form dash section. Okay. And then later here we'll populate this div with the correct component to show kind of the add form. All right. So we have this page component. This will let us uh essentially view the bookmarks, handle the form, etc. Now, in order for this to work, we're going to have to write a little bit more code because we have to display the form, which we haven't written yet, and we have to display the bookmarks. So, we're going to write a quick component that will let us do that. But for now, let's run this and see if it works because we've written a lot of code. So, going to type npm rundev. It's going to take a second here. Hopefully, it's going to work. We can go to our front end. So, let's just go to localhostport 3000. And you can see that we have a sign-in button and a sign up button. It says, ""Please sign in to manage your bookmarks."" If I press sign in, it should bring me to the clerk page. So, you can see it's here. And then I can sign in uh with my account. Or if I don't have one, I can sign up. So, I'm going to sign up with a new account. And I'll be right back. And you can see now I've signed in. I have this clerk button that I can press on where I can manage my account or I can sign out. Let's make sure we blur my email, please, editors. And then we have bookmark manager, organize and manage your bookmarks, and then the ability to add a bookmark. And you can see it kind of toggles between add and cancel. Okay. So for me right now that is pretty good. If we sign out. So let's do that quickly. You'll see that it brings us back to this page and then we can sign in again. Let's do that again. Please blur my email editors. Let's sign in. And you see that it loads and it brings us back here. Okay. So now we just need the ability to actually add the bookmarks and view them. So let's start with the add bookmark form. In order to do that, uh, let's go to our components folder and let's make some new files for these components. So, we'll start with the bookmark form.ts. Inside of here, we're going to write the form. So, this is going to be use client because it's going to use React state. We're going to say import use state from React. We're going to say import create bookmark data from our types. We're going to make an interface for the props. So we're going to say interface bookmark form props. Okay, this is going to be equal to the following. It's going to say onsubmit and then we're going to take in data which is the create bookmark form and this is going to return void. We're going to say the initial data question mark and this is going to be a partial of create bookmark data. We're going to say is editing. Okay. And this is going to be again a question mark and then boolean. And then we're going to have is submitting and this will be a boolean as well. Okay. Now we have the props. So we're going to say export default function in lowercase. This is going to be the bookmark form. We're going to take in the onsubmit the initial data is editing equal to false. And then this is going to be is submitting equal to false as well. We're going to take from the props. Okay. So that is formatted. Now we're going to go const. We're going to say set form data is equal to use state. And this is going to be the create bookmark form data. Then we are going to have the following. We're going to say URL colon and then this is going to be the initial data URL or an empty string. We're going to have the title, same thing. And then the notes, same thing. And that's all we need for our form data. Okay. We're then going to have const handle submit. Okay. For this, we're going to take in E. This is going to be of type react form event. We're going to have a function here. We're going to say e.prevent default so it doesn't refresh the page. Then we're going to say if not form urltrim or not form title.trim sorry or is submitting. Okay. Okay, so if any of this is true, so if you don't have a a URL, you don't have a a title or we are currently submitting, then we are simply going to return. We're not going to let them submit the form. Otherwise, we're going to call the onsubmit function with the form data and we're going to say if we're not editing the form, then what we're going to do is say set form data and we're going to set the form data. So we have an empty URL and empty title and empty notes like that. Okay. So that's going to handle the submit. Now the rest of it is just going to be essentially the actual form that we need to build. So what we're going to do is we're going to say return. Okay. Now I want to return a form. Now I just realized that I need to rename this to be.tsx. So let's rename this to tsx so that this works not just ts. Okay. Okay, so we're going to have a form. We're going to end the form tag. So let's do that. Inside of the form, we're going to have the onsubmit equal to handle submit. Then we're going to have class name equal to form. Okay. Then we're going to have an H2. In the H2, we're just going to say the following. This is going to be class name equal to form-title. And then we're going to have is editing question mark and then edit bookmark. Otherwise, we're going to say add new bookmark. And actually, this reminds me at first I was going to make this form allow us to edit a bookmark as well. But now we're not going to do that. So, I'm just going to remove all of this is editing stuff because we don't actually need this uh for this component. So, let's just get rid of all of that. Okay. And then we can remove this. And we can just say add new bookmark because this is just going to be for adding not editing. Okay, that'll make it a little bit simpler. Now we're going to have a div. We're going to say class name is equal to form dash group. Inside of here, we're going to have a label. This is going to say HTML 4. And this is going to be URL. And then class name is equal to form dash label. Here we're going to have URL and an asterisk. Then we're going to have the input field. Okay, the input field is going to have a lot of props. We're going to say type is equal to URL. ID is equal to URL. On change is equal to E. And then this is going to be set form data. We're going to say dot dot.prev. We need three dots here. And then we're going to say URL is e.target dot value. And then we need prev here like that when we set this and then put this inside of parenthesis. Okay. So that's going to be the onchange. We're going to have class name equal to form dashinput. We're going to have the placeholder equal to https/acample.com. We're going to have required which is true and we're going to say disabled is equal to is submitting. So you cannot do it anything here if you are currently submitting. All right. So again this form is for adding a new bookmark. So to add a new bookmark we're going to have a URL, we're going to have a title and we're going to have some notes. So we'll just copy this form group and paste it again and then modify this now uh for the title. So we're going to say URL for title. We're going to change this just to say title. And then pretty much everywhere we're going to go type text ID title. Rather than URL, we're going to call that title. And for the placeholder, we can just go something like enter title. [Applause] Okay, that should be it. Now, same thing, we can copy this and do the same thing for notes. So, we're going to change this to be notes. For the placeholder, we'll say enter any notes. We'll change this to say notes. We'll change this to say notes. And then same thing, notes without the asterisk because this is optional. All right. So that's our form groups. Now we're going to have the submit button. So we're going to have button. We're going to say submit. We're going to say type is equal to submit. We're going to say class name is equal to btn btn- primary. We're going to say disabled is equal to is submitting. For the button, we're going to say if we are submitting, then it's saying saving. Otherwise, it'll say save bookmark. Okay, that is the form. Let's make sure this is exported. It is. Okay, I'm just going to format that. So, we're all good. Now, what we're going to do is use that inside of page.tsx. So from here we're going to say import the bookmark form from our bookmark form and then what we can do is we can go here to where we're going to show the form and we can render that. So we're going to say bookmark form on submit as handle add bookmark is submitting is is submitting. Okay. And then let's save that and I think we should be good to go here. Okay. Now we are very close to finish the UI. We can quickly test and see if this is working. By the way, we can just refresh. And you can see that when we press add bookmark now, we see this. I think the styling is a little bit messed up for some reason. So, I probably forgot to add a um style tag somewhere. I typed it wrong. You can see it is toggling it. When you press it, it makes sure that we fills makes sure sorry that we fill in this field. Uh we could test that later, but for now, actually, you know what? Let's test it right now. Let's go enter title tech with Tim website. Okay, let's go best site and say bookmark. Okay, I think it worked. I mean, it's just not showing it right now. And then if we go to Prisma Studio here, we can see bookmarks and the bookmark was added. All right, so that's working. Now, we need to display the bookmarks. So, I'm going to make two new components. The first component I'm going to make is the bookmark card.tsx. And then I'm going to make the bookmark list. bookmark list.tsx as well. Okay. So for the card, let's go ahead and do that. We're going to say use client. I'm going to say import the bookmark type from attypes/bookmark. I'm going to make a quick interface and say this is the bookmark card props. Inside of here, I'm going to say bookmark bookmark like that. I'm going to say on delete and this is going to be ID colon string. Okay. And then that's going to return to void. Okay. Then we're going to say export default function bookmark card. This is going to take in the bookmark. and on delete from the props. Inside of here, we're going to add a few kind of validation functions as well as just what the bookmark is going to look like essentially on our UI. So, we're first going to say const format date. So, we can show the date that this was actually um what do you call it added at. So, we're going to say date like that. And then what we're going to do is say return new date. We're going to take in the date. We're going to say to localal date string. What this is going to do is give us a local string based on our time zone. We're going to say en- us and then we're going to do the following. We're going to say year is numeric. We're going to say month is short. Okay, let's spell that correctly. And we're going to say day is numeric. Okay, so that's going to format a date for us and we'll make sure we're returning that. Then we're going to say const get domain. What this is going to do is actually create a domain from a string so we can open it up in the browser. So we're going to say URL string and then what we're going to do is try the following. So we're going to try const domain equals new URL. This has to be all capitals. And then we're going to say URL.hostname. Okay. Then we're going to return the domain.replace. And then we're going to replace www dot with simply an empty string. So just get rid of that. And then we're going to have a catch error. And we're just going to return invalid URL. Again, this is so we can kind of press on this and actually open it up. Then what we're going to do is we're going to say return and we're going to return a div. Now, inside of the div, we're going to say the class name is equal to the bookmark dashcard. Okay. Then we're going to have another div, and we're going to say the class name is equal to bookmark dashactions. Then we're going to have a button. For the button, we're actually going to put a trash emoji. So, let me find one here. So, we're going to put trash like that. Then what we're going to do is we're going to say on click is equal to and we're going to say on delete and we're going to pass the bookmark do ID bookmark do ID like that. Okay. Then we're going to have the class name and the class name is going to be action btn delete. And then we're going to have title is equal to delete bookmark. Okay. And let me just format that there. All right. So now we have the button. This is going to kind of be at the top. So we're going to have like a little top area where we'll have a button that allows us to delete it. Then we're going to have an H3. This is going to be class name equal to bookmark- title. And then we're going to put the title of the bookmark. Then we're going to put our link. So we're going to say a href is equal to bookmark dot URL. We're going to say target equals blank. This means we're going to open it in a new page or a new tab. And we're going to say re is equal to no opener, no referral. And then we're going to say class name is equal to bookmark- URL. And then you guessed it, we're going to put the bookmark URL. Okay. Then we're going to put a paragraph tag here. And we're going to say class name is equal to the bookmark dash meta. Now here we're going to get the get domain bookmark URL and then we're going to do dash and then format date bookmark.created at. Now actually sorry I lied. The get domain is so we're just going to show the host name or the main domain and it's potentially uh invalid. So that's why it could be an invalid URL. Otherwise it could be valid as we're going to render the URL as you see here. Okay. And then lastly we're going to say if we have bookmark.note notes. So if there are any notes, what we're going to do is the following. We're going to have a div. We're going to say class name is equal to, and this is going to be notes dash section. We're going to end the div. Inside of the div, we're going to have a paragraph tag. The paragraph tag is going to be class name equal to notes dash content. And then we're gonna have the bookmark.notes. Cool. And then let's format that. And that is our bookmark card. All right, we are almost done. The last thing we need to do is the bookmark list. So this is the component that's going to list all of our bookmarks. It's going to be a lot shorter. Then the entire UI is done and we can move on to the MCP server. So we're going to say use client. We're going to import the bookmark from same thing our types. We're also going to import the bookmark card that we just wrote from that component. We're going to say interface and this is going to be the bookmark list props. Okay, we're going to say bookmarks and this is going to be bookmark like that. And then we're going to say on delete and we're going to take in the ID the string and then void. Okay. Then we're going to say export default function bookmark list. We're going to take in the bookmarks the unddelete from the bookmark list props. Now what we're going to do first is we're going to say if we don't have any bookmarks. So if the bookmarks.length is equal to zero. So if there's none in our list then we're just going to return a simple UI that essentially tells them hey you know you don't have any bookmarks. So, we're going to say return div class name. This is going to be empty dash state. Then we're going to return another div. And this is going to be class name. We're going to say empty dash icon. I'm going to put in here a book. So, I'm going to say book. And I'll just put this one like that. Then we can have another div. And this div is going to say, or actually rather than a div, let's change it to an H3. And for the H3, we're going to say no bookmarks yet. Okay. And then let's add a paragraph tag. And let's go class name is equal to empty dash text. And we're going to say add your first bookmark to get started. And that's going to be the empty container. Now let's do another one here. So if we are not empty, then we need to show the bookmarks. So we're going to have a div. We're going to say class name and this needs to be what is it inside of the correct thing. So outside of that. Okay. Boom. So there we go. And then we're going to say bookmark dash grid. Then what we're going to do is say bookmarks dot map and we're going to map our bookmark to its page. Well, we're going to return a component. So the component we're going to return is the bookmark card. We're going to say key is equal to bookmark do ID. We're going to say bookmark is equal to bookmark and we're going to say ondee is equal to ondee. We're going to format that. And that should be I think everything that we need. So we have a div and actually I'm just going to wrap this in one more div. Okay. So we're just gonna have an empty div wrapping around this again. Save and format. And now we are good. Okay. Okay, so we have the bookmark list. If it's empty, we render this. If it's not empty, we show a simple grid with all of the bookmarks mapped out here. Now, let's render that component from our page. So, we're going to say import the bookmark list from what we just wrote. And then, of course, we need to now hook this up. So, let's go into page and let's write that. So, we're going to go inside of signed in underneath the form and we're going to say bookmark list. We're going to show the bookmark list. We're going to pass our bookmarks equal to bookmarks and we're going to pass on delete equal to handle delete bookmark and we're going to format that. And now we are good to go. All right. So that should be the entire UI. I think it's still running. It looks like it is. So if we go here and we refresh, you can see that it's showing our bookmark. Again, the padding is a little bit messed up, so I'm probably just missing a CSS class, but you can see that it shows up here. Now, if I add another bookmark, let's go this one. AI voice gen. Whatever. Let's see. Voice gen. and save the bookmark. Oh, it's making me do notes. Okay, I can remove that. But let's say for AI voice gen and we save that. Then you can see it shows up here. Then obviously if we signed in with another account, we wouldn't see it. And you can see it's showing us the root domain rather than the kind of slash page, which is how I had this set up as well as the formatted date for when it was added. And let's try to delete. So if I press this, we want to delete. Okay. And then you see that it removes the bookmark for us. Okay. So our UI is functioning now. We know that it works. We just tested it. All the features are here. Again, we can kind of ignore the CSS for right now. And now it's time to move on to the next part, which is setting up the MCP server. So, let me show you how we do that. Okay. So, as I promised, we're going to add the MCP server. And I'm just going to follow this documentation here that comes directly from Clerk. I'll link this in the description in case you want to follow along with it. And you'll see like that's kind of how I figured out how to do this. Now, essentially, we already installed the packages that we need. And you're going to see that it starts showing us what we need to create in terms of adding the MCP server. Now in short to do this it involves adding three separate routes to our API. So one for transport and then two for if we keep going here let me find this the OOTH authorization server and the OOTH protected resource. You don't have to worry too much about these but essentially they're required for the OOTH flow uh as was described here. So you can see that it kind of like you know we have to go back and forth. We have to have these particular endpoints. So clerk is showing us how to add those. Now in order for any of this to work first of all we do need to go to our clerk dashboard. Now from our clerk dashboard in our project we need to configure a few things. Now first of all there's a lot of stuff that you can do here right? So you can make like custom UI components deploy your application. You can have like user management organizations etc. I'm just going to go to configure my application here. And first of all again like there's all these settings that we can mess with that you can go through like do you want them to sign up with a phone? Do you want to use a username? Do you want to add usernames to an existing account? Do you want to have pass keys? So all of this is handled by clerk which is really really nice. And of course for the MCP server it makes it quite easy as well. But we need to go all the way down here. We need to find OOTH applications. And from here we need to just check this box that says dynamic client registration. Acknowledge this and enable it. This allows and I got to save that here uh our MCP clients or MCP hosts to actually connect to the MCP server and register themselves uh without us having to do it manually like you would have to create a manual application here. Okay, so this just means essentially any AI tool can connect to our MCP server and use it. All right, that's pretty much all the settings we need to do in Clerk. Again, I just want to make you aware there's so much stuff in here which is why I personally love Clerk and why I use them for pretty much all of my projects for authentication. You saw how easy it was to add in this particular project. And now you'll see it with the MCP server. Okay. So, let's take these docs. Let's put it on the right side of our screen. And let's open up this on the left side. So, let's put that here. Make it a little bit smaller. Okay. Let's close some of this stuff because we have a lot of things open. And let's start setting up our roots. So, again, if I'm following along with this, first thing we need to make this app/transport. So, we're going to close everything here. We're going to make sure we're in our app directory. We're going to make a new folder and in square brackets, we're going to call it transport. Okay. Now, inside of here, we're going to make a root.ts and we're just going to copy the code. Again, I will link it in the description. Now, as we keep going here, it's going to show us how to create an MCP tool. Now, we can create a tool. We also can create resources or prompts. Again, I'm not going to cover in depth exactly how the MCP servers work, but the point is that you can have all of these tools on the MCP server which you can expose to an AI host, something like cursor. It can then call those tools and use them. In our case, there's two tools that we want to provide. We want one for getting a user's bookmarks and for creating a new bookmark. So, while this is giving us an example of a tool right here, this is not actually the tool that we want. We want to make our own tool. So I will copy this but I'm going to modify it and I'm going to start creating the tool that we need. So let's make this smaller. Okay. And let's write our first tool. So rather than getting the clerk user data which is that's what this is showing us how to do essentially you know you can await the authorization get the clerk user data. What we want to do is different. So first we're going to change the name here. Rather than get clerk user data, we're going to say get user bookmarks. Okay. And then for the description, we're going to say get all bookmarks for the authenticated user. Obviously, make sure you write a good name and a good description because this is how the LLM will know what tool to call. Then we're going to import a few things that we need here. So, we're going to import first of all the get user bookmarks, okay, from our lib. That's why we put it in the lib. So it's reusable. We're also going to get the create user bookmark from there. We don't need delete. We're not going to add that as a tool right now, although we could if we wanted to. And then we're going to import and this is going to be the create bookmark data from our types. And we're going to import zed from zod. Okay. This is going to allow us to do some more advanced documentation for another tool that we write in a second. Okay. What we're going to do is we're going to clear out some of this stuff here. So, I'm going to get rid of that. I'm going to copy my user ID and I'm going to put a try catch block here. So, we're going to say try catch like that. Now, in the try, we're going to get the user's ID. Okay, so off info.extra user ID. Then, we're going to get the bookmarks. I didn't even mean to do that, but the AI automatically did it for me. So, we're going to say bookmarks equal to await get user bookmarks. And then, we're going to return and we're going to return a type that says content is going to be a list. We're going to say type is text and the text is going to be JSON stringify the bookmarks. Okay, so we need to always uh return stuff as text or at least that's how we're going to be returning it here. So we're going to get the object which is the user bookmarks. We're going to turn it into a JSON string and we're going to return that from our MCP tool. Now we're just going to copy this as well and we're going to put this down here in the catch and we're going to catch an error. The type will be text. And then for the text here, we're going to say in back ticks error like this. And then we're just going to show what the error message is. Okay. So this is pretty much how you make a tool, right? You put the name of the tool, you put the description here. You put any parameters that need to be passed to the tool. I'm going to show you an example when we make another tool in just one second. And then you write the tool body. So it's an async function, right? We get our authentication info. We can check here the user's ID. We can use the user's ID to get their bookmark and we can return it. However, this handler only works if we actually have this O handler down here. So, we're going to copy the rest of the code from the documentation. We're going to paste it in this file. And you'll see now that we're exporting off handler as get, off handler as post. So, if a get or a post endpoint are send sent, sorry, to this route here, then automatically it's going to go into this function. What it's going to do is it's going to get the authorization token from clerk. It's going to verify the token and make sure it's valid. And then it's going to also provide this ooth protected resources path if we don't pass the correct authorization token. You don't have to worry too much about this, but essentially we're going to forward all of the routes into this function. It's just going to make sure that we're authenticated. If we are authenticated, it's then going to go into this handler. It's going to call the correct MCP tool as is required. It's going to pass pass the authorization info and then we can use that to get the user that's actually using our MCP server. Okay, so that's a start here. That's one tool, but I just want to write the other tool. The way we do that is we put a comma kind of after this server tool and then we can write the other one like this. So we can say server tool and the next tool I'm going to do is the one for creating a bookmark. So, I'm going to say create dashbookmark. And then I'm going to write a description. And the description is going to say create a new bookmark for an authenticated user. Okay, let's spell that correctly. And let me just make this a bit larger for now. We can open the docs after. Okay, this will be fine. Actually, let's just fix the spelling as soon as we add this next parameter. Now this next parameter is the parameters or the values that need to be passed to this tool. So what we're going to have is a URL. So we're going to say URL is Z dot string. Okay. And then doescribe. So we can describe all of these values. And I'm going to say this is the URL of the bookmark to create. And then you see we have two more. So we have title and we have notes. So we're going to pass a title and we're going to pass a notes. And for the notes, this is optional. So I'm going to say dot optional like that. Uh, oh, and it already was optional, but either way, we can do it before. Okay. Now, again, essentially, we're just using this ZOD tool to do the documentation to say, hey, like these are the things that need to be passed. Now, when you're making the MCP server, you need to make sure that you document these correctly and that you have the correct descriptions. If you don't have the correct descriptions, then the LLM isn't going to know how to call it. Regardless, we also want to get the user's ID here because we're going to create a new bookmark for them. So, we're going to have our try statement. We're going to go in here. We're going to have our catch statement with an error. Okay, we're going to get the user's ID. Then what we're going to do is we're going to create the bookmark data. So we're going to say const bookmark data is of type create bookmark data. Inside of here, we're going to specify the value. So we're going to say URL is args URL. We're going to say that the title is args.title and we're going to say that the notes is args dotnotes or just an empty string in case it's not passed. Then we're going to say const new bookmark is equal to a weight create user bookmark. We'll pass the user ID and the bookmark data. And then we can return. So we're going to say return. And then same thing we're going to say content type text JSON.stringify the new bookmark. Okay. And that should be good. Now we also can put some back tick if we want to make this a little bit better. So let's go back tick. We're going to say created new bookmark. And then we're going to say colon. We're going to do the dollar sign. We're going to embed the variable here. And then close the back tick like that. And I think that's good. Yes, looks good. Okay. And then for the error, we can just copy the same one that we had here and put it like that. And now the error is handled. So now we have two tools. One for creating a bookmark, one for uh getting bookmarks. And if you wanted to make new tools, well, it's very easy to do that. You just write another tool in this list. Again, give it a name, give it a description, write any of the parameters here and document what type they are as well as the description. And then automatically the MCP server will be able to pick up these tools. Okay. And I realize we're also not using this clerk client, so I'm just going to remove that for now. And we'll just have this off function. Okay. So that's it in terms of the main MCP server route. This is where we define the tools. And again, if you want to add more tools, you would add them here. And clerk is automatically doing the handling with our O. And I'm just going to format this so it's a little bit nicer. Okay, so that's working. However, in order for us to actually get our authorization token, we need to expose our MCP metadata endpoints. Like I was showing you in this OOTH flow, there's particular endpoints that the MCP client is going to attempt to hit in order to receive the OOTH flow instructions. So, we need to implement those on our server. One of them is kind of the current one. One of them is the older standard, but we're just going to implement both of them to make sure that no matter what client we use, it will be able to understand how to authenticate with our server. So, in order to do that, it gives us some instructions here. Again, let's split this over to the left. We need to make a new folder inside of app and we need to call this well-nown. Make sure you type this exactly, otherwise it's not going to work. Then, we need to make two new folders. One is going to be the OOS ooth sorry authorization dash server and another let's make this a little bit larger is going to be the ooth and then this is going to be dashprotected dash resource. Okay and you can see those here right it's showing you the names so the paths that's where I'm getting them from and then inside both of these we're going to make a new file called route.ts ts and then same thing route here dot if we spell this correctly ts. Now all we're going to do is literally just copy the code that's here. So for ooth authorization server we're going to paste that inside of that file. We'll look at it larger in a second. And for the protected resource, same thing. We're just going to copy this and put it in protected resource. Looks like I put it in the wrong file. So let's paste it in the correct file. Okay. Copy that. Paste that here. Copy this. Let's go in the other file. Paste that here. Okay. And let's have a look at them and I can explain what's going on. All right. So, OOTH authorization server. Essentially, what this is going to do is it's just going to automatically return the correct authorization server for clerk. You don't need to worry too much about it. It's already just implemented for us from the clerk MCP tools. Same thing for the protected resource. In this case, we need to specify some scopes like the profile and the email which the MCB client will be able to get access to. Again, don't worry too much about this. It's already implemented for us. We just need both of these routes so that we're able to actually perform the authorization essentially with the MCP server. Now, that is literally it. So, now that we have that, I'm going to show you how to add this as an MCP server inside of one of the clients, specifically in this case, cursor. So, from cursor, you can open up the command pallet with control shiftp. You also can just open up the settings menu if you're able to navigate that. And what you want to do is type MCP. From here, we want to open the MCP settings. So from the MCP settings, what we're going to do is we're going to go to this little edit button. So it should say add new custom MCP server. So you can press that. And then we're going to add a new MCP server with a URL to our current kind of uh project URL, which is localhostport 3000/MCP. So let's say this was empty because yours is probably going to look like this. What you're going to do is you're going to write something like bookmark MCP or bookmark manager, whatever. Then you're going to go colon and then you're going to go URL is equal to and then http slash localhost port 3000/mcp or wherever your server is running. It should be on port 3000. And then just make sure you append the slashmcp. So now if we go here, let me just close this and rerun it. It should be good to go. And if I open up my MCP settings now, it should say needs login. So, we can toggle it off and toggle it back on. Just make sure that it's loading. When we do that, we should see a bunch of URLs hitting here. So, it's compiling all of these routes. And you can see that it's looking at the OOTH protected resource as well as the OOTH authorization server and it's getting all of these URLs. Tells us that we need to log in. So, what we can do is go needs to log in. Open this up. Okay. We're going to wait a second here. It's going to bring us to a clerk page. Okay, we can modify this again. We're going to go allow open cursor. Here we're just going to go don't ask me and go open. And then it should start loading the tools for us. You can see that we have the two tools get user bookmark and create bookmark. And then if we go into our agent mode, we can say something like let's go here. Can you tell me my current bookmarks? Okay. Okay. And let's see if it can get them. It's going to call this. Okay. And you can see we have one bookmark. We're going to say add a new bookmark for the Rust docs or something. Okay. And it should be able to do that. Okay. And it's called this. And then if we go back to our UI here, let's go back and refresh. We should see that we now have two bookmarks showing up uh because we were interacting with the server. There you go. Right. So, we've got this functioning. And then of course if we signed in with a different account, we would have a different set of bookmarks. So with that said and done, I mean that's pretty much the entire project. I mean we could test this again. Let's add another one. Let's go random URL. Okay. And we're going to say Enro URL. Let's save it. Okay. And then if we go back here, what bookmarks do I have for Enro? Okay. We can ask it a question. It should run the tool. And then wait a second. It says we have one bookmark, the one that we just added, and it shows us the URL. Perfect. So, we've got this working. And the reason why this is so cool is because now we can build some type of application and we can expose the functionality on an MCP server, which means all of these AI or LLM based tools can now use all of our user data and these tools in this tool, right? In this LLM or AI based tool. So, as application development continues to move more towards MCP, more towards AI, using LLM, this is going to become more and more important, and that's why I wanted to make the video on it and show it to you today. So, with that said, guys, that wraps it up. That's everything. That's all we needed to create. I hope that you found this useful. If you did, please make sure to leave a like, subscribe to the channel, and I will see you in the next one. [Music]",unknown
1nfRxFJZ7c0,"I can almost guarantee you that at some point in your life you wrote code that looks like this. So here's the first way that you can fix this code. Now what I've done is I've created a dictionary. So whenever you've got kind of values mapped to some other values like a one is Monday, a two is Tuesday, what you can do is you can kind of map them using a dictionary. So notice what I've done here is I've mapped one to Monday, two to Tuesday, three to Wednesday, and I've written this dictionary that contains all of my keys associated with their values. And then I can simply get out of the dictionary the key and it will give me the value. So if I say daysw week get and then the day number, if this number exists as one of the keys inside of the dictionary, it's going to return me the associated value. So if I put a one here, it's going to give me Monday. If I put a six here, it's going to give me a Saturday. And if this number for some reason doesn't exist as one of the keys in the dictionary, we'll simply return invalid day",unknown
bWE0OZuZA2A,"Once you've mastered the core Python syntax and the language, you need to start getting efficient with the tools that you're going to use as a developer. So, your tools determine your productivity and your effectiveness. The biggest mistake you can make is relying purely on passive learning. So, just watching tutorials or reading blogs or books. Now, studies show that passively learning only helps you retain about 20% of what you consume. But when you actually get your hands dirty, you build, you experiment, you write real code, you can retain as much as 75 to 90%. And that's why interactive project-based learning isn't just optional, it's essential.",unknown
JXUcWMFS6Ow,"I'm willing to bet that most of you have seen this code before and probably have no idea what it actually does. So in this short video, I'm going to break that down. So let's go ahead and get started. All right, so let's get rid of this to begin because in order to understand its use case, we need to have a look at some sample Python code. So look here, I have this calculator.py file. Now this is a file that I might directly run myself. And if I want to do that, I can press run and you can see that it says this is a simple calculator. I can enter some numbers and then I get the sum and the difference of those values. Okay, so let's type this correctly and I will break down what these variables mean. Okay, so you can see that I have if name is equal to main with the double underscores. And by the way, this is sometimes referred to as dunder. So dunder name or dunder main, which means double underscore name double underscore main. And when you do this, what's going to happen is this code will now only execute if this module is ran directly, not if it is imported. So let me show you what I mean. Now, if I go and I run my calculator.py file, you can see that this works and it runs. But if I run my program.py file, it no longer runs this code. It just runs whatever is directly inside of",unknown
kAUBB12-OoY,"If you want to become a Python developer as quickly as possible, then you have to skip through the fluff and focus on exactly what matters. Now, once you've done that and you're really comfortable writing Python code, you need to move on to object-oriented programming. Now, this means understanding classes, objects, inheritance, and encapsulation deeply. This is because Python is an object-oriented programming language. And to really get good at it, you need to understand these concepts. So you can build small projects like a basic bank account management system or a textbased adventure game to practice these different concepts. Anything that's using object-oriented programming is going to be good practice. Okay. So next I suggest looking at async and concurrency. Now you need to learn how async operations work using the async IO library and practice with basic multi threading.",unknown
_y3LNjg0o_8,"If you want to become a Python developer as quickly as possible, then you have to skip through the fluff and focus on exactly what matters. Now, today I'm going to give you a proven detailed blueprint to go from zero experience to a job ready Python developer faster than you ever thought was possible. Anyways, let's dive into exactly how we do that. First, master the core skills. Second, become efficient with essential tools. Three, specialize and create value in a particular niche. and then four, find a job or land a job. All right, so let's drill into exactly how you can accomplish each of these steps. So step one, mastering the core skills. Now, without foundational skills, nothing else matters. So here are the exact skills that you need and how you can approach them. First, core syntax. So you should spend probably about 2 weeks here learning variables, loops, conditionals, data structures like lists, dictionaries, and sets, and functions. You need to write a bunch of Python code like small scripts that automate small tasks like maybe renaming files, simple calculations, and basic data manipulation.",unknown
FTe2_rrXDMM,"Learning Python is just the beginning. Most devs finish the basics and they get stuck. They don't know what to do next and it kills their chance of ever getting hired. So, here's exactly what you need to focus on after the basics if you actually want to land a developer job. Don't skip learning SQL. Pretty much every serious app is going to talk to some kind of database. Doesn't matter whether you're a data analyst, a web developer, or doing automation, you need to understand, for example, Postgress SQL internals. You should be able to write basic select queries, do joins on tables, handle the CRUD operations, and integrate a database into a Python app using something like SQLite 3 or SQL Alchemy. Now, you don't need to be a complete expert in SQL. I wouldn't take a 5 months long course on this like I had to do in university, but you should know the basics. You should be able to write a few queries and you should just know kind of under the hood how does a database actually work and how is Python interfacing with",unknown
sNH9xmVPxJI,"If you want to build a website in Python, then you're in the right place. Now, Python offers some incredibly powerful yet beginnerfriendly frameworks that can get you from zero to a live website in literally just a few minutes. Three easiest ways to build websites with Python. And that includes Streamlit for data apps and prototypes, Flask for lightweight web applications, and Django for fully featured websites. Anyways, let's dive into it and start with Streamlit. Now, Streamllet is by far the easiest way to make a website in Python, and it's a massive gamecher because you don't need to know HTML and CSS. Streamlit allows you to write only Python code, literally pure Python code, and have a fully functioning website, and it comes with a ton of built-in components that make it very easy to do this. Now, that said, Streamllet is best used for data science and AI related applications. It's typically very good for building fast demos or interacting with LLMs or for example showing chart data or images. It's not necessarily the best when it comes to features like authentication, for example, or fullyfledged websites that you'd want millions of people to be",unknown
i3fDNWGHoG0,"Now, this is the difference between I learned Python and I'm a software developer. Being employable means knowing how to do the following. Solve real problems, not just textbook ones, but ambiguous, messy, and weird problems that don't have a defined solution. Working with APIs, because no modern app exists today in isolation anymore. You're always using other components. Being able to connect to databases, not just read from them, but design and query them efficiently. Debugging and fixing things when they break because of course things are going to break. And then using version control like Git, not just saving files as final one, final two, final three, etc. And maybe the most importantly, build code that other people can actually use and understand. Now, that's what companies are hiring for today. It's not about memorizing syntax or completing hundreds of lead code problems. It's about being someone that they can trust to ship working code in a real environment with a real team. And if you don't focus on closing that gap, getting beyond the basics of Python, then this is where you're going to get stuck. And many people do get stuck for",unknown
jv8IbOnaUPM,"Just like programming is evolving, so is Python. The way that we use Python today is drastically different than five or 10 years ago. And in this video, I want to get into that in a lot more detail. Now, I actually had a look at the Python developers survey. This surveyed over 30,000 developers specifically focused on Python. And in this video, I'm going to break down some of the most interesting results. Now, this survey was conducted by the Python Software Foundation as well as the Jet Brains PyCharm team. So, what I'm going to do is dive into all of the results. I'm going to share with you. And by the way, if you want to check it out, I'll leave a link to it in the description because I'm just going to go over some of the most important parts and what it actually means for you as a Python developer in 2025 and beyond. So, I've got the survey open. You can access the same page from the link in the description and I'm just going to skip through and cover what I think are the most interesting insights and what that actually means as someone who's a Python developer. Now, one thing to note is that this was done in November 2024. Hence why we don't have the 2025 version yet because it's going to happen in 2025. The results were just kind of aggregated recently. And then this was also surveying 30,000 Python developers. So people that mostly write in Python as you're going to see as we go through this survey. It wasn't surveying just all random developers. So keep that in mind. This is very biased towards Python developers as it should be considering it's the Python developer survey results. Anyways, you can also see the previous uh years if you want and you can kind of see the trends that are going on there. Okay, so let's keep going here. First thing, general Python usage. So obviously if we're surveying Python developers, well, most of them are going to be using Python as their primary language. You can see that's 86%. And then what's interesting to note is that along with Python, most people are using JavaScript. You can see that's 40% as a secondary language. And then things like SQL, HTML, CSS, and that makes a lot of sense considering what Python is used for, mostly web development and data science. Cool. Let's keep going. Uh, another interesting point here is that most people that are writing code with Python professionally have been doing this for less than one year or in this case less than two years. But 50% of all Python developers, professional Python developers have no more than 2 years of experience. So if you are someone who actually does know a lot of Python, you become an expert in that field. You have 5 6 7 8 10 years of experience in Python. You're going to be quite rare as you can see here because most people are kind of beginners when it comes to professional experience. And then in terms of how long have people been programming in Python, what this tells me here is that most people have learned Python at some point in their life. They've been doing it for a while, but they just haven't done it professionally. Hence why we see the largest um kind of category here, 30% of people having 3 to 5 years experience. That doesn't mean professional experience. It just means they've been programming in Python for that long. And then that leads us to this, which I think a lot of us probably already know, but it's worth noting that Python is the most popular programming language for learning to code. Hence why I do so many tutorials on this channel and I typically recommend Python as the first language to get into. Okay, so let's keep going here. There's a bunch of other stuff that we can look at, but again, not all of that is interesting. What I do want to get into is what Python is actually used for. People ask me all the time, why should I learn Python? What do you actually use it for? Well, we can see here based on the survey results what the most popular uses are. Now, of course, we're going to have data analysis and web development up there. And then we have machine learning, data engineering, web scraping and parsing. That's something that's getting a lot of attention recently. Academic research, that's not as interesting to me. And then we can go through the rest of them where it gets, you know, quite small down here for things like MLOps, game development, embedded development, etc. So, if you go here, you can see kind of the main categories. Again, we can skim through those. I don't think it's too useful. We pretty much all know that Python is used mostly for web development and the machine learning, AI, and data analysis. And if you go down here, they kind of rank their primary, secondary, and hobby activities. And we can see when it comes to hobby activities, a lot of people are doing uh it's kind of hard to check this here. Programming of web parsers, scrapers, and crawlers, which is kind of interesting. That's, you know, a pretty big jump there uh compared to the other sections. Okay. Now, this is where I think it gets a lot more interesting in terms of the frameworks that people are actually using for these different activities. So if you're someone who wants to become a Python developer, this your favorite language, you're writing it all the time, you should probably pay attention here to the frameworks people are actually using in professional development because that's probably what you want to learn. So we can also look at the trends and the growth. And I mean this actually even relates closely to me. I used to always just use Django and Flask. Now I pretty much just always use fast API for doing my APIs. And we can see most people are doing that as well. So of course we have fast API, Django, Flask and requests, async.io as well. But most people when it comes to building APIs now are going with fast API. So that's definitely something that you'd want to focus on if you wanted to become a professional Python developer. And you can see all the growth there. I expect that's going to continue to grow as more and more people learn that framework. Again, few things over here in terms of data science web development, but generally speaking, Flask, Django, fast API request is a pretty easy one to learn. So of course that's going to be up there, but most people favoring fast API for API development and I would assume Django for more full stack sites. If we go here, we can see a few other web framework crossage. So a lot of these frameworks are kind of intertwined to one another. So for example, Starlet is used all the time. AIO HTTP like they're dependencies of each other, which is kind of what's happening right here. And we can see Django, you know, is used with Django West REST framework 93% of the time, right? Fast API is used with HTTPX or Starlet, of course, right, for running the server 92% of the time. And you can kind of go through those, but I think, you know, that's pretty straightforward. Cool. Continuing here, other frameworks and libraries. Beautiful soup. So if you're doing any kind of web scraping or parsing, that's a really interesting library to look at. Pillow, this is for image manipulation. Um kind of loading in dealing with images and computer vision related stuff. Pyantic, that's going to be super popular for uh frameworks like fast API where you need to do the type validation. Open CV again for computer vision. I'm actually surprised that we have these tokin, piqt, uh scrappy, and pygame. Obviously, Pygame being my favorite Python module, but Tequiner and PIQD is interesting because you can use those to build uh what do you call it? Graphical user interfaces or desktop applications. Actually interesting to me here that that's increased a little bit from 2023 to 2024. Unit testing framework pretty much everyone is just using piest or unit test which is built into Python. I actually have a tutorial on this. Definitely recommend you learn it. It is quite simple. And then of course all of our great Python developers, 36% of them not testing at all. So the next interesting part of this survey to me is the data science section. Now first of all 51% of devs are doing something related to data science which obviously makes a lot of sense especially with AI becoming super popular now. We need data to train those AI models. And when it comes to the libraries that people are using of course we have pandas and numpy. I'm sure you guys probably know this but if you want to get into data science you need to know these modules. And then we have a few other ones that are a bit less popular like polars airflow inhouse solution dask etc. But pretty much everyone is just using the go-to triedand-true pandas and numpy. I'm going to skip the data versioning here. This one's interesting as well. Streamlit is the most used by far now for uh data dashboards. And then we have plotly as well. This is what I use all the time now. I recently found out about Streamlit maybe a year ago, year and a half ago. Since then, it's been my go-to. If you haven't used that before, definitely recommend it. It's super easy to make basic web interfaces with Python without having to know any JavaScript, HTML, etc. in like a few lines of code. You can make, you know, really interesting dashboards and display all of your data. Going to skip over a few of this other stuff, but let's get into the ML model training and prediction. So, interestingly, most people are still using Scikitlearn. I think that goes to show that while we have all these LLMs and crazy models and stuff, uh, people still just need some more basic AI solutions or machine learning solutions and scikitlearn is pretty much perfect for that. And then of course we have PyTorch and TensorFlow. Interesting to me that PyTorch is more used now. Uh, previously a few years ago, I remember TensorFlow was more popular, at least that's what I was using all the time. And then we have a few other ones like Scypi, KAS, etc. which is kind of just an extension. hugging face transformers and you can see that's got a big boost recently 6%. I think a lot of people and I've seen this as well are going towards hugging face for a lot of those models and then of course we have the cross usage here. So for example natural language to toolkit is used all the time with scikitlearn and we pretty much use everything in combination with scikitlearn to get these tasks done. Same thing here with pietorch. You're going to use a lot of these in combination with another uh scroll through the rest of this. We can see that most people are using Jupyter notebooks when they're actually doing the training and kind of data exploration, which is interesting. And I'm going to scroll through to the next section. So now we're getting into the development tools. Now, this is pretty interesting. Obviously, this doesn't add up to 100%. I assume that's because people are using multiple operating systems. Most people are using Linux, then followed by Windows, believe it or not. I know a lot of you guys think people only develop on Mac and Linux, but a lot of people write code on Windows. And then we have Mac OS, BSD, and other. And what AI tools are most people using? Chat GPT. That's interesting to me. I would have thought more people would be using things like C-Pilot or built-in idees or AI idees. However, I guess it's just first of the market. Chat GPT is the one that most people are comfortable using. Uh especially I guess with more beginners in the Python ecosystem. GitHub Copilot, Google Gemini, Claude, Visual Studio Intellode, Code GBT plugin, etc., etc. Tab 9. So we can see the more traditional autocompletes which used to be popular a few years ago are kind of taking more of a back seat now to the full LLM models which is an interesting insight for me. OM. So if you know OMS, object relational mapping, most people just using SQL alchemy, we can see for web development and data science and that's becoming more and more popular, which makes sense because in my opinion, it is just the best. And then Django OM, of course, if you're working in Django, you're going to use their OM. Databases, another interesting one. Postgress SQL getting some growth here. SQL light, same thing. MongoDB, still not super popular. So most people are opting for your traditional SQL tablebased databases uh with Postgress, SQLite and MySQL at the top and then some of the more NoSQL or caching databases a little bit lower down. Then we get to CI and CD. Not surprisingly to me, we have GitHub actions followed by GitLab CI up here. Makes sense. Just the simplest solution by far for doing continuous testing and integration. So I can see why those are the most popular amongst amongst sorry all of these Python developers. Most people are not using anything for configuration management, documentation, markdown, of course, that makes sense. Swagger, Sphinx, Postman, etc. And how do you typically work in a single Python file? I open the entire project that contains the file in the IDE. Makes a lot of sense. Some people using a command line editor. I can't imagine why you would want to do that unless you're on a VPS or something. I just open the one file in the IDE. Okay, that's interesting to me. I think these are probably more of the professional developers that are answering this 58%. Then main editor and IDE. You guys might find this interesting. We have pretty much just Visual Studio Code and PyCharm close behind. Makes a lot of sense to me. Those are just the most popular with 3% of people using Vim. Leave a comment down below if you are a Vim user. I'd be interested to hear that. And just a few last interesting points to go over here. Python packaging. So what are people using? See most people still stacking with Venv or Venv or however you want to say it followed by virtual env. Then poetry pip env. And we can see UV obviously a very new tool already grew to 11% which is very interesting and this is what I'm using pretty much all the time now. So I would definitely predict that next year UV is going to have a huge growth. I don't think it's quite going to be as popular as Venv. But I would suggest if you haven't already checked out check out UV. Very popular, very fast, very easy to use package manager and it's been my go-to in Python for the past probably eight months since I discovered it. Let's keep going through here. Anything else interesting? what tools you use to manage dependencies. Same thing, UV showing up here. And then, of course, we have pip. I mean, pip is just going to be used everywhere. And then lastly, of course, requirements.txt, pipro.toml, setup.pies makes a lot of sense. Now, another thing worth noting here is that Rust is picking up some popularity when it comes to building binary modules for Python. So, in the past, it's mostly C++ and C, but we can see Rust is slowly growing. And I believe we're going to continue to see that trend as more and more people learn about Rust and understand kind of the benefits and the usage. If we scroll down, there's a bunch of other stats. We can see, you know, 89% of people are male. I think that's probably close to just the programmer demographic in general. And then for the age, we can see most of them are sitting in between 21 and 39. Makes sense. Again, that's just the core demographic of programmers. Most programmers do not last that long in their career and by the time they're in late 30s, early 40s, as we can see here, they start to drop off pretty quickly. Be curious to see this compared to some other career paths, but I know in programming specifically, you typically don't find crazy old programmers. By that time, usually they're rich enough and they just retire. At least that's my experience. Anyways, that's kind of the main stats here from this. Now, look, there's a bunch of stuff that I didn't go over. I just wanted to cover what I personally thought was interesting and that I think you guys should be aware of. Generally speaking, what I'm seeing here with Python is that while it is evolving, more and more people are moving into data science using AI. We saw almost 51% of people are doing some kind of data science related work. People mostly are sticking with the tried andrude modules, the ones that just work that have been used forever. And then there's a few new tools that people are using because clearly they are just better. For example, we have UV, we have Streaml, we have everyone really pushing more towards fast API using paidantic with that. So, I think those are some interesting trends and if you're someone who's still using some of these older modules or you haven't switched over to a different package manager or you're still writing everything in Flask for example, then definitely consider kind of hopping on the trend and going with what most people are using because that's what's going to be used for most of the jobs, right? Or for most of these companies that are going to be hiring you. Of course, there's lots of other insights that we could dive into here. We could spend hours talking about this survey, but I'm curious to hear what you guys think. If you go through the survey or you just watched this video, leave a comment down below. Let me know what you think of the future of Python in 2025 and beyond. If any of these stats surprised you, if any of them, you know, you thought were quite normal, there's any other insights I didn't share that you think are interesting, I would love to hear them. With that said, thank you very much for watching and I look forward to seeing you in another video. [Music]",unknown
ZFFWhwe_pq8,"There's now an even easier way to run AI models locally other than using OALMA. Now, Docker just released their model runner and this is a complete gamecher for running models locally. So, I want to show it to you in this video. Now, just like Olama, you can manage, run, and deploy models locally with OpenAI compliant APIs. But the real game changer is that all of this is built right into Docker Desktop. So you don't need to install CUDA, you don't need to install a driver, you can just enable it and start using it right away. Now you can pull models directly from Dockerhub or from HuggingFace and then you can run them from the command line or from your containers and deploy Genai applications very quickly. Wait.",unknown
zhJCbvyGlp4,"Today I'm going to explain to you how I mastered data structures and algorithms quickly without hating my life. Continuing, let's get into my prep when it came to the questions. So, I saw so many articles online of people saying they did like 400 lead code questions or 300 lead code questions or even 200. That is insane to do that many questions. First of all, that will take you like four, five, six months unless you're doing five a day or something along those lines. And I want to tell you for myself, I only did 60 lead code questions and I did about 50 algo expert questions. Okay, so my process when I was practicing these questions, first of all, was to always emphasize quality over quantity. Now, yes, you do need to put in sufficient volume. I think getting to about 75 to 100 questions for most people should be enough if they're practicing correctly and picking the right questions. But for me, when I was starting out, I really struggled with these questions. like I could hardly answer some of the easy questions. So, what I would do is I would struggle at a question, but when I wasn't getting anywhere at all and I had put in the time and I had struggled, I would go and I would watch through the video explanation and really make sure that I understood it and then reattempt the question right after to see if I could actually do it on my",unknown
cQMGwslwS9w,"which is the dependency inversion principle or DIP. Now, in short, this says that we should depend on abstractions, not concrete classes. Now, the definition of this is that high-level modules should not depend on low-level modules. Instead, both should depend on abstractions. This makes the code more modular, testable, and interchangeable, allowing us to swap dependencies without breaking the system. Okay, so you can see here that we have some code which is problematic and violates this principle. The reason it violates this principle is I have this email notifier and I directly couple it or use it inside of this user service. So let's see what happens now if I change over to my solution. So now let's just look at the user service and notice the user service now relies on an abstraction which is a notifier class or a notifier interface. Again in Python we don't have interfaces, we just have abstract classes. We just rely on this abstraction which is a notifier. And as long as what's passed inside of here implements the send method, then this code works completely fine. And we can use it with any type of notification",unknown
noqQ1dCtT6M,"You might be making one of these mistakes right now and it's silently killing your chances. Now, I've reviewed hundreds of portfolios and these four issues show up almost every single time. Now, if you can fix them, your portfolio goes from meh to hire this dev. So, let's start by breaking down what a portfolio is. Now, when I say portfolio, I'm talking about your public proof of skill. Now, usually that's a personal website with your best projects, but it could also be a GitHub profile, or even just a short list of projects that you include on your resume. Now, the purpose is simple. Make it obvious in under 20 seconds who you are, what you can do, and why someone should talk to you. Now, recruiters and hiring managers are busy, and they're not going to dig for answers. They're probably not even going to click into your projects. They're simply going to skim, and if they don't see something compelling immediately, then they're going to move on. That's just how it works. Now, that's also why it's always better to have between one to three really good portfolio projects rather than having 10 half-assed ones. Good projects are ones that people will pay attention to. They're not going to read through a list of 10, 20, or 30 projects. They just want to look at the best ones. So, throughout the rest of the video, I'm going to go over the four mistakes that most developers make in their portfolio. So, stick around. But first, before we get into that content, I want to take a moment to thank today's sponsor, boot.dev. Now, this is an online learning platform designed specifically for back-end development, and it approaches learning in a way that's far more interactive than the usual video-based courses. Rather than having you sit through hours of lectures, boot.dev puts you straight into hands-on coding. You'll work directly in your browser building real projects while learning back-end fundamentals like APIs, databases, and serverside logic using Python and Go. Now, what makes it stand out is the way it borrows from game design. You'll progress through levels, unlock new content, and keep your momentum up as you go. Now, the platform is filled with exercises and practical challenges, so you'll end up writing a lot of code, which is exactly how you improve as a developer. Now, all of the core content is free to access, and if you decide to commit to the annual plan, you can use the code tech with Tim to get 25% off your first year. I've been through the content myself, and it's honestly surprisingly addictive. So, make sure you check it out. So, with that said, let's get into the first mistake. Now, that is that there is no wow factor. The first thing that a recruiter is going to notice is your list of projects. And if they're generic, if it's another to-do app, a weather app, or an algorithm visualizer, then they're gone before they even scroll. Now, you need at least one project on your resume that makes them stop and say, ""Oh, that's actually interesting."" This doesn't mean you need to reinvent the wheel or invent something groundbreaking. You can take a common project and just give it a twist. For example, instead of building a plain CRUD to-do app, you can build an AI powered meal planner that generates shopping lists or recipes. Or instead of a stock price tracker, make one that uses sentiment analysis from news articles. The functionality might be similar to something that you'd build in a tutorial, but the presentation and the context is what's going to make this stand out. So, you need to force a pattern interrupt in the reader's brain. So that's where they're actually going to stop to read everything you wrote because it's not the same thing that they've seen millions of times again. Now, quick tip here. Any project that has real users always gets attention. So if possible, aim to get other people using your project. Overall, you need to write and display your project in a way such that when someone looks at it, they go, ""Oh, that's different. That's unique. I actually want to look more into this."" If it's the same thing that they've seen hundreds of times before, they really just don't care and it doesn't do anything for you. Now, speaking of which, that leads me to mistake number two. Now, the second mistake, and this is one that pretty much all of you are probably making, is having ambiguous descriptions or horrible project names. Now, look, no one cares about your project if they can't figure out what it is within seconds. If your project is called my final year project or cool app or to-do app or AI app, you've already lost them, right? Your project name should clearly explain what it is and why it matters. If you say React dashboard, that tells me nothing. But if you say e-commerce sales dashboard for real-time order tracking, that gives me a reason to actually click or to read further and see what it's about. Now, the same goes for the descriptions of your project. Keep them to one or two sentences that explain what it does, what text stack you used, and what the overall outcome was. For example, you could say a Flask and Postgress SQL web app that tracks gym workouts and suggests new exercises using OpenAI's API. Now, that's enough to make someone curious without overwhelming them with data. So, what you need to do is cut out the random names and always use a few word descriptive text. A project that I used to have on my resume, for example, was AI plays Flappy Bird with an evolutionary algorithm. Now, it's not what I would name the app if I was going to put it on the app store, but it's something that's easy for people to understand and allows recruiters to know what the project is actually about. So in short here, don't use random ambiguous names. And make sure your description is short and to the point while displaying what you actually built, the tech stack you used, and why it was impressive. So now we move on to mistake number three, which is having no role targeting. Now, your portfolio should tell a story about the type of developer that you are. If you're applying for back-end roles, then the first thing in your portfolio shouldn't be a random front-end clone that you made 2 years ago. Now, I see this all the time, right? portfolios with an ML model, a WordPress blog, a Python game, a React mobile app, all in the same list. Now, that doesn't make you look versatile. It just makes you look unfocused. Instead, you need to pick two or three projects that align directly with the type of job that you want. If it's a back-end job, you need to show an API project, a database heavy web app, and something that demonstrates maybe performance optimization or some kind of deployment with Docker and Kubernetes. Now, this way, if a recruiter is looking at your work, they can instantly connect the dots and say, ""Okay, this person is a back-end developer."" In fact, this is the biggest mistake almost all of the developers I work with make. They have no focus or specialty. When I open up their portfolio or resume, I should know immediately what type of developer they are, but most of the times I have no clue. So, the moral of the story here is that you don't just want to be a general software engineer. You want to specialize in something like backend, front end, mobile apps, etc. And this is something I focus on a lot in my Dev Launch program and we've seen a lot of success tailoring people to specific roles. So when you're creating your portfolio or at least picking the projects you want to put on your resume, make sure you pick the ones that speak to the type of role that you're applying to. Again, applying to front end, have a few front-end projects. Applying to backend, have a few back-end projects. Don't throw random projects on your resume that aren't related to your role type because that's just not going to help you out. And like I said, it doesn't make you seem versatile. it just makes it seem like you didn't have another good back-end project to put there. Now, we move on to mistake number four, which is that your portfolio just looks amateur. Now, this could be in the way that you're naming projects, the way that you're describing them, or even just how the project looks. For example, if your project has some type of presentation, so it's a website or a full stack application. If I open it up, it better look professional. It better look like a real software developer built this and it wasn't built in 2009. Now look, I know a lot of us hate designing. A lot of us want to focus on the back end or clean code or building something scalable. But the truth is that everyone is going to judge what you built just by looking at it for a few seconds. So if you are going to have some kind of front end or some kind of website, it needs to look really really good. Now fortunately today we have AI which can design and make things look really impressive extremely fast. So even if you're not a front-end engineer, there's really no excuse for having a poorlooking portfolio or a poorlooking website. So, make sure you're using complimentary colors. For example, you can literally go to Adobe's website and generate a color palette that has colors that work together. Make sure you're using a modern font. Make sure spacing is consistent. Make sure it's mobile responsive. All of these things are just best practices that you need to have in your portfolio projects because again, god forbid anyone does actually look at it, it cannot look amateur. I cannot tell you the number of times that someone tells me they have a portfolio website and then I click it and it just looks like it was made out of a random tutorial, right? It looks like you just learned HTML and CSS. Don't put that there. It's going to do more damage than it is good. It needs to look really, really nice. After all, you had infinite time to build this portfolio project. So, there's no excuse for it looking amateur. I would just say overall any project you have, ask yourself, is this what a professional software engineer would build and would deliver on a job. If it's not, then you need to do a better job making it seem more professional. Okay, so those are the four mistakes and I guarantee that you're making at least one of them. These are minor. These are not rocket science. I'm sure a lot of you already know about these mistakes, but you need to actually put the effort in to fix them. And just to quickly recap here, number one, you need to have some wow factor. Number two, you need to give this a good name that is descriptive and actually makes sense. Number three, you need to target a specific role. And number four, you need to make sure this doesn't look amateur. If you implement these few mistakes, your portfolio is going to look significantly better. And it may actually be the reason you end up getting called in for an interview. Anyways, that's all I had for this video. If you guys want more information on this topic, then definitely let me know in the comments down below. I look forward to seeing you in another video. [Music]",unknown
UFnFJukpdWk,"Today I'm going to explain to you how I mastered data structures and algorithms quickly without hating my life. Moving on, step number two. Now, I learned the theory quickly. A lot of people spend months learning the theory of data structures and algorithms. That's not necessary. There's three main things that you need to learn or kind of three main topics. I'll quickly go over them, but the point is don't spend too much time here. You need to understand the algorithms and data structures. Know the time complexity of the operations, but that's about it. You don't need to implement these from scratch. Sure, if you have extra time, it's a good idea, but it's not necessary. So, what I did is I started by learning bigo notation and time complexity analysis. This is the most fundamental thing. You need to understand this. Then I started looking at data structures. So, I won't go through an entire exhaustive list because there's a lot of resources online that cover those better than this video can. But things like stack, Q, linked list, trees, etc. If you're going for more senior positions, maybe you need to know those. But in my case, for internship or kind of entry- level roles, you're just probably not going to be quizzed on",unknown
NvxP_oNOVAE,"Today I'm going to explain to you how I master data structures and algorithms quickly without hating my life. Now I say that because a lot of people that get into this topic do it completely wrong. It takes up a massive amount of time and they just hate doing it. Okay, so let's get right into it. First things first, do yourself a favor and pick an easy language to do this in. Now, most people are going to be learning this either because they're in a computer science degree or because they're preparing for technical coding interviews. Now, I'm mostly speaking to that latter group there, people that are doing this because eventually they're going to be quizzed on this type of stuff and have to answer these leak code style problems. So, I highly recommend use a language like Python when you're learning this and when you're going to be practicing these DSA style problems. The reason for that is it's a much more elegant language. It's way easier to write code in it and it's much easier to",unknown
1bUBoS3QSic,"Please don't hate me, but if you want to land a job, you should probably stop learning Python. When everyone knows Python, it's no longer valuable. Now, sure, it's good to know, but you're not going to stand out as a pure Python developer unless you're a complete expert. So, please, if all you're learning is Python, go learn another language. Go. Java, C++, heck, even PHP. I don't care what you learn, but you want to stand out and make sure you're not just like all of the other thousands of applicants that only know Python.",unknown
vM_3wzfaZiE,"Here's the real reason most software engineers want to work in the United States. We all know software engineers get paid a ton of money, especially if they're in the US. But I bet you didn't know how drastic the difference actually is. I was offered an internship at Microsoft when I was 19 years old, where I was getting paid about $8,000 per month. Now, at that time, I was living in Canada, and the next year they offered me a return offer, this time out of the Canadian office. out of the Canadian office, my salary was dropped to $3,700 per month, less than half what they were offering me before. So, if you work even just across the border in a country that costs a very similar amount to the United States, you get paid nearly half what you get paid in the US. Absolutely crazy. And I was shocked and said no to that offer.",unknown
qketTJTlL_4,"I can almost guarantee you that at some point in your life you wrote code that looks like this. So here's the first way that you can fix this code. Now what I've done is I've created a dictionary. So whenever you've got kind of values mapped to some other values like a one is Monday, a two is Tuesday, what you can do is you can kind of map them using a dictionary. So notice what I've done here is I've mapped one to Monday, two to Tuesday, three to Wednesday, and I've written this dictionary that contains all of my keys associated with their values. And then I can simply get out of the dictionary the key and it will give me the value. So if I say daysw week get and then the day number, if this number exists as one of the keys inside of the dictionary, it's going to return me the associated value. So if I put a one here, it's going to give me Monday. If I put a six here, it's going to give me a Saturday. And if this number for some reason doesn't exist as one of the keys in the dictionary, we'll simply return invalid day",unknown
cUC-hyjpNxk,"In this video, we're building an advanced AI agent in Python using Langraph. Now, this isn't going to be a basic chatbot. This is a multi-step deep research agent that will pull live data from sources like Google, Bing, and Reddit. Now, this tutorial is not for beginners. I'm going to be covering advanced Python concepts, complex architecture, and best practices for building agents that go far beyond just a single prompt response. Now, for this video, like I said, we're using Langraph, Python, and I will also be using bright data to access real time web data. Either way, even if you don't want to build a web-based agent, you can still learn a lot from this video because I'm going to build really a pretty complex agent and show you how to structure that in Python. So, by the end, you're going to have a fully functioning project and the skills to build powerful production AI systems. So, with that said, let's dive in and let me show you a quick demo of the project. So I'm in PyCharm here and I'm just going to give you a quick demo of what the finished project will look like. Keep in mind that you can adjust this a ton and this is really meant to give you a solid base. Anyways, let's have a look at what we can do. So as you can read here, this is a multissource research assistant, but you can use it for a lot of different tasks. It says ask me anything. So I said, should I move to Dubai from Canada? And then what we do is we start in parallel searching both Google, Bing, and Reddit. Okay, so we can actually do this at scale and search for like thousands of different results. So you can see we searched Bing for this, we searched Google for this, we searched Reddit for this, and then what we start doing is waiting for the results. So essentially what Bright Data is going to be doing is it's going to be pulling all of these results into a large snapshot for us. See, we get all the results here. We download it and then we're able to actually, for example, parse through all of the Reddit posts. In this case, I just did 75 of them. We analyze the Reddit post. We find the titles that actually make sense for our search query. We then go, we find those Reddit uh posts, sorry. We download all of the comments from those two Reddit posts. You can see right here it says it downloaded 26 Reddit comments. We then take all of that data and we analyze it. So we analyze the Google results, the Bing results, and the Reddit discussions. And we synthesize all of that data into one final answer. And then it gives us the response right here. So it says, you know, taxfree income, cost of living, lifestyle, and environment. And if we scroll over here, it tells us where it actually got this data from. So from Google and old assets. Here it found this from Reddit r/duby and it gives us kind of all of these sources and quotes where it found this information from. Same thing I asked it should I buy AMD or Nvidia stock? Same process. It goes through finds all of this relevant web data finds all of these different posts and then as we scroll down you can see here in this case there was a lot more comments that it analyzed and then it gave us this comprehensive response breaking down whether we should invest in Nvidia or AMD. And ultimately it gives us a conclusion here and says Nvidia appears to be a more straightforward choice for those prioritizing immediate and robust growth in AI who favor it strong financial and marketing position. Okay, so there you go. And then I just stopped the agent here which is why we got that kind of interrupt message. So overall this is a very powerful agent and the interesting thing about this is the way that we're going to write this is it's very scalable. So I could run this agent thousands of times in parallel. I could scrape thousands of different posts and nothing really changes here. You'll see how we do that later on. But because of the technology that we're using and the way that we write this, we really can run this actually in production in a scalable format and it's going to be pretty fast to actually execute. It doesn't take a very long time due to the services that we're using. Anyways, with that said, I want to quickly talk a little bit more about search because that's a really important part of what we're doing here. And then we'll get back onto the computer and start coding all of this out. So, now that we've looked at a quick demo, I want to briefly touch the current problems that exist with search because that's what this agent is going to do. it's going to be searching the web. Now, most AI agent systems today share a pretty major limitation. They can't access the full range of data that's actually relevant to the problem. So, relying on a basic search API, or just a single plug-in means that you're usually only seeing a fraction of what's actually available on the public web. So, important sources like live social media sentiment, real time crawling, or historical trend data often go untapped. Now without them the results are incomplete and the decisions these agents make can be based on outdated information and opportunities are going to be easily missed. Now on top of that many setups require stitching together multiple APIs that don't work smoothly together and they leave the agent with a narrow or fragmented view of the entire world kind of based on the web. Now with that said that's why for this video I mentioned we're going to be using Bright Data. Now Bright Data has been a long-term sponsor of this channel. I've worked with them on many videos now and what they have here is a web discovery API that provides a much easier way to access a wide range of public data. So rather than just basic search results, it can pull all kinds of information like live SER data from engines like Google, Bing, and other search engines. Realtime sentiment from platforms like Twitter, Reddit, and Tik Tok. In this video, we're going to be scraping Reddit, for example. They have historical web data that goes back years. and then insights from answer engine such as perplexity, Gemini, chat, GBT, etc. Now, that's because Bright Data handles the crawling, parsing, and does this reliably in one unified API so that we can focus on building the agent rather than trying to set up these really complex web scrapers. Again, I've used sprite data many, many times in the past. Essentially, just a smarter, easier way to be able to scrape the web. And we're going to integrate that tool into our agent here in this multi-step kind of orchestrated flow so that our agent essentially grabs all of this real web data based on what we're asking for, analyzes it using models like chat GBT, and then gives us a really competent response that's kind of followed the strict protocol that we've set up. So with that said, let's get onto the computer here. Let me start explaining the architecture of our agent. and we're going to start kind of scaffolding this out, building it, and then going step by step because I won't lie to you, there is a lot of code here. And also, I'll quickly mention that all of the code for this video will be available from the link in the description. Anyways, let's dive in. So, we're back on the computer now and we're going to start coding this out. Now, first I want to quickly explain the Langraph architecture that we're going to use for this agent just so you can understand what it is that we're about to build. And with that said, if you're unfamiliar with Langraph, I do suggest you have some background with that before following along in this video. Otherwise, it might be a little bit confusing. So, I'm going to put a video on screen right now that explains Langraph in depth that you can follow along with to get some context before going into more of a complex project. Okay. So, anyways, we're going to be using Langraph and essentially what's going to happen is the following. The user is going to ask some kind of question and we're going to simultaneously in parallel go and search Google, Bing, and Reddit for information based on their question. Now, in theory, we could search a lot more sources as well, but I'm just keeping it a little bit slim for this video, so it doesn't take us 25 hours to code this out. Okay. Now, after that, what we're going to do is we're going to wait to analyze the Reddit posts. The reason for this is that the Google results and the Bing results are extremely fast because Bright Data already has them indexed. So, we get them in like a few seconds. Whereas the Reddit post can take a little bit longer because we're doing manual web scraping. Well, Bright Data is doing that for us and pulling all of the relevant posts. So, in this case, we have to wait for the Reddit post. Takes a second. And then once we get the Reddit post, what we're going to do is retrieve all of the posts that are actually related to the prompt that we passed in. So, we're going to search Reddit. It's going to return a bunch of different results for us. Then we're actually going to analyze those Reddit posts. We're going to pull out the ones that make sense. And then from those posts, we're going to retrieve all of the comments on those particular posts. Hopefully that makes sense. But that's kind of these two steps here. Now, after that happens, we're then going to analyze all of the results that we got. So, we're going to analyze the Google results, the Bing results, and the Reddit results. This is so that we cut down the amount of information that we have before we synthesize that all together into one larger prompt. So we have these three kind of smaller prompts that are focused on pulling information that we need from each source. Then we take all of that and we pass that to kind of a synthesizer which is then going to take all three results from here and synthesize that into one final answer which we'll end up getting here. Okay. So this is kind of the architecture or the graph that we're going to build. And of course, when I say lang graph, that's referencing this graph, right? Like we're building this graph essentially where we're flowing data through this and eventually getting this final answer. Okay, so that's what we're going to build. So what I'm going to do now is go over to PyCharm and start setting this up. Now, for this video, you can use any IDE that you want, but I do typically recommend PyCharm for larger Python projects, especially when you're working with AI or modules like Langraph, Langchain, etc. And I do actually have a long-term partnership with PyCharm and you can check them out and start using it for free from the link in the description. I always recommend at least try it. If you don't like it, you can switch to something else. But personally for me, it is my favorite for larger Python projects and it is literally designed for Python, hence the name PyCharm. Anyways, let's get started here. So, what I've done is I've opened up a new folder and I've just called this AI search agent. You can call this anything you want. And then from this folder, we're going to initialize a new UV project and create our virtual environment in Python. So in order to do that, I'm going to type UV init and then dot in my terminal. This is going to initialize a new UV project. And from here, we're going to install the dependencies that we need. So I'm going to type uv and I'm going to add lang chain. Okay. and then lang graph and then we're going to install lang chain and then dash open ai because we need to use gpt here and then we're going to install python env. Okay, these are the four dependencies that we're going to need to install. So let's go ahead and press enter here and they all get installed in our environment. Now feel free to use pip or any other virtual environment that you want. But if you want to use UV and you're not familiar with it, I'll leave a video on screen that teaches you how to use UV because it's kind of the standard now. It's very fast for managing dependencies and environments in Python. Okay, so now that we've got UV installed, we're going to start setting up our project. So, there is quite a bit of setup and there's going to be a lot of code here. If at any point you're getting lost or you just want to copy something that I'm writing, you can do that by clicking the link in the description. There'll be a GitHub repository that contains all of the code for this project. So, what I'm going to do now is I'm going to make a new file inside of this folder called env. Now, this is going to store some environment variables that we need. I'm just going to ignore this for right now. Specifically, our OpenAI API key and our bright data API key, which we're going to get later on or in a few minutes. So, we'll just start by writing the variables that we're going to need. So, first is going to be bright data API_key. Okay, we'll fill that in later. And then next is going to be the open AI API_key. And again, let's spell open correctly. We can get that later. Okay, so we have our environment variables defined. Now, we're going to go into our main.py. py file. Just create a new one if you don't have one here and we'll start writing some code. Now, PyCharm is also prompting me just to configure my interpreter. So, let me just select the correct one and then I'll be right back. All right, so I've configured the correct interpreter and now what I'm going to do is start scaffolding my project. Now, when I say scaffolding, what I mean is I'm going to write all of the functions and logic that we'll eventually implement. But for now, I'm going to just kind of connect it together so that we understand the architecture and the flow that we're going to follow along with. And then once we have that, it's a little bit easier to go write each individual function. This is typically how I plan larger projects. So I'm going to kind of walk you through my thought process in this video and you'll see how we plan it out. So first we're going to say from So let's do this correctly. Env import load.env. This is going to allow us to load in the environment variables that we've defined in this. Envile. I'm going to say from typing and I'm going to import annotated. Okay. I'm gonna say from lang graph and then this is going to be dotg graph. I'm going to import the state graph and the start and the end nodes. Now again if you're not super familiar with lang graph essentially this allows us to build a graph which is a bunch of different nodes that are connected to each other and to flow some state or some data through that graph where each kind of node in the graph can modify or update that data. So we're going to have some state which is going to store all of the information that our agent needs to have access to. And as we run through these different stages or nodes in our graph, we'll be populating that state where then at the end of our graph, we have this final answer which we can present to the user. So it's kind of a really unique way to build AI agents in a bit more of a kind of predictable flow. Rather than just giving a set of tools to a model and letting it go crazy, we actually kind of walk through this manual process that's a lot more consistent where we update this state kind of stage by stage. Okay, so next we're going to say from lang graph and this is going to beg graph. Okay, dot message we're going to import add messages. We're then going to say from langchain dot and this is going to be chat_models. We're going to import the init chat model which is a really quick way to initialize an LLM in langraph. We're then going to say from typing extensions and we're going to import the typed dictionary. Okay, these are just some typings that we need in Python. And then we're going to say from pi dantic. Okay, and we're going to import the base model and the field. And then we're going to say from typing import list. And actually I realized we can just put this up here because we need list and annotated and they come from the same package. Okay. So that's most of our imports. Later we'll import a few other things but for now we can start with this. And then we're going to call this load.env function. When you call.load env file and it loads these variables for us that we can start using them inside of our Python code. Okay. Now, next step, we're going to say llm is equal to init chat model. And for the chat model, we're going to put the name of the LLM we want to init, which in my case is just going to be GPT40. Now, you can put pretty much anything that you want here. You just need to make sure that if you put a different model from another provider that you pass the correct API key in this file. So, automatically when we try to load GPT40, Langraph is going to look for the presence of this OpenAI API key variable and then use that as our API key. Okay, so we just put GPT40. You can put a newer model, whatever you want. Just make sure you have the correct API key. Okay, so now that we've done that, what I want to start with is actually writing out the state that we're going to pass through our graph. When we have the state, we'll kind of understand the data that we need to come up with and find. And then I can start creating this graph and making the connections between these nodes. And then we can start actually kind of populating the graph by writing the different implementations. So for now we're going to say class state and this is going to inherit from the typed dictionary. Okay. Inside of here we're going to start by having a list of messages. Now these messages are essentially the messages that our user is sending into this graph that we'll then process and start getting the information for coming up with an answer for. So we're going to say messages is annotated and then this is going to be list and add underscore messages. When we do this, we mean that okay, messages is type list. And when we want to add a new message, we call this add messages function, which will uh essentially modify the messages for us. Okay. Next, we're going to have the user question. And this is going to be string or none. Okay. Then we're going to have the Google results. And this is going to be string or none. And you'll notice that all of these are going to be or none because at some point in time, we may not have these results. and then later we'll populate it. So then next we're going to have the Bing results. This is going to be string or none. Then we're going to have the Reddit results. Again, string or none. Okay. Then we're going to have the selected_reddit URLs. This is going to be list of type string or none. Now, the reason why I have selected Reddit URLs is because we're going to get a bunch of results from Reddit. And then we're going to pass these results to an LLM where it's going to select which of these URLs we actually want to process further just to avoid us looking at data that we don't need. Then we're going to have Reddit_post data which is going to be the data for those selected URLs. This is going to be list or none. We are then going to have the Google_analysis. This is going to be string or none. This is the kind of LLM analysis. After we get our results, we're going to have the Bing analysis which is string or none. And then the Reddit analysis which is string or none. And then finally the final answer which again is string or none. Okay. So this is essentially our state. This is what we're going to be flowing through the graph. And we'll start populating these one by one as we kind of go through all of the nodes that we have in our lang graph. All right. All right. Now, that's great. What we need to do next is we need to start defining the nodes that we have in our graph. So, if we look here, this is what we need, right? We need to do Google search, Bing search, Reddit search, analyze the Reddit post. All of these are essentially just functions that need to execute in some order. So, what we're going to do now is we're going to write all of these empty functions without the implementation. And then later, we're going to implement all of these functions. This way we can build this flow and then later we can go and we can actually add all of the different pieces and kind of test it step by step. So what I'm going to do is I'm going to start defining a bunch of functions. So the first function that I'm going to have is going to be called Google search. So I'm going to say define Google search and then for all of these functions what they take as a parameter is simply the state. Okay, so we say state and then that's going to be equal to this right here. they take in this state and then what they're going to do is return something that modifies the state. So for right now, we're just going to say return. We don't need to return anything right now. And we're just going to keep making a bunch of functions with all the different operations that we need to perform. So after we have Google search, then we have the Bing search. Okay, that's the next function or the next note. Then we're going to have the Reddit search. And again, we're just going to populate all of these and then finish them later. Okay, then we're going to have analyze Reddit posts. So let's go analyze Reddit posts. Okay. Next function is going to be retrieve Reddit posts. So let's change this. Retrieve Reddit posts. Okay. And I'm just going to add some spaces between here because you can see PyCharm is kind of linting this and telling us that we should have two spaces between our functions. So that's fine. After this, we're going to have analyze Google results. So analyze Google results. We need to analyze the Bing results as well. So in fact, let's just copy this function and paste this down here. Analyze Bing results. Okay. Then we need one more for analyzing the Reddit results. Okay. So Reddit results are a little bit different than the Reddit posts. So we're going to have Reddit results and then we're going to synthesize this. So, we're going to say synthesize_analysis like that. And then this is going to actually take all of the results that we had here and synthesize it into one larger result. Okay. So, we have a bunch of functions. We're almost done with functions. What we're going to do now is we are actually going to create the graph where we connect these nodes together. So, again in Lang graph essentially we have nodes. Nodes are really just operations or functions. So we've defined now what all of our operations are going to be. What we need to do though is we need to connect them to one to one each other. Sorry. So we know that we start for example with Google search then we do the Bing search then we go to Reddit search then we analyze this and we need to just create these connections or create the graph. So what we're going to do is we're going to say our graph builder is equal to and this is going to be state graph. And for the state graph we simply pass our state. Okay. And now that we have that, what we're going to do is we're going to add all of these nodes into our graph. Now, the way that you do that is the following. You say graph_builder add node. And then what we're going to do is give the node a name. So we're going to say something like Google search. And then this is going to be pointing to the Google search function. But make sure you don't call the function. All right. Now, this is a little bit tedious, but essentially you just need to give a name to every function or every node that we have. So you see like the next autocomplete is we're going to add the Bing search and that's going to be the Bing search function. We have the Reddit search that's going to be the Reddit search function. And I'm just going to keep going here and using my autocomplete. So we're going to have analyze Reddit post. That's going to be to analyze Reddit post function. Analyze Google results. And you get the idea. And I'm just going to go through here and analyze results results is definitely not the name of a function, is it? Um okay. If that is then I definitely spelled something wrong. So we don't want analyze results result. We want analyze Reddit results. Okay, so let's fix that. And let's go here to analyze Reddit results and analyze Reddit results. Okay, good job. We caught that. And then we have the last one, which is the synthesis. So, let's add that here. Okay, it looks like we're actually just missing one here, which is retrieving the Reddit post. So, let me add this. We're going to say graph builder.add add node and this is going to be be retrieve okay Reddit post like that and then we're going to fix this to be retrieved_reddit post. So we analyze the Reddit post we retrieve the Reddit post and then we have the rest of them here which I think is all good. Okay. And ignore the yellow highlight. We're going to fix that later on. It's just because we're returning none from these functions. All right. All right. So at this point, what we've done now is we've created the nodes. So they exist, but they're not yet connected. So now that we've created them, we need to connect them to one to one each other. Sorry. So the way that we do this is we can say graph_builder. And we can say add edge like this. And an edge is a connection between the nodes. And we're going to connect the start to the first node, which is going to be our Google search. So what this says is okay when we start the graph the first thing that we're going to do is we're going to go to Google search. Now what we're going to do is we're going to connect the start to multiple of these. So we're going to connect to Google search as well as Bing search as well as the Reddit search. So this way what will happen is at the exact same time we'll execute all three of these operations. So we'll run them in parallel. So as soon as we start or as soon as the user gives us some message or some request, we searched on Google, we searched on Bing and we searched on Reddit at the same time. Okay, cool. So next thing we're going to do here is we're going to connect the next steps. So after Google search, what do we do? After Bing search, what do we do? You get the idea. Okay, so in order to do this, we're going to say the graph builder added. And the first edge that we're going to add might seem a little bit weird, but from Google search, we're actually going to connect the analyze Reddit posts. Okay, let me make this a little bit smaller so you guys can see this. Now, the reason we're doing this is because if we follow our architecture, right, after we do all of the searches, we need to wait a second to get all of the Reddit results before we can move any further. So, all of these connect to the analyze Reddit post, which is what we're doing right now. Then, we'll retrieve the Reddit post. then we'll go and do all of this analysis. Now, there's actually some ways that we can make this a little bit more efficient, but for right now, this is just a simpler architecture that I want to follow. Um, you probably know what I mean if you're thinking like, okay, how can I make this a bit more efficient? But for right now, I don't want to make it too complex. So, we're just going to go with this. Okay, so after the Google search, we go here. After the Bing search, we're going to go here as well. So, we kind of wait at this stage. And then, of course, after the Reddit search, we need to go here, too. Okay, so we've now made this next connection. So we have start to Google search, start to Bing search, start to Reddit search, and then from each of these we wait at the analyze Reddit posts. Okay, now after we analyze the Reddit post, what we need to do, so let's put one more in here, is we need to retrieve the Reddit post. So we're going to go analyze Reddit post to retrieve Reddit post and add that edge between those two. All right. Now, the next thing that we're going to do is we're going to say graphbuilder.add edge. Let's get rid of all of this. And we're going to start now from the retrieve Reddit post. And after the retrieve Reddit post, what we're going to do is we're going to start analyzing all of our results. So we're going to say analyze. And then the first thing that we're going to do is the Google results. So underscore Google results like that. Let's spell analyze correctly. Okay. Now let's copy this and go down here. Now, after retrieve Reddit post, we are also going to go and analyze the Bing results. Okay? And then we're going to go one more down here. After we retrieve the Reddit post, we're also going to analyze the Reddit results. All right? So, hopefully this is making sense. But again, if we go back to the architecture, we wait for the Reddit post, we retrieve them. Then after we retrieve them, we go and we analyze the Google results, the Bing results, and the Reddit results. That's what I've just written, right? We go Google, Bing, Red. So, analyze those three at once. Okay. Now, after those three, what we need to do is we need to synthesize our analysis. So, we're going to do this again. We're going to add another edge. Now, we're going to start from analyze Google results. And the end key here is going to be the synthesize analysis. Then, we're going to copy this. And I'm just going to copy it twice because we're going to need it here. After we analyze the Bing results, we're also going to go there. And after we analyze the Reddit results, we're going to go here as well. Okay, so those three then connect to this next node where we're synthesizing everything. And then lastly, we add one more. So we say graph builder added edge and we're going to say from the synthesize analysis, we're going to go to the end. Okay, so this is how you set it up. You need to always have a start key, which we do right here, and an end key or an end node. And then this creates this graph that you just saw in this diagram. Okay. Now, after we create the graph, what we can do is compile it. So, we're going to say graph is equal to graph_builder and notbuild, but compile. This is going to actually execute the graph for us. So, we're able to run it. And then what we can do is we can essentially pass a message to this graph. it will run through all of the different nodes. The state will get updated and then we can print out that state. So what I'm going to do is I'm going to write the function that would allow us to execute this graph. And then of course before we can do that, we need to start writing all of these different functions. So we're going to make a function here. I'm going to call this run chatbot. Okay, what this is going to do is start executing our uh what you call agent so that we can actually run through this graph. So, what we're going to do is we're going to do a print statement and we're just going to say a multi- source research agent like that. I'm going to print a line and I'm going to say, you know, type exit to quit. Okay. And then back slashn. All right, that's good. And then what I'm going to do is have a while loop. So, I'm going to say while true. And we're going to keep asking the user to give us some input. So we're going to say user input is equal to and then we're going to say input I'm going to say ask me anything colon like that we're going to say if the user input. equal to exit then print by and we can break the loop. Okay. Otherwise what we're going to do is we're going to say state is equal to and we need to initialize a kind of starting state. So in order to do that, we could say state is equal to the following and we can say messages and then for the message we just need to put the message that we want the uh bot to reply to. So we're going to say roll is user and we're going to say content is the user input. Okay, we're then going to say that the user question is the user input. We're going to say the Google So we need to actually have this in a string. The Google results is just equal to none. And then we're going to do the same for all the rest. So the Bing results is equal to none. The Reddit results is none. The Google analysis is none. The Bing analysis is none. The Reddit analysis is none. Final answer is none. And then of course there's a few other ones that we missed. So let's go here. After Google results, Bing results, Reddit results. We also have the selected underscore Reddit URLs. Okay, this is going to be none. We then have the Reddit post data. So let's do this. Reddit_post data and that is none as well. Okay. And I think that's all of the state that we need. So again, kind of at the beginning, we need to initialize the state that we're going to be passing through the graph. So that's what we've just done. We've plugged in the user input. So the question that they've asked us and then what we're able to do is start running the graph. So what we can do here is we can do a print statement and we can say back slashn and then something like starting parallel okay and let's go here research process dot dot dot then we can do another print and we can say something like launching Google this is just for logging by the way but I think it looks nice bing and reddit searches dot dot dot okay I'll do a back slashn here as well to kind of separate this out. And then I'm just going to print a dash* 80 uh just so that we get kind of some separation here between what is appearing. Okay, so actually I just missed something. So up here what I'm going to do is I'm going to say the final state is equal to graph.invoke. I'm going to invoke the graph with my state. And then what I'm going to do down here is I'm going to say if the final state and then I'm going to say get and this is going to be the final answer. So if that does exist then I'm going to print out the answer. So I'm going to say print. Okay. I'm going to do an fstring. I'm going to say back slashn. I'm going to say final answer like that. I'm going to say back slashn again. And then I'm going to put the final state. Okay. Get final answer like that. and then we'll put a back slashn. Okay, so essentially what I'm saying is all right, we're going to invoke the graph. This is how you invoke it. We pass our initial state. Again, don't worry too much about that. We'll fix that later on. We say if the final state does contain a final answer, then we'll print out the final answer and it will just print kind of a separation here so that if we run this again, we know, you know, which run was which. Then lastly, we need to execute this function. So we can say if name is equal to main, then we can run the chatbot. And then that actually would be a finished program assuming that all of the nodes were completed which of course they're not and we're going to need to write. So let me quickly just kind of summarize what we've done here. I just want to zoom out a little bit so you guys can read this. Essentially we started with all of our imports. We loaded the environment variable file. We initialized our LLM which we still need the API key for which we're going to get in one second. We created our initial state. Okay. And then what we did is we kind of stubbed all of these different operations or nodes that we're going to have in our graph. So Google search, Bing search, Reddit search, analyze Reddit post, retrieve the Reddit post, analyze Google results, analyze Bing results, analyze Reddit results, synthesize the analysis, and then we created the graph. So we added all of the nodes where we connected functions to the node name. That's essentially what we did here. We then added all of the edges. So we started with these three running in parallel. We then kind of connected them to this analyze Reddit post node. We get the Reddit post here after we analyze them. And then we go through the rest of the flow until we eventually synthesize all of the results. We then have this uh while loop that just allows user to type something in and essentially run it through our graph. And that is the lang graph component kind of done. What we need to do now is we need to start updating the state as we go through these various nodes. So let's get into that. And that's going to allow us of course to start searching the web using the SER API, all of that kind of stuff that I'm going to show you. So for now, because I want to be able to test this step by step, I'm going to start filling in some of the outputs that we're going to have from these functions so that even if they're not fully complete, we'll be able to execute the graph and kind of test the Google search first, then the Bing search and see what results we're getting. So from our Google search function, I'm going to say the user question is equal to state.get and this is going to be the user question or an empty string. Okay, so because I have state in all of these functions, I can pull out the state. Then what I'm going to do is I'm going to have a print and I'm going to say f string. So, and this is going to be searching Google for and then we'll do a colon. So, searching Google for the user question. Okay, I'm then going to say the Google results are equal to an empty list and later we'll actually get the uh Google results, but for now we'll just make it an empty list. And then I'm going to return the following which is Google results is equal to the Google results. Now whenever you return something from these functions it needs to match what you have in the state. So in this case we have Google results matching with our Google results. So this Google results will get updated to be equal to whatever this is. And then in the next function we have access to these updated Google results. That's how the state kind of flows through here. you return a partial update to the state from one of these nodes and then it gets updated here where it's continually passed to all of the next nodes in the sequence. Hopefully that makes sense. But that's kind of the idea. Now for the Reddit search or the sorry the Bing search, it's effectively the same thing. So I'm just going to paste this here and rather than searching Google, I'm going to search Reddit or not Reddit, Bing. I keep messing these up. And then rather than the Google results, this is just going to be the Bing results. So change this change this and change this here. Okay. And then for the Reddit search, again, it's pretty much going to be the same thing except just named Reddit. So, we're going to paste this here. We're going to say searching Reddit. And then just update all these variables to say Reddit. Okay. Reddit and Reddit like that. Okay. Now, we're going to go to the analyze uh Reddit posts. From here, essentially what we're going to do right now is just return some fake data. So we're going to say the selected_reddit urls. And for now, this is just going to be equal to an empty list. Later, we can populate that, but for now, that's all we need. Now, same thing when we talk about the Reddit post data, we're just going to say return Reddit post data is equal to an empty list. And then for the analysis, same thing. We're going to return. Okay. And this is going to be the Google analysis. And for now, just going to return an empty string. And then we can do the same thing for Bing. So return the Bing analysis empty string. Okay. Return the Reddit analysis empty string and then the final answer. So we're going to say return final answer. Okay. And then empty string. just so that all of these functions work properly and they return the correct format. Okay, cool. So, I just saved this now and what we can actually do just to test and make sure that the logic is set up correctly is we can just run this file. It should ask us to type something in and it should just give us no response. So, what I'm going to do is just press on run here and we'll see if we get any errors. It should just prompt us to type something. So, it says ask me anything. So just go hello and then you can see that it just kind of gives us this output and then doesn't say anything and says ask me anything. So that to me means that this is working again type hello and you can see that it just kind of doesn't give us anything but we get some output here and that's actually exactly what we were looking for. So I'm going to stop this here because it means the flow is working properly. And I did notice that we have a few spacing issues. So let me kind of fix that here. Looks like yeah we randomly printed out a quote. So, let's get rid of that and fix the quote here. And I think we're kind of good to go. So, the next step is going to be to set up our LLM as well as to set up Bright Data to start doing these search operations. I want to start by searching Google, then searching Bing, and kind of walk through these and do one search operation at a time so you understand how they work. So, what we're going to do is we're going to go and get these API tokens. So, we're going to create a Bright Data account in an OpenAI account. Let me go to my browser and let's set that up. All right. All right. So, let's start by getting our OpenAI API key so we can use GPT and then we'll get the bright data one. So, what we're going to do is go over to platform.openai.com. From here, we can just go to our settings, then to our API keys, and we can create a new key. So, from here, I'm just going to go with AI agent as the name. Okay. And then obviously, you don't want to leak this key. So, I'm going to copy it and I'm going to paste it here in my environment variable file. Okay. And now that we have that, we need the Bright Data credentials. So, if you don't already have an account, you're going to need to create a new one on Bright Data. I'll leave a link below in the description and you should be able to get some free credits. So, you do not need to pay to use this for the tutorial. Now, I quickly want to show you a few of the services that we're going to use here from Bright Data because they have a lot of options when it comes to getting web data specifically for AI agents. So, for example, they have a chat GPT scraper, right? where you can actually scrape the conversations from chat GBT, the responses, the user queries, etc. We're not going to use that here because we don't really need it for this specific tutorial, but in other ones, it's quite useful. Now, we also have, let's go here, social media scraper. So, this is the one that we're specifically going to use to scrape Reddit data. You can also get stuff from Facebook, Instagram, Tik Tok, YouTube, which is notoriously very difficult to scrape. If you've ever tried to build your own scrapers before, you've likely seen that it's very complicated to actually get this data and you get blocked by captas, IP bands, uh, etc. Whereas Bright Data can actually overcome and bypass all of that for you and just give you the data in a very easy format. So, for example, you can get Instagram profiles, posts, X, LinkedIn. In our case, we're using Reddit, which I think makes a lot of sense for this particular agent, but obviously you can pick pretty much anything you want. And then we have the SER API or the search engine API where we can really quickly scrape all of the major search engines like Duck.go, Google, Bing, etc. This also works for things like Google flights, right? Uh, and all of those other services that come from those search engines. Yeah, like maps, images, hotels. Pretty cool. I've done some other projects in the past where I've used this. And again, for this one, we're just going to use the standard kind of Google Bing search engines. They also have things like a web archive. So, for example, if I go to the documentation here, you can see that you can actually scrape all of the previous web data. So, you can get like years back and you can kind of see trends and historical data. Again, not going to use that for this video, but we could add that if we wanted to make it more complex. Okay, so for now, we need to make a new account or log into our existing account. So, go to the link that I have in the description. I'm going to log in because I already have an account here. For you, you are likely going to create a new one. So, once you've signed into your account, you should be brought to a page that looks like this. They actually recently added this feature where you can just ask the AI here and it can tell you how to do what you want to do. Uh I'm not going to use that though. What I'm going to do is go to proxies and scraping from the left hand side here. And what we're going to do is create a new SER API. Now of course there's a lot of other features here as well like web scrapers. We'll use this later to actually collect the Reddit comments and the posts as you can see that I was kind of doing already. But for now, we go back to proxies and scraping and we're going to go to add up here and we're going to create a new SER API, search engine API. Okay. So, press on this. From here, we can give it a name. I'm just going to call this AI agent uh two because I already have one called AI agent. Can give it a description if you want. And then in this case, I'm just going to leave this at standard, but you could go maximized if you care about actually retrieving the ads. Okay. There's a few advanced settings as well. We don't really need to modify any of those currently. And we can just go ahead and press on add again. You should have some free credit. So this should be free to use for you. And then later obviously you can pay for it if you want to use the service. Okay. So I'm going to go yes create this new zone. Once this is created it should give us access to an API key which we can actually see here and show us how we can call this API. So notice here we have method API and then we can do for example Python and it gives us an example of how to call this. What I'm going to do for now is I am just going to copy the API key which is right here. And we're going to take that and put that into our uh file into our environment variable file. So let's go here and paste the API key. And obviously don't leak that to anyone. I'm going to delete that after this video. And then we'll be able to start using this service, the search engine API. Now if you go to the playground, you can actually mess around with it here and you can uh kind of test out your different searches. So for example, we could search all of these different engines here. We can choose the keyword that we want to search. And then there's a bunch of other information that we can add. So we can search a specific Google. So dot, you know, France.AE dot whatever, right? And then we can add all these other settings like do we want to look on desktop or mobile? Do we want to add specific headers? Do we want to actually get a page nated response? Do we want geoloccation? There's all these different parameters that we can add. And there's some examples that you can view here as well on exactly how to do this. In our case, it's going to be pretty simple. We're just going to search Google. Um, and that's kind of it. So, what we'll do from now is we'll go back to main.py. And I'm actually going to make a new file where I'm going to call this webcore operations. And inside of this file, which will be a Python file, I'm going to start implementing all of the operations related to the web scraping and to using the bright data service. So, inside of here, we're going to start with just our basic search. So, we're going to be searching Google. But in order to do that, I'm going to set up some reusable functions that will make our life a little bit easier in the future because we'll be sending quite a few requests over here to the bright data SER API. So what I'm going to do is I'm going to say from enenv import load.env again because we need to import our environment variables. I'm going to say import OS import request and I'm going to say from URL lib.parse parse import the quote underscore plus which is going to allow us to turn a normal string into a string that we could include in a query parameter in our URL which you will see in a minute. For now, I'm going to call load.enb to load theenv function. And I'm going to make a simple function here called make API request which will just be a reusable function that we can use anytime we want to send a request to bright data so we automatically can include the correct headers for our authentication. So I'm going to say define_make API request like that. I'm going to take in the URL and starst star quarks like that. Here I'm going to say API_key is equal to os.get env. And we're going to get the bright data API key like that. Okay. So we're going to get the API key and we're going to create a set of headers because we need to send these headers to tell bright data who we are. So we're going to say authorization is equal to fstring and then bearer space and then our API key and then we're going to say the content dash type is going to be the application JSON because that's what we want to get back. Okay. From here we're going to do a simple try accept block where we send a request to whatever the URL is that was provided here. So we're going to say try and this is going to be response is equal to request.post. We're going to post to the URL with headers equal to headers like that and pass our star star quarks. We're then going to say response.rafor status. What this means is we're going to raise an exception if we don't get an okay status. And then otherwise we're going to return the response.json. Okay. Then we're going to say accept and this is going to be request.exceptions exceptions dot and this is going to be the request exception as E and we're going to say print like this an F string and we're going to say API request failed and then we'll put E inside of parenthesis or inside of braces and then we can return none because this didn't give us a response. Then we can have another exception. So we can say except any general exception as E. We can say print f unknown error and then we can print out e and again return none. I'm just doing some more advanced exception handling here just so that if it's related to the network request we can handle that. If it's not related to the network request then we deal with it here. So we kind of know which exception or what error was actually causing the problem. Okay. So now we have a general function that can send a request to brightite data. What we need to do next is implement our SER function. Okay. So we're going to say define and this is going to be SER search. And what this is going to do is take in a query and an engine which by default right now is going to be equal to Google. Now I'm going to write this kind of dynamically because this will allow us to actually search any search engine that bright data supports. So something like Bing, Google. So we can reuse this function multiple times. All right. What I'm going to do is I'm going to say if the engine is equal to Google, then I'm going to say the base URL is equal to https/google.com/arch. And this needs to be ww.google.com/arch. We just add a new line here. We're going to say l if the engine is equal to bin or not bin, bing. Then the base URL is https www.bing.com/ bing.com/arch and then else we're going to raise an error and we're going to tell them hey this engine is not supported. So we're going to say raise value error and then unknown engine and then whatever engine they passed. Okay. Now we're going to say the URL is equal to https slash and this is going to be api.brightdata.com/ request. Okay, because this is where we're going to send the request and we're going to pass essentially the search URL that we want to search and get the data back from. Now, we're going to say our payload is equal to zone and the zone is going to be the name of the zone that we created, which is AI agent 2. So, if we go back here and we look at our overview, we should be able to see the zone name. You can see it's right here, AI agent 2. Okay, so that's our uh zone name and you can kind of see the information down here as well. So, anyways, we need to pass the zone. We also need to pass the URL. So the URL is going to be the following. We're going to put an F string. We're going to put our base URL, which is the search engine that we want to search essentially. And then we're going to say question mark Q is equal to and we're going to say quote unl. Now what this is going to do is it's going to take whatever the user typed in. That's going to be our search string. It's going to turn it into a format that we can actually pass correctly in a query parameter for this URL. And then we're going to put an and we're going to say BRD_JSON equals 1. Now what this means is bright data JSON enabled. So essentially we want to get our responses back in JSON format. So Bright Data is actually able to parse all of the responses from the search engines and then return it to us in a digestible format. In this case, JSON. And then we're going to say the format is raw like that. Okay. So this is the payload which is essentially how we send this search request. This will hit the search engine API and then it will give us back a response. So what we're going to do here is we're going to say the full underscore response is equal to underscore make API request. We're going to pass our URL right which is the URL right here. So that's where we're sending the request to. And then we're going to say actually the JSON is equal to payload which will be another query parameter that we pass there along with our request. We're going to say if not full response then we're going to return none. Otherwise what we're going to do is extract data out of this response. So the bright data response is going to give us a ton of information. It's going to give us the sponsored post, the organic post. It's gonna give us a bunch of stuff, but we only care about a few sections of that response. Now, if you want to look at this response, you can just mess with it right here. You can go to the playground, right? And we can kind of run this request and see the result that we get. But what I want to do is I just want to pull out a few pieces of information. So, right, it's giving us the full kind of preview of the page. We can actually look at the JSON format and you'll see it has like general, input, navigation, it has all of these other fields, right? It's a very long response that we get, but I only care about part of the response. Now, the part of the response that I care about are to the organic results and the knowledge that Google pulls here. The knowledge is like a quick summary of the uh information that you search for that you've probably seen before if you've done, you know, a Google search. So, what I'm going to say is extracted data is equal to this and I'm going to say knowledge is equal to the full response.get get and I'm going to get the knowledge field. Now, if that doesn't exist, I'm just going to get an empty set of braces or an empty dictionary. Then I'm going to get organic and this is going to be the full response. And then same thing, organic except here, this is actually going to be a list. Now, the reason I know this is because before the video, I was obviously preparing. I looked through the response structure and these are the two fields that I care about. If you want to see the entire response structure, then feel free just to print it out and you can see all the information that it gives you. Here, we're just narrowing down the data. that we only get the important stuff. But if you wanted all of the data or something else for a different use case, then of course you can get that from this API request as well. And what's interesting here is that you can run this as many times as you want. It's very scalable. So you can run this, you know, hundreds of times, thousands of times with different requests. And it returns very, very quickly because it's already indexed by bright data. So I'm going to return the extracted data here from this function. And then that should be it for this first function where we're essentially just calling this kind of search function. All right, so that's pretty much it, at least for right now. What I'm going to do is I'm going to go back to main. I'm going to import what we just wrote and then I'm going to call that from one of our functions so we can test it out and make sure it works. So I'm going to say from web operations import and we're just going to import the SER search. So now where we go to Google search the Google results are actually going to be SER search and then the user question and we're just going to say the engine is equal to Google and then that should give us back the Google results. Okay. So for now what we can do is we can just print the Google results so we can see if we're actually getting anything at all. And while we're at it we might as well just do the same thing for Bing because it's going to be the same thing just with a different engine. So let's go SER search. We'll go user question engine is equal to Bing and then same thing we can print the Bing results and we can do an initial test here to see if this is working. Okay, so let's run the file and let's go invest in video. Okay, and it says searching Bing, searching Google. Wait a second and then we should get the results. And you can see no knowledge popped up for this one. That's okay. And then for organic there's a bunch of links, right? So it gives us kind of all of this data popping up related to those results and you get descriptions. So I start thinking of Nvidia stock etc etc. Now of course there's a lot more stuff that we can extract from here but for now that is good and it gives us kind of the top results on Google and we can read through the descriptions the links etc. Okay, so let's exit out of that and let's continue because now we have the SER API functioning. And I'm just going to remove the print statements because now that we know we're getting the correct results, we don't really need anything more. All right, so we have Google search, we have Bing search. Now what we want to do is we want to implement the Reddit search. So for the Reddit search, it's a little bit different and that's going to require us going to web scrapers. So from here, we're going to go to new. We're going to go to browse scraper marketplace and then we're going to search for Reddit. Okay, so it's going to take a second. We're going to press on the result for scrapers and then this is going to give us a few options that we can use to actually scrape Reddit and get the real lifetime data. Now you can build your own scraper if you want, but a lot of them that you need are already built for you and you can just call them like an API which makes it very easy to actually download and get the data quite quickly. And in our case, there's two main things that we want to use here from Reddit. We want to discover posts by their keywords because we want to search essentially on Reddit. And then after we search, we want to get all of the relevant post URLs and download all of the comments. So you can see we have Reddit's comments collect by URL. Then we have Reddit post discover by keyword. So we're going to use both of them. First, we collect the post. Then we get the comments from the post that we care about. So let's go to Reddit post here. It's going to say scraper API. So I'm going to go ahead and press on next. And it's going to create this scraper for us. Now here we have collect by URL, collect by keyword, collect by subreddit URL, right? Like and we can get the comments as well. And we can kind of run through this and see how we use this scraper, all of the fields that we can pass to it and all of the fields that we'll get back. So it shows us what the response structure looks like. And then if you go to the API request builder, it shows us how to build this API. Now our API key will be the same. The thing that's going to change is the URL that we need to hit here. And this is where I want to go in and talk about our management API. Okay, so when we use this um scraper, essentially what's going to happen is we're going to send a request and then bright data is going to go using its scalable network and start collecting all of that data for us. Now, it's not going to be available instantly because it needs to actually access it in real time from Reddit. So what's going to happen is we're going to create something called a snapshot. Now the snapshot is going to be generating. So when we first send a request, it's going to take a second. It's going to start generating. So what we need to do is we need to monitor the progress of this particular snapshot and wait until it's ready. Now, as soon as the snapshot is ready, we can then download the snapshot and we can access the data, but we need to wait for it to be finished. So essentially, there's these multiple API endpoints that we're going to hit. The first endpoint is going to be to actually start the collection process. Then we're going to use this monitor endpoint to wait for when the snapshot is ready. And then as soon as it's ready, we're going to download the snapshot. So we need to kind of write some code in Python here that is going to allow us to do this process where we hit the API, we wait for it to be ready, and then we download the snapshot. Okay, so I'm going to start writing this out. I've written it based on myself reading the documentation here, and you'll kind of see how it works as we code this out. Again, we just need to make this scraper to start, and then we need to get access to the data set ID, which I'm going to show you in one second. So in the left hand side here, we're going to go to discover by keyword. We're going to go to the management APIs and we're going to scroll down here until we see this data set ID. Okay, so we need to copy this data set ID because this is something that we're going to need to use when we actually perform this scraping operation so we can identify what data set we're talking about. All right, so we have that data set ID. What I'm going to do for now is I'm just going to put it in a comment in my web operations file so I don't forget it. So I'm going to say data set ID is equal to that. And now I'm going to start writing the Reddit search function. Okay, so I'm going to say define Reddit search. This is going to take in the following. It's going to take in the keyword that we want to search for. It's going to take in the date, which in this case I'm going to say is all time. It's going to take in the sort by. I'm going to sort by hot posts, but you could sort by rating or um you know up votes or whatever you want. So let's go hot. And then we're going to say the numbum of posts. And in this case, I'm going to do 75. You can do as many as you want. Okay, so let's zoom out a little bit so you guys can read this and let's continue. So for Reddit search, the first thing we're going to do is define our trigger URL, which is going to be the bright data API. So we're going to say https/api.brightdata.com/datasv3/trigger. Okay, then I'm going to say my params are equal to and I'm going to put my data set ID and this is going to be underscore ID and this is going to be equal to the ID that we had up here. So I'm just going to copy it and paste it inside of here. Okay, then we're going to have include errors and this is going to be true inside of quotation marks. I'm going to have type and this is going to be discover new. Again, I'm getting all this from the Bright Data documentation and I'm going to say discover_by and then keyword. Okay, so this indicates what type of kind of search we're doing essentially. Next, I need to indicate the data that we're searching for. So, I'm going to say data is equal to and this is going to be a list. And then inside of here, I'm going to put all the keywords that I want to search. Now, you'll notice that because this is a list, I can actually put multiple sets of keywords at once and Bright Data will go and asynchronously scrape all of them for us. So, what that means essentially is that if you wanted to do a 100 different search strings or a thousand different search strings, you can do that in one API request rather than having to send multiple of them because this is set up to obviously scale. So, we're going to say keyword is equal to keyword. We're going to say date and then this is going to be equal to the date. We're going to say sort by okay and this is going to be sort by and then we're going to say the num of posts is equal to the number of posts and then again you could write this multiple times for multiple search strings. So this is going to start setting it up. We're now going to say raw data is equal to and I'm going to call a function here that I haven't yet defined. So right now we're going to say none. We're going to say if not raw data then we're going to return none. Otherwise, we're going to go and we're going to parse this raw data. So, I'm going to say to-do parse raw data and then we are going to return the information right here, which we'll write in 1 second. Okay. So, essentially this is how we're going to start uh set up the trigger. But essentially, what we need to do is write a function that will allow us to download the snapshot, which is how we're going to get the data, which is what I'm going to write now. So, I'm going to put another function here. Here I'm going to say define underscore trigger underscore and underscore download snapshot like this. I'm going to take in the trigger URL. I take in the params the data and the operation name which in this case I'm just going to call operation. Okay. Now here what I'm going to do is I'm going to make an API request to brightite data. I'm then going to get the snapshot information and I'm going to pull that snapshot until it's ready and then download it. This is going to be a little bit of code, so just bear with me here. I'm gonna say trigger result is equal to underscoreake API request. So the function that we wrote before, we're going to pass our trigger URL, our params, which is equal to the parameters, and our JSON, which is equal to the data. And then what we're going to do is say if not trigger result then return none because of course if it didn't give us anything then we can't pull it. Otherwise we're going to say the snapshot and this is going to be underscore ID is equal to the trigger result.get snapshot ID or snapshot ID sorry. We're going to say if not snapshot ID then same thing return none because we don't have any snapshot to retrieve. Otherwise, what we're going to do here, I'm going to write a to-do, is pull the snapshot. Okay, so that's what we need to do. Now, we need to write some more functions uh to essentially pull the snapshot and download the snapshot. Now, to make this a little bit cleaner, I'm going to make a new file here. For this new file, I'm going to call this the snapshot_operations. py. And I'm just going to copy in this file just to save us a little bit of time because it's pretty kind of redundant code and it's not super valuable for you to write all of this manually. So what I'm going to do is paste it in. It's about 70 lines. I'm going to walk through exactly what it's doing, but you can just simply download this code by going to the link in the description for the GitHub repository, finding this file, just copying it, and pasting it in here. Anyways, let me walk through what we're doing here. So you can see we're importing OS time requests and typing. What I'm doing is I'm pulling the snapshot status. So, I'm getting my Bright Data API key. I'm setting up the progress URL. I'm setting up my headers. And what I'm saying here is, okay, I want to keep sending requests to this endpoint until eventually it tells me that it's ready. So, I'm going to do this a maximum of 60 times. I'm going to delay by 5 seconds in between each of those so that this takes me a maximum of 5 minutes. I'm going to say, okay, checking snapshot progress. This is the attempt. We're going to get the response from this URL. We're going to check the status. If it's ready, we return true. If it's failed, we return false. If it's still running, then we just add a time delay. And we keep doing this. Okay? And we keep going and we keep going and we keep going until eventually it fails or it's ready. Now, we have another function called download snapshot. And we only call this function once the snapshot is ready. So, same thing. We set up our API key and our download URL. And then we simply send a request where it downloads a snapshot and then returns the data to us. Okay. Okay, so that's all that I put inside of this function. So now from web operations, we're going to import those functions. So we're going to say from and this going to be snapshot operations import and then we are going to import the download snapshot and the pull snapshot status. Okay, so now let's go to our to-dos. So we have a to-do here where we need to pull the snapshot. So for pulling the snapshot, we're going to do the following. We are going to say if not pull snapshot status and the snapshot ID then we are going to return none. What this is going to do is it's going to continually pull the snapshot until it eventually gets a result of true or false. True means we can download it. False means there's an error in which case we return none. So we're now going to say the raw data is equal to the download snapshot and we're going to download the snapshot with this snapshot ID which will contain our scraped data and then we can return raw data. Okay, so this function trigger and download snapshot is going to well do that. Okay, so now we can go to Reddit search. Let me just add a new line here. From this we can get the raw data now. So we can say the raw data is equal to underscore trigger and download snapshot. We are going to pass the trigger URL. We're going to pass the params our data and an operation name which I'll just call Reddit in case we want to do some logging later on. Same thing if there's no raw data we'll return none. Otherwise we're going to parse this data. So I'm going to say parsed data is equal to an empty list. that what I want to do is I want to take all of the data that was returned to us and I just want to get the information from this data that I care about. That's because I don't want to pass all this unnecessary data to my LLM when I start checking which post we actually want to download or want to get the information from. So I just want to get for example the description of the post and the title of the post or the title of the post and the URL of the post just the data that I actually need. Okay. So I'm going to say parse data is equal to a list. I'm going to say for post in raw data. Then I'm going to say the parsed post is equal to and I'm going to say my title is equal to the post.get and then title and I'm going to say my URL is equal to the post.get and then URL. Now each post in my raw data is going to have a ton of information, right? It's going to have the number of likes, number of upvotes, the number of comments. It's going to have a description. and it's going to have the date was posted. It's going to have the author. I don't care about all that information. So, I'm just parsing through it, getting the information I do care about. And then I'm going to say parse data.append. And I'm going to add this post to that data. Then here I can return my parsed data like that. Okay. So, this function now should actually work where if we do Reddit search, it should essentially trigger this scrape operation to start happening. So, Bright Data will go to Reddit, it will do the search, and it will start collecting all of the relevant posts. Then, we're going to pull that snapshot because it takes a second to run. As soon as the snapshot is ready, we're going to download the snapshot. We're going to parse through the results and then we're going to return that parsed data. Now, the next step after this would then be to get the URLs from this parsed data that we want to explore further and then to download all of their comments. So, we're going to do another operation in a second here that's going to get all of the comments from a list of posts. But for now, let's test this one out by going back to main.py and actually calling this function now from our Reddit search. Okay, so we're going to go to Reddit search now. And we're just going to change this to call the Reddit search function. So what did we call this? Actually, we called this Reddit search. And actually, let's call this Reddit search API. Uh because if we name it the same thing as our function here, that's going to be an error. So we're going to say Reddit search API like that. And then we're going to import this. So, let's go up here and let's import the Reddit search API. Okay, cool. Come back here and same thing. We'll just pass the user's question. And then what we can do is we can print out the Reddit results. Okay, so now we've tested that function. So, let's run this and see if it works. And we're going to say, should I buy AMD stock? Okay, and it says it's starting the search. And it gave us a bad request for this URL. Also, I probably just typed something incorrectly and I will check what that problem is. Okay, I was just checking here in kind of a silly mistake, but I accidentally had a capital T when I typed all time here and this needs to be a lowercase T. Uh, that should fix the problem for us now in this function. So, if we come here, we can run this and we can say, you know, invest in AMD and then we should be good. And you can see it starts checking the snapshot progress. Okay. Now, while it does that, we're just going to make a small change to the code as well because the way that I'm returning this parsed data uh from here is not actually how I want to return it. What I want to return instead is a format that makes a little bit more sense. So, I'm going to say return. So, I'm going to put a set of braces and I'm going to say parsed posts and this is going to be equal to the parsed data. And then I'm going to say the total found. Okay, total found is equal to the len of the parsed data. Okay, cool. So that's that. And if we go here, it looks like it finished running. And you can see that we get some posts and some titles from Reddit. Now, these don't seem to make a ton of sense to me. So I'm just going to quit this and try again because I think I may have messed something up in the search string here specifically because I think I spelled invest incorrectly. But let's just search Nvidia here. And let's see if we get some posts that make a little bit more sense here from Reddit. Okay. And there we go. So, these make a lot more sense, right? Nvidia is actually in the post title because I didn't spell it incorrectly this time. And there's 75 posts as we go through here. And the next step is going to be to narrow those down so we can grab all of the comments that we need from them. Okay, so that is working. And we've got this first function where we're doing the Reddit search. Next, we want to get all of the Reddit posts. So, what I'm going to do is write another function here. And then this will wrap up all of the search operations, and we'll go back into Langraph and start doing some of the kind of prompting with the LLM. I just like to get the data first. Then once we have the data, we can pass it to the LLM, and we can kind of analyze it. So, here we're going to go Reddit_post retrieval. Okay? And we should spell retrieval correctly. What we're going to do is we're going to take a list of URLs. We're going to say days back. So, this is the number of comments that we want to get or how many days back we want to get the comments from. We're going to say load all replies. For now, this is going to be equal to false. But if you wanted to get all of the nested replies, then you could go with true. And we're going to say comment limit. And for now, we'll just make this an empty string. And then later, we can add a limit if we're getting too many results. And what we're going to do is we're going to say if not URLs, then we're just going to return none because if you don't pass me any URLs, well then there's no reason to do this search. And then what we need to do is set up a similar thing to before. So I'm going to copy this trigger URL. And I'm going to put this here and we're going to say the trigger URL is equal to the following. Then we're going to say the params are equal to and we're going to say the data set ID. The data set ID here is going to be different. I'll show you where to get that from in a second. And we're going to say include underscore errors is true. Again, we're then going to create our data. So, we're going to say data is equal to same thing. You could run this at scale if you want. And we're going to say URL is equal to URL. We're going to say the days back is days back. We're going to say load all replies. Load all dollar replies. And we're going to say comment limit is equal to comment limit. And then this is going to be for URL in URLs. So essentially we're creating one of these entries for every single URL, passing that all inside of here, and then we'll get all of the comments for all of these URLs with these parameters. Okay, so now we need to find the data set ID. So what we're going to do is go back to write data here. We're going to go to where it says collect by URL. We're going to go to the management API. And then if you scroll here, you'll see this new data set ID, which is the one that we're going to copy. We'll come back here and we'll paste that updated data set. So this is the one for getting the comments. All right. Now, we're effectively going to do the same thing that we did before. So here we're going to say the raw data is equal to and it's going to be underscore trigger and download snapshot. We're going to pass the trigger URL. We're going to pass our params data and the operation name is going to be Reddit comments. Okay, we're going to say if not raw data, then we're going to return none. And then if we do have raw data, we are going to parse the comments. So we're going to say parsed comments is equal to an empty list. We're going to say for comment in the raw data. We're going to say the parsed comment is equal to and then we're going to start writing the comments. We're going to say the comment ID is equal to comment.get. And then this is going to be the comment id. We're going to say the content is equal to the comment.get and this is going to be the content. We're going to say the date and this is going to be the comment.get and then of course the date. We're going to say the parent comment ID because this will be important for the linkage. So parent comment ID is equal to comment.get get and then this is the parent comment ID. Okay. And then lastly, we're going to say the postc_title and this is going to be the comment.get post title. And make sure we don't forget to put that inside of quotes. Okay. Then we're going to say the parsed comments.append the parsed comment. And then lastly from here we're going to say return and we're going to return the comments which is the parsed comments. and we're going to say the total underscore retrieved. Okay. And this is going to be equal to the len of the parsed comments. Okay. So that's it for getting the comments. Now again, it's literally the exact same thing as getting the post except we're changing the data set ID and a few of the different parameters. That's it. So now we have the ability to get all of the different uh comments for a particular post. Now, before we can test this, we need to know what posts we want to get the comments for. So, what we're going to do is close out of this. We're going to close out a snapshot. We're going to close out av. And now, we're just going to be working inside of this main file. So, the Reddit search works, the Bing search works, and the Google search works. Now, the next step is to analyze the Reddit search, pull out the relevant URLs, right? So, that's what this is doing right here. And then to retrieve those comments or really the post data from those particular posts. So let's move on and let's handle that. All right, so let's move on to the next step here where we are going to analyze the Reddit post and then pull out the ones that are relevant. Now, in order to do that, we're going to need some LLM operations here. And I'm going to make a new file and I'm going to call this prompts. py. Now, similarly to before, I'm not going to write all of this out from scratch because it is a good amount of code and it's not super valuable to do that. But what I'm going to do is paste in all of the prompts that I've already written that we're going to use for this video. Again, you can get these from the link in the description. Just go to the GitHub repository and download them. So, I'm going to paste it in. It's going to look like a lot of code, but really most of it is just prompts that I've already written that I've tested that work well here. Now, you see that I have this class called prompt template. I have a few static methods inside of here where when you call this function, essentially just returns to you the prompt. So, for example, the Reddit URL analysis system. That's the one we're about to use. You're an expert at analyzing social media content. Your task is to examine Reddit search results and identify the most relevant post that would provide valuable additional information. You get the idea. Okay. And then we tell it do the following. You know, find this information blah blah blah. And then return a structured response with the selected URL. Sorry. Reddit URL analysis user user prompt for analyzing Reddit URLs. So same thing user question that we pass the user question here. Pass the Reddit results analyze these Reddit results. Same thing for the Google Analysis. Okay. Pull this in. Google analysis user. same thing the user prompt. So we have the system prompt and the user prompt and all these functions or methods that contain the prompts and allow us to pass some variables and have it kind of embedded inside of here. So don't worry too much about this uh but there's a few functions that of course we are going to use from this file. So now we're going to go to main.py and we are going to import them. So we're going to say from prompts and we're essentially just going to import all of the functions that we have written there. So what this is going to be is get the underscore Reddit analysis messages, get the underscore Google analysis messages, get the underscore Bing analysis messages, get the Reddit analysis messages, and get the synthesis message. Okay? And then we can format this. So we can just put set of parenthesis here. Okay? So like that. And then we can move this down to the next line and kind of put all of them like this. So they're all getting imported from the same place. Okay. So I think that is good. We have the prompts. Now what we're going to do is go over to analyze Reddit posts and we're going to start using some of these prompts when we call the LLM. Okay. So first things first, we're going to get the user question. So we're going to say user question is state.get user question and we're going to get the Reddit results. So, we're going to say the Reddit results is equal to state.get and then you guessed it, this is going to be the Reddit results or an empty string. Okay, so we're going to say if not Reddit results. So, for some reason we don't have any, which can happen, then we're going to say return and then we're just going to return the selected URLs equal to an empty list because we won't have any to select. Next, we're going to say structured_Lm is equal to llmwith_structured output. And what I'm going to pass here is something called a pidantic model, which will force the LLM to give me an output in a particular format. So, we're going to write that now, and you're going to see how useful this actually is. So, I'm going to make a class, and this is going to be the Reddit analysis. So we're going to say reddit URL analysis and this is going to inherit from the base model which we imported here from pi dantic. Now what we're able to do is define a python class and then pass that to an LLM and tell the llm it needs to give us an output that's in this particular format. This allows us to ensure that we always get something in the same format. And in this case the format that we want is just a list of URLs. So what we can say is selected urls. We can say this is a list of type string and we can make this equal to a field. This comes from pyantic and we can say the description is equal to the following. And then I'm just going to paste in the description. So let me copy it from my other code file here. But essentially we just describe what we want the model to populate this field with. So I've said this is a list of Reddit URLs that contain valuable information for answering the user's question. So now what will happen is when I initialize the LLM I can give it this model and I can say hey you need to give me an output that's always in this format and then every time we run the LLM we're going to get selected URLs it'll be a list and it will contain the URLs that we need right that are strings. So if we come here now we can just pass this which is the Reddit URL analysis and that's it. We've created this structured output model and again it's just very very useful at giving us uh content in the correct format. We're then going to say messages is equal to get Reddit analysis messages. We're going to pass the user question and we're going to pass the Reddit results. Okay, so these are the messages now that we're going to pass to the LLM. And now what we're going to do is we're going to invoke the LLM and we're going to attempt to get this kind of structured output. So, we're going to say try and we're going to set analysis is equal to the structured if we could spell structured correctly. Not sure why it's not giving me the autocomplete. Okay. Dot invoke. And then we're going to pass these list of messages. Now, the messages if we go and look at prompts here is essentially just two messages, right? So, we have like the system prompt and then we have the user prompt. So, that's all that we're passing. And if we look at the Reddit one, so it's right here. We get the Reddit analysis system prompt from the prompt template and then we get the user prompt. So we just pass that here. Those are the two messages. And then what we're going to do is say the selected URLs is equal to analysis. Okay. Dot selected URLs because it's going to give us a Python object. Let's fix the spelling. Okay. So now what we can do is we can print out the URLs just to make sure that it's actually correct. We're getting the proper URLs. So we can say for i, url in enumerate and we can enumerate over the selected urls. From here what we can do is we can say print and then we can put an f. We can put maybe a few spaces here and we can say i and then we can say dot url inside of braces. And if we want I can just go with one here so that we start the index at one. Okay. Okay, so now this is just going to print out the selected URLs. Before that, we can also just say selected URLs just so we have some logs and then we'll be able to see what those are. Now down here, we need the accept. So we're going to say accept exception as E. We're going to say print and we'll just print out E. And then we'll say selected URLs is equal to an empty list. And then when we return the selected URLs, we'll just return the selected URLs. Okay, so that's all that we're doing. We essentially said all right we're going to create this structured output LLM. What we do is we tell it that we need something in this format which we defined above. We generate the messages that we need and then we pass that to the LLM. So we invoke the LLM. We get the selected URLs from the response. We print that out. There's some error then we print E and we say there's no selected URLs and then we keep going from there. Okay. So now this should actually just work. Um what we can do is we can test this and we can see if it selects some URLs for us. So let's go to run. Let's run this and let's say Nvidia. Okay, it's going to start searching for this and let's wait for the snapshot and then see what URLs end up getting selected. Okay, so we just got an error here essentially saying that we forgot to pass one of the parameters to our functions get Reddit analysis messages. So if we go here, you can see that we have to pass the user question, the Reddit results, and the Reddit post data. So I think we probably are calling the wrong function uh because that's not the one we want. We want the get Reddit URL analysis messages which just takes in two parameters and then we have another one later. Yes. So this one here that takes in four. So are these called the same thing? No, they should not be get ready URL. Yeah. So we just misnamed this uh function call essentially. So what we'll do is we will rename this to be get ready URL analysis messages. That should be fixed. And then we're going to rerun this and same thing. Let's go invest Nvidia and see what pops up. Okay, cool. So, that just finished and you can see that it actually selected four URLs here and these all seem to be relevant in terms of investing. We're investing in video. Why are you investing in Nvidia? Nvidia is rising today. DCA, Nvidia, Tesla, I don't know what that is. You get the idea. So, let's exit out of that. That stage is completed. And the next thing that we need to do now is we need to actually retrieve all of the comments and then get those comments and again continue to pass those to the LLM. So we already have the function to do that, but we need to now write it inside of main.py. So we're going to go to retrieve Reddit posts. And what we're going to do here is just do a simple print statement and we're going to say getting Reddit post comments. Okay, like that. And then we can say the selected urls is equal to states.get selected reddit urls. And then we can continue from here. So we're going to say if not selected urls again it's possible then we're going to return and this is going to say reddit_post data. This will be equal to an empty list. And then what we'll do down here is we will start to collect that data. So we're going to say print and we'll do an fstring. We're going to say processing and then we'll say len of selected urls and we can say reddit urls like that and then we can say here the reddit post data is equal to reddit_post retrieval which we need to import. So let's go import that from the top of our program. So we can import that here. Reddit post retrieval, the function that we wrote. Scroll back down. Okay, so Reddit post retrieval. From here, we're just going to pass the selected URLs. And that should be pretty much all that we need to do. Now, down here, we're going to say if Reddit post data, then we can say print. Now, successfully got and then we can say something like this. Let's do an fstring successfully got len of Reddit post data posts. Okay, let's fix the spelling here. All right, so we successfully got those posts and then otherwise we're going to say else print failed to get post data and we can return or we can say sorry Reddit post data is equal to an empty list and then here we will go and say return the Reddit post data. Okay, so that should retrieve the Reddit post data for us. We're saying, okay, get the Reddit post, get the selected URLs, make sure we have some, obviously. Uh, if we do, then we call this function, which should go and grab all of the comment data from that. And then if we want, we can, of course, print this out. So now we can print the Reddit post data and make sure that's working before we move into the analysis and kind of synthesize step, which will be pretty straightforward. So let's make this bigger. Let's run this again. Let's go invest in Tesla. I'm sure that's going to be all over for Reddit. So, let's run that and let's see what we get. Okay, so I was just doing a little bit of debugging here because the results I was getting from the comments weren't great and I realized this because I made a small mistake in the way that we are parsing this. So, if we go back into web operations and we go to where we're parsing the comments, we need to change some of these fields because they're not actually correct based on the response that we're getting here from the API. So the major change is that where we have content, we're going to change this to say comment. So we're getting the comment because that's actually where the comment is stored. Same thing for the date. We're going to change this to date posted. And then I think we can just remove the parent comment ID because that doesn't seem to actually be working. And for the post title, I believe that we don't need that either because again, it wasn't populating quite a bit. So, let's remove that and let's just stick with the comment, the content, and the date. Again, mostly just changing this to say comment. And then I'm going to run this again and give it another test uh to make sure we're getting the right data. Okay. And there we go. It just loaded a bunch of comments for me. And you can see now the data is actually filling in. If we go here, there is a lot of data that we pulled because we pulled a bunch of comments from a bunch of different posts. All right. So, that is it for that phase. So now we've got in the post and we've got the comments from the post. The next step is really to synthesize all of this data together, which is going to be pretty straightforward. We just need to write these four functions. So let's get started here with our analyze Google results. And then we can just go through the rest of them. Again, it's pretty much going to be copy and paste uh but just changing a few things and changing kind of the prompt that we're using. So we're going to do a print statement here. We're going to say print analyzing Google search results like that. We're going to get the user's question. So, we're going to say user question state.get user question. We're going to say Google results is equal to state.get and then get the Google results. Okay. Then from here, we're going to say messages is equal to get Google analysis messages. And then we're going to pass the user question and the Google results. We're then going to say the reply is equal to llm.invoke. and we're just going to invoke the messages and we're going to go here and we're going to say the Google analysis is equal to the reply content. All right, so the llm is just the one that we defined right at the beginning, right? So if we go here, the chat model. So we're just calling it raw without doing anything else and essentially just getting whatever response it has based on our prompt. Again, you can go read the prompt from in here, but essentially we're just creating a prompt that says, hey, you know, analyze these Google results and give us the interesting uh output. Okay, so let's copy the exact same thing for Bing, except we're just going to change everything to say Bing essentially. So rather than the Google results, this is going to be the Bing. Change this to Bing. Same thing. This is going to be Bing. Okay. And then this needs to be Bing as well. for the return. We can change the print statement as well. Okay, cool. So, that's pretty much it there. And rather than get Google, this is going to be get Bing. All right, so let's copy the same thing and we're going to do it again. This time for Reddit. Okay. Now, for Reddit, it's actually going to look a little bit different. So, we'll modify this a bit more. So, let's paste this in here. I'm going to say analyze Reddit search results. Rather than just getting the Bing results, we're going to say Reddit results, this is going to be Reddit results. But then not just the Reddit results, we also need to get the Reddit post data. So we're going to say Reddit_post data. It's equal to Reddit_ost data. For the messages, this is going to be get Reddit analysis messages. This takes in three things. So the results, the post data, and the user question. So let's go to Reddit results and then change this to say Reddit post data like that. Okay. And then same thing. This is just going to say Reddit like that. Let's make sure everything else has changed. So analyzing Reddit results. Okay. Get the user question Reddit results. Reddit post data. Invoke the LLM. And then there we go. Okay. And then the last thing that we need to do is synthesize all of our analysis. This is going to be quite a bit different. So we'll just write this manually. We're going to say print combine all results together. We're going to say the user question is state.get user question. We're going to get the Google analysis first. So state.get Google analysis. We're going to say the Bing analysis is the state.get Bing analysis. And then the Reddit analysis is going to be the same thing for the Reddit analysis. We're going to say messages is equal to get the synthesis messages. And we're going to pass the user question, the Google analysis, the Bing analysis, and the Reddit analysis. We're then going to say the reply is equal to llm.invoke the messages. We're going to say the final answer, okay, is equal to the reply.content. And then what we're going to do is we're going to pass the final answer, which will be the final answer. We also need to pass messages because this is kind of how langlow works. And we're going to pass this where we say roll and this is going to be assistant. Okay. And then we're going to say content is the final answer. All right. And let me zoom out a little bit and kind of close this sidebar so you guys can see what's going on. Let's close the terminal as well. So again, what we've done here is we said, okay, we're going to get all the results that we analyzed previously, right? We're going to combine that into a message, pass that to the LLM again, and then it's going to synthesize all of that together and return to us a final answer and also just a final message. We need this message again for the lang flow kind of chain to operate properly. So that's pretty much it. I mean, I know that's a lot of code and we went through a bunch of stuff in this video. Again, all the code will be available from the link in the description, but of course, we need to test this and make sure it works. So, let's bring this up and say, ""Tell me if Elon Musk is a good person."" Okay. And let's go ahead and see what that tells us. Okay. And after a minute here, we've gone through this whole process and we get this general response here telling us what the sentiment is on if Elon Musk is a good person or not. And if we scroll over here, we can see all of the sources where it was getting this information from, you know, Reddit comments, etc. Okay, so pretty cool. Now, obviously, we can make this a lot better and we can search more things and we don't just have to have one search string and we could actually have the LLM searching multiple things and giving us a really detailed response. I just wanted to show you this to give you kind of the sense of how you create this more complex orchestration with an AI agent that's pulling in a bunch of relevant data. In our case, our lang graph is relatively simple, right? We have the architecture that I discussed before and we have what, seven, eight nodes, something along those lines. But if we added more nodes, we added more LM interaction, we allowed this to run a little bit longer, we can get significantly better responses. So I think with that said, guys, that's going to wrap up this video. If you made it to the end, give yourself a pat on the back because this is very complicated and was a long video to go through. Again, all the code will be available from the link in the description. Massive thanks to Bright Data for sponsoring this video and I look forward to seeing you in another one. [Music]",unknown
kd5jREI-rGs,"You might be making one of these mistakes right now and it's silently killing your chances. Now, I've reviewed hundreds of portfolios and these four issues show up almost every single time. So, now we move on to mistake number three, which is having no role targeting. Now, your portfolio should tell a story about the type of developer that you are. If you're applying for back-end roles, then the first thing in your portfolio shouldn't be a random front-end clone that you made 2 years ago. Now, we see this all the time, right? portfolios with an ML model, a WordPress blog, a Python game, a React mobile app, all in the same list. Now, that doesn't make you look versatile. It just makes you look unfocused. Instead, you need to pick two or three projects that align directly with the type of job that you want. If it's a back-end job, you need to show an API project, a database heavy web app, and something that demonstrates maybe performance optimization or some kind of deployment with Docker and Kubernetes. Now this way if a recruiter is looking at your work they can instantly connect the dots and say okay this person is a back-end developer.",unknown
4jMkU2PymqY,"You might be making one of these mistakes right now and it's silently killing your chances. Now, I've reviewed hundreds of portfolios and these four issues show up almost every single time. Now, the second mistake, and this is one that pretty much all of you are probably making, is having ambiguous descriptions or horrible project names. Now, look, no one cares about your project if they can't figure out what it is within seconds. If your project is called my final year project or cool app or to-do app or AI app, you've already lost them, right? Your project name should clearly explain what it is and why it matters. If you say react dashboard, that tells me nothing. But if you say e-commerce sales dashboard for real-time order tracking, that gives me a reason to actually click or to read further and see what it's about. Now, the same goes for the descriptions of your project. Keep them to one or two sentences that explain what it does, what text stack you used, and what the overall outcome was. For example, you could say a Flask and Postgress SQL web app that tracks gym workouts and suggests new exercises using OpenAI's API. Now, that's enough to make someone curious without overwhelming them with data.",unknown
6tO9G9NXsnM,"You might be making one of these mistakes right now and it's silently killing your chances. Now, I've reviewed hundreds of portfolios and these four issues show up almost every single time. Let's get into the first mistake now. That is that there is no wow factor. The first thing that a recruiter is going to notice is your list of projects. And if they're generic, if it's another to-do app, a weather app, or an algorithm visualizer, then they're gone before they even scroll. Now, you need at least one project on your resume that makes them stop and say, ""Oh, that's actually interesting."" So, you need to force a pattern interrupt in the reader's brain. So that's where they're actually going to stop to read everything he wrote because it's not the same thing that they've seen millions of times",unknown
WoNmm4YS8e4,"This video features over six hours of hands-on JavaScript content. It's organized into 15 projects ranging from beginner to advanced, and you'll find the timestamps down below along with all of the links to code and resources for the various projects. Now, these projects are curated from past videos on this channel, and I compiled them all into one large video to make it easier to follow along with and find all of the JavaScript projects that I've made in the past. Now, whether you're just starting out or you're already experienced, there's definitely something here for you. And if you're a complete beginner, this video is going to be great and help you build some really practical experience. Now, the projects are in no particular order, and you can simply pick the ones that you want to work on based on what sounds most interesting to you. Again, you can see all of the projects from the description or in the video player. Now, with that said, let's dive in. So, once you master JavaScript from this video, chances are you're going to want to deploy the apps that you build. Now, if you're tired of cloud platforms that nickel and dime you with surprise fees and artificial limits, then you need to check out Savala, the sponsor of today's video. It's an all-in-one platform for deploying apps, static sites, databases, and object storage. Now, it's built on top of Google and a Kubernetes engine across 25 global regions with Cloudflare's 260 plus edge network baked in for static site performance. Now, that means that your content loads fast no matter where you are. There are no seat licenses, no fixed plans, and just no BS. There's unlimited collaborators, unlimited parallel builds, and usagebased pricing with free internal traffic between your various services. Now, you also get managed databases, object storage, and even a full database studio right out of the box. Plus, things like git based deploys, one-click templates, and instant preview apps are just standard in Savala. Now, Savala basically combines the best of other known solutions on the market, but without the traps. It's what a platform as a service should look like in 2025. Now, you're also getting real human support by developers who understand technical issues and are there to help you every step of the way. On top of that, enjoy enterprisegrade security from day one. Now, you can try it today with $50 in free credit. Just hit the link in the description. Thanks to Savala. Now, let's get into this video. So, what we need when we're writing code is something that can execute our code and then a place where we can write our code. Now, for JavaScript, you have a few different options, but in this tutorial, I'm going to use something called Node.js. Now, Node.js is actually a clientside application that allows you to run JavaScript directly in your terminal or your command prompt. You don't need to really know what that means, but the first step in this tutorial for anyone who doesn't have this installed is going to be to go to Google and search NodeJS. I'll put this link in the description as well. And you're going to download whatever the recommended version of Node.js is for either Windows, Mac, or Linux. You're going to go to the installer. So, when you download this, it should go in your downloads or something like that. Double click the installer, run it, and then it should run uh or install Node.js for you. Node.js allows you to execute a JavaScript file. So, we can do all of our code directly in our terminal, and we don't need to open up something like a browser or interact with any HTML. Okay. So, make sure you've got Node.js JS installed. Once you have that installed, we're going to install something called Visual Studio Code. Now, this is a code editor, which is a place where we can write our code. So, just like Microsoft Word helps us write documents when we are, you know, writing an essay or something like that, we have special tools called code editors or idees, integrated development environments that allow us to write code, kind of get some syntax, highlighting, formatting, etc. So, that's what Visual Studio Code is. Go to this website again, download the recommended version for Windows, Mac, or Linux. Double click the installer, install it, and then open it up. So, at this point, you should be open in Visual Studio Code. Yours is going to look a bit different than mine cuz I have some settings and some themes and stuff. Don't worry about that. All you're going to do right now is you're going to go to file, open folder, and then you're going to make a new folder in some location that you can remember. So, I usually just recommend going on the desktop. So, you go to the desktop, make a new folder. Again, Mac, Windows, whatever, doesn't matter. Call this something like Tech with Tim tutorial, whatever you want to name it. Click enter and then open up that folder. So, I'll actually just go through the step here so that I'm following along with you. From here, you're going to be brought into an environment that looks similar to this. What you'll do now is create a JavaScript file, and then we'll pretty much be off to the races and ready to write our code. So you can see on the lefth hand side of the screen here we have a bunch of different buttons. The tab you want to be in is the file explorer which is kind of the files right here. You're going to click on this button which stands for new file or you're going to go to file and then new file like that. Okay. What we'll do is go to this new file button. It's going to pop up this little area and we're just going to type something like script.js. Now you can call this whatever you want so long as you end it in ajs extension.js JS stands for JavaScript and that's the extension for any JavaScript code files. So I'm going to go ahead and hit enter and now I'm inside of a JavaScript file. From here we're just going to make sure that our Node.js installation is working and then we'll be ready to get onto the project. So we're just going to type console.log and then inside of double quotation marks we're going to type hello. So just exactly what I have on the screen here. Don't worry too much about it. Just type this in. Save your file with Ctrl S or by going to file and then save. And then what you can do is pop open this terminal from the bottom of the screen. So you can see I kind of put my mouse down here and I can drag this up. You also can hit control and then back tick on your keyboard. Back tick is at the very top left hand side of the keyboard where the tilda or the squiggly line is. And that's going to toggle the keyboard for you. For most of you, it's going to be easier just to kind of grab this from the bottom of the screen. From here, it's automatically going to open the terminal in the same directory where your file is. So, what you'll do now is you'll just type node and then the name of your JavaScript file, which in this case is script.js. Okay? If you named it techwithim.js, if you named it main.js, then you're going to obviously replace script.js with that. So, go ahead and hit enter and you should see that you get hello appearing in the console. If that worked, then you're all set up and ready to go. If for some reason you got some error with this command, you're going to have to look up how to fix your Node.js installation. Unfortunately, I can't help you with that in this video. But you just need a way to execute this JavaScript file. Quickly recap. Install Node.js, install Visual Studio Code, open up a folder in Visual Studio Code like I just showed you, create a new JavaScript file, and then run the file using node name of the file. Okay, that's how we do that from our terminal. If you're on Mac, Linux, etc., the the steps are going to be the exact same. You're just going to see probably a few slightly different things depending on your operating system. that's totally fine. Follow the same steps. Okay, so we're all set up now. What I'm going to do is go into full screen mode and we're going to begin our first project, which is a quiz game. Now, what I'll be doing is writing a little bit of code. Then I'll be stopping kind of explaining that code. So, if something doesn't make sense, just hold on. I'm sure I'm going to explain it in just a minute or two. All right. So, for our quiz game, let's begin with what we want to build. The idea here is to make something you can give to like your friend, your son, your spouse, whatever that's a quiz about yourself or a quiz about something that you know a lot about. So, in my case, I'll make a quiz about different computer components. But for you guys, you can make a quiz like what's my favorite food? What's my favorite pastime? What do I do at night? Where do I go at 9:00 p.m. on Thursdays? Whatever you want to do, right? You can make this as personal as you want. So, I'll give you a bit of a template for the project and then you can extend this on your own and make it as long as you see fit. The idea is we'll keep track of the number of correct and incorrect answers. And that way what we can do is tell them you got 70% on this quiz or you got 30% or whatever the score is. Okay, so let's begin. The first thing we need to do is get some console input from our user. That means we need to allow them to type something into the screen. So how do we do that? Well, the way we do that is actually by installing a package which is going to give us access to some function which we can use to get some input from the user. So we're going to go back to our terminal here. So just open this up, right? and we're going to type npm install and then prompt-sync. Okay, npm stands for node package manager. And this is something that installs different dependencies on your computer you can then use within your JavaScript files. So we type npm install prompt sync and that's going to give us access to a module which will allow us uh to kind of ask the user to type in some input. Okay, so just run that from your terminal. You're going to see some output here. Don't worry if you get any vulnerabilities or issues. That's totally fine. Now, once you've installed that, I'm just going to clear my terminal here. We're going to go to the very top of our file and we're going to say const. This is how we declare a variable. We're going to say prompt is equal to require. And then inside of double quotation marks, we're going to say prompt-sync. And we're going to put another set of parenthesis here. I know this is a little bit confusing. It looks like a lot of gibberish. Just type exactly what I have here. This is kind of the most complicated line that we need. What this does is load in this module. So it requires its use and then we get access to it in this prompt variable. That now means we can use this prompt variable to actually grab user input. Okay. So we said we're declaring a constant. This is a type of variable in JavaScript. We're saying this is equal to require. We're requiring prompt sync module. And then we put another set of parenthesis here. I'm not going to explain exactly why we need those, but just make sure you have the second set. So you have this line exactly as you see it here. Now, let's just quickly test this code out by typing prompt and then we're just going to say enter something and then a colon and a space. Make sure you add the space. There's a bit of separation between where we're going to be entering some code. And then we can clear and we can run our code again. Notice, by the way, in the terminal, you can use the up and down arrow key to cycle through commands you've typed before. So, I'm hitting the up and down arrow key and it's kind of going through my command so I don't have to type it every time. Anyways, I'm going to hit node here. Notice it says enter something and you can see my cursor is appearing in the terminal. So now I can type something like hello world and then we just continue with the rest of the program. Perfect. So prompt gives us access to whatever the user types. So now we're quickly going to talk about some variables. We're going to define those and use them and then continue on from there. Okay. So what we're going to do to begin here is we're going to say const and we'll just say value is equal to prompt. Now, what we're doing here is declaring a variable. A variable is really just some named value that gives us access to some kind of piece of data. In this case, the data we're going to be getting access to is something known as a string. Now, within our programming languages, we have some different data types. These are the different pieces of information essentially that we can store in our program. So, we can have numbers, we can have a boolean value, something like true or false, we can have strings, arrays. We'll talk about those later as we go through the rest of this video. And I'm sure for many of you, you already know what those data types are. But what this prompt function is going to do for us is it's going to give us something known as a string. Now, a string is anything that is surrounded in double or single quotation marks. There's some more complicated strings as well, but typically your strings are going to be in double or single quotation marks. Meaning, if I have something like one, this is the string one. If I have something like hello, this is the string hello. And usually they'll highlight in yellow or some color for you in your code editor. Okay? So what we're doing is we're saying we're going to have a variable. We've made this a constant. Now a constant is a variable whose value cannot change and we're saying that's equal to this function which gives us some type of string. So what I'm going to do now is I'm going to type console.log value. And what this is going to do is print out or log to our console which is really our terminal the value that we typed in. So whatever gets stored in this variable we can then access by using the name of the variable here inside of our console.log. log. Again, I know this is a lot of information, especially if you've never programmed before. Going to try my best not to overload you, but these are kind of fundamental concepts we need to go over. So, I'm going to run my code again, and you're going to see I get enter something. And then I can type in hello. When I do that, notice hello gets printed to the screen because that's what we typed in from this function. Again, function gives us some kind of string. This is a data type, a piece of information we can have in our program. We store that in the variable value and then we access what's stored inside of that variable by using the variable name. Notice if I try to use something like value one here and I run the code, I actually get an error. So you can see this kind of reference error is popping up saying value one is not defined and that's because no variable called value one exists. If I wanted to print value one, so I wanted to see that in my terminal, then I would actually need to surround this in a string. So I tell my computer and I tell JavaScript, hey, I'm not trying to access a variable. I actually want to print out literally value one. So now if we clear and run and I type something like hello, you can see I get value one this time because I put it inside of a string. Okay, so that's kind of what we've learned so far. We know what a string is, anything surrounded in quotation marks and we know how to access a variable. Great. So now we're getting something typed in from the user and I just want to show you if I try to do something like value equals 1 here and I go ahead and run my code you're going to notice I get another error. Now the reason is I'm getting assignment to constant variable. Now this is where we'll quickly talk about the types of variables and then we'll continue on with the rest of the code. So here we're using a constant. Now a constant is something that can't change. So think of constant value, right? Or think of something like gravity which is a constant. This is something that's always going to be the same. So, we have the ability to define on our variables if we want them to be able to change or not change. In this case, we've said, well, we're not going to change this variable, so we'll make it a constant. However, if we wanted to be able to change the value of it later on, we'd have to use this keyword known as let or var. For now, just use the let keyword, but there is this var keyword, which is effectively going to do the same thing. It just has a few small differences that we don't need to get into right now. So I'm going to say let value equals prompt. And when I use let this says we're setting up a variable which can be dynamic which can change. So we can modify its value without a problem. So now if we run our code and we type something in you notice there's no issue because we used let instead of const. Okay. So already in 7 minutes there you've learned more than you probably would in like you know five six different tutorials for JavaScript. Okay. We have our variable now and what we should probably do is start working on our quiz. We understand the fundamentals. Now we can move on and kind of create this quiz game. So the first thing we want to do is probably welcome the user to our quiz. So we're going to put a console.log here and we'll just say something like welcome to the computer hardware if we can type this correctly. Quiz exclamation point. Okay. So now the program is going to start. It's going to print this message to the user. And the first thing I think I want to ask the user is if they'd like to maybe play the quiz. Or maybe we'll just go right into question one. In fact, we can just do question one. So, what I'm going to do here is I'm going to say const. And I'm going to say answer one, which is a variable. And this is a valid variable name. By the way, you can use numbers in your variable name. The rules for the variable naming are if you wanted to have something like a space, you'd have to use an underscore. So, if I wanted to do answer 1 hello, I couldn't do it with a space. That would cause an error. Instead, I'd need the underscore to represent that space. Or I could then put a capital on the first letter here. So something like answer one hello to kind of space it out and indicate it's multiple words. This is something known as camel case which is suggested when you're naming variables. Another rule is that you can't have any special characters. Something like an amperand is not going to work. And you can't start your variables with a number but you can have numbers inside of the variable. Okay. So we're going to say const answer one is equal to and then we're going to ask a question. So what's the first question we should ask? We'll say something like what is the brain of the computer? Question mark. Okay. And then we'll allow the user to type. Now we're going to be looking for a specific answer. And in this case, the answer we want is CPU or central processing unit. Okay. So now what we need to do is we need to check what their answer is and we need to see if it's correct. If it's correct, we want to tell them they got it right. Otherwise, we want to tell them they got it wrong. So how do we do that? Well, we need a way to compare this value with the correct answer. So, I'm going to make another variable here and I'm going to say const and we'll say correct answer one is equal to and in a string we're going to type CPU because this is the expected answer that we're looking for. Okay. Now, what we'll do is we'll use something known as an if statement. An if statement allows us to evaluate something known as a condition and see if that's true. So, we're going to say if answer one is equal to the correct answer, then we're going to put a set of curly braces like this. Don't worry, I'm going to explain this in a second. And we're going to say console.log, you got it correct. Exclamation point like that. Okay. So, what we've done here is we've set up an if statement. Now, the syntax of an if statement is you write if, you put an opening parenthesy, and then you put something known as a condition. Now a condition is something that evaluates to true or false. Now the way that this kind of works is that we have another data type in our program or in JavaScript known as a boolean or a bool. Okay. Now this is anything that is the value true or false. So these are the only two valid values that are booleans. So true or false values. Okay. Now what we can do is we can write something known as a condition which uses something known as a conditional operator to see if something is a true or false. So when I use something like three equal signs here, what I'm actually doing is I'm comparing the left hand side to the right hand side and I'm asking if they are equivalent, if they are the same exact value and the same type. Now there is a double equal sign as well. Don't use that right now. Just use the triple equal sign. We don't want to get confused with the double equal sign which works a little bit differently. Okay. So I say is answer one equivalent to answer two. Now this condition here is going to give me the value true or false. Now the way the if statement works is if whatever is inside of these parentheses is true then it's going to execute what's inside of this curly brace block. Okay? So this little set of curly braces here is associated with the if statement and it's saying do whatever's inside of this set of curly braces only if this is true. Okay, if it's false, we're just not going to do it. We're not going to enter into that block. So let's run this and see what we get. And it says welcome to the computer hardware quiz. What is the brain of the computer? And we're going to type CPU. And then notice it says you got it correct. Whereas if I run this and I type something like the motherboard, we don't get any result. The reason for that is that the motherboard was not the same as the CPU and so we didn't enter inside of this block. Meaning we didn't print this out. Okay. Now, there's a few more things to teach you related to this, but hopefully all this is making a bit of sense. Trying to kind of blur the line here between in-depth explanations and, you know, actually writing some code. Once we get through all this in this first project, we're going to go a lot faster. I just wanted to make sure that I cover all the bases in case you've never seen JavaScript before in your life. All right, so let's run this one more time. And I just want to kind of test something out. And this is what I would encourage you to do as well on your own. If you have a question, don't necessarily wait for me to answer it. You can try to figure it out by actually writing some code and modifying what you have. So for example, what happens if I type CPU with lowercase? That could be an answer. Someone could type that in without uppercases. And notice we actually don't get that output saying you got it correct. The reason for that is when we compare two strings in JavaScript, we're comparing them with their capitalization. So they're case sensitive. So what we actually need to do if we want to allow this answer or an answer like CP and then lowercase U to be correct is we need to convert either our expected answer or the answer the user types in to either lowerase or uppercase and then compare them against each other. So the idea here is that we keep our correct answer all in the same case. So in this case I keep it completely in uppercase which then means what I can do is I can take whatever the user types in and I can just convert it completely into uppercase and then I can compare the two strings. So you're just going to compare them using the same case. So how do I do that? Well there's actually a method and a method is something that you can kind of use on a data structure or on a data type and the way this works is you put a dot. So we have answer one which is a variable. This variable is equal to a string. I'm going to do dot and then this is two and then notice we have uppercase here and put a set of parenthesis. Now what this is going to do is it's going to take answer one convert it completely into uppercases and then give me that result kind of in place of this string or in place of this kind of line or you know expression that you see right here. Trying to come up with the correct word there. It's not going to modify the value of answer one. Answer one will stay the same. But what will happen is it will essentially inject what answer one to uppercase is on the left hand side of this equal sign which then means we'll be comparing the uppercase answer one to the uppercase correct answer to check if it's correct. Okay. So let's clear and run. And now you can see if I type something like CPU and lowercase we still get it correct because we converted that to uppercase. And even if I type something like CPU like that we still get it correct. Now, last thing to show you here is that if I do add something like a space, so I have CPU space, it's not going to give us the correct answer. And that's because a string that contains a space in it is different than a string that doesn't contain a space in it. Okay? So, just keep that in mind. You're comparing every single individual character and you can kind of modify the string in a way such that you're avoiding any incorrect answers when it is correct. It's just not exactly what you were expecting. Okay. All right. So, that's a good start. Now, one other thing to mention is that we should probably tell the user when they get it wrong. So, what I'm going to do is add something known as an else statement. Now, an else statement is the complement to an if statement. And this block, so whatever's inside of this curly brace is going to execute if the if statement is false. Okay? So, if this condition here is false, we don't do this instead. So, else we do what's inside of this block. Excuse me. So, I'm going to take this console.log and I'm going to say you got it wrong. dot dot dot. Okay. So now if we clear here, bring this up a little bit, and run the code, and we type something like, I don't know, GPU, you can see it says you got it wrong. All right, so at this point, we've learned quite a bit already, and we're actually ready to just extend this project and add a bunch more questions. Now, we'll add some more things to it, like keeping track of how many correct answers we have, but for now, let's just copy all of the code that we have. Paste this here, and let's change our variables just so we don't get an error. So notice here if I highlight this, it's saying cannot redeclare block scoped variable answer one. Essentially what that's saying is we already have a variable called answer one. So I can't make that again, right? Because this is defining the variable when I use this const block. So instead I'm going to change this to answer two and then correct answer two. Now let's come up with another question. We can do something like what is better, a 3090 Ti or a 4060? I don't even know if they have a 460 or not, but let's just go with that. And for the correct answer, this is going to be a 3090 Ti. Okay. So, now we can just change this around again. So, we'll say answer two and then correct answer two. And now everything should just work the exact same. We've just kind of copied and pasted this and changed the answer and the question. Okay. So, let's save that and run. What is the brain of the computer? CPU, excuse me, 3090Ti. And it actually says we got it wrong there. Um, okay. So, let me check why we're getting that. Aha. So, the reason we're getting this is because we converted our answer to to uppercase when our answer here is in lower case. So, what I would need to do is just change this to be capital TI like that. Or alternatively, rather than converting this to uppercase, I would need to convert this to lowerase. So, if you do get an error, don't freak out. Obviously, just do kind of something like what I just did and look through your code and say, ""Hey, why am I getting that wrong?"" Well, I typed it in lowercase. Ah, it was converted to uppercase. Okay, that's probably the issue. And you know that you're kind of going to have the error in one of these few lines here because this is where it's evaluating if you're getting a true or false. All right, so this happens all the time even to experienced programmers like me. Don't worry if you get an error. Very, very common. In fact, almost a good thing when you're just learning how to code. Okay, so now let's run this again. What is the brain of the computer? CPU. And now we'll type 3090 TI. And it says we got it correct that time. So we fixed it and it is working. Great. Okay, let's do one more question and then we'll add uh tracking of the correct questions. So answer three, correct answer three. Answer three and answer three. And this time we can do something like say what is the recommended amount of RAM in 2023. Now this is going to be a subjective answer but I'm just going to go with 16 GB like that. This time we're going to convert this to uppercase. So we're matching the casing of our answer. And that's all we need. That'll fix that. We're just going to need to make sure these are answer three. They are. Okay. Perfect. H let's run this and CPU 3090 Ti and 16 GB. Okay, awesome. All right, so our quiz has now been written. We have three questions. Obviously, you can add a lot more. I'm just not going to bore you by adding those right now. The next thing that we really need to do is keep track of how many correct answers we have. Now, this is fairly straightforward, but what we'd like to have is some kind of variable that's storing you have one answer correct, two answer correct, three answers correct, etc. and then display that to the user at the end. So the way to do that is to go at the very top of our program. Doesn't really matter exactly where so long as it's near the top and before your first question. And we're going to say let correct and we'll just say answers like this equal and then zero. Now one thing I'll mention just cuz some of you may be getting upset about this. I've used underscores for these variables. uh really it's going to be best practice to not use the underscore and to do it in camel case like I have suggested. Uh different programming languages have different conventions for the way you write your variables. In JavaScript you are supposed to use camel case. So just because that's the convention I'm going to change these here. Doesn't really matter. No one's going to get mad at you at least you know when you're just starting out. But just to kind of be correct I'm going to make sure we're using camelc case rather than underscores which is actually a convention in Python known as snake case. Anyways, I have this variable let correct answers equal zero. Now, this time we're using something known as the number data type. And this allows us to perform arithmetic. So, we can add to the number, subtract from the number, etc., which is different than the string, right? So, the string zero and the number zero are different like discrete unique values and they can be used differently because of the type of their data, the type of their information, right? So, this is a number meaning we can kind of add to it, subtract from it, etc. So now that we have this variable here, what we're able to do is go inside of our if statements and after we console.log correct or before it doesn't really matter, but just inside of this if statement, we can actually write correct answers like this, which is our numeric variable. And then we can say plus equals 1. Now saying plus equals 1 is going to add one to this value. Another way that we can do this is we can say correct answers is equal to correct answers plus one where we're saying okay well what was the previous value of correct answers well was it one was it two was it zero whatever it is add one to it and then assign that to correct answers so changing the value or a third way is we can write plus+ and plus+ stands for add one okay this is known as the increment operator just adds one to a variable in JavaScript so I'm going to use plus+ and I'm just going to go here and put these inside of all of the if statements. And this way at the end of our program, it will tell us the number of correct answers that we had. Okay. Uh I don't think there's much more to mention here. I will just quickly say if you see these semicolons here, you don't actually need them, but what these stand for is a line termination or a line break, which essentially means stop reading the current statement and move to the next line. Okay, that's all that means. I kind of excluded mentioning them because you don't actually need them for your code to work, but since they're here, figured I'd mention that. Okay, so now we're going to go down to the bottom of our program and we're just going to tell the user how many correct answers they got. Excuse me. So to do that, we're going to say console.log you got and then we kind of need to embed this number in the middle of the string. There's a few ways to do this, but the way that we're going to do it is we're going to put a comma. We're then going to put the correct answers. Okay? And then we're going to put another comma and we're going to say questions correct like that. So now what this is going to say is you got it's then going to put whatever the value of that number is. So 1 2 3 0 whatever and then questions correct. And it's automatically going to add a space between all of these different values because that's how this function works. So if I come here now I can print this out. Uh let's go CPU. Let's get this one wrong. So we'll go with 4060. Uh let's go with 16 GB. And then it says you got it correct. You got two questions correct. Perfect. Now last thing we can do here is we can actually give them some kind of percentage or grade indicating like what their score was on the quiz. So to do that I'm just going to make a variable here and I'm going to say total questions is equal to and I'm going to specify the total number of questions that I have which in this case is three. Okay. So we're saying constant. We're making this a constant because we don't expect to change this value throughout our program. But if you did add another question, obviously you would adjust this and make this four, five, however many questions you have. Now what we can do is we can say you got correct uh questions correct or correct answers questions correct. Then we can say you scored. Okay. And we can say correct answers and we can divide this by using the forward slash by our what is this? Uh total questions. Okay. And then we can multiply it by 100 by using the asterisk operator. And I'm just going to put this in a set of parenthesis so that we have this being applied before we have our multiplication. And then what we'll do is we'll just add a percent like that so they can see what their percentage score was. So say like 87.2 whatever in this case you know 33 66 uh or 100. Okay. So now let's run this. And what is the brain CPU? 4060 and 16 gigabytes. And it says you got two questions correct. You scored 66.66666%. If you wanted to cut that off so that you didn't see all of those values, you do have the ability to round this. Now, I'll show this to you even though might be a little confusing. You can simply take math.round and you can surround all of this here inside of that. Now, I know that gets a little bit messy. So what we might want to do here is say const percent is equal to and then put that there. And then we can just embed the percent variable. So we're kind of structuring our code a little bit better and storing some intermediate values making it a little easy to understand. I know I went a bit faster just cuz I want to move to the next project. But we're going to take math.ound and we're going to round the division of this multiplied by 100. That's going to round it to the nearest decimal value. So you are going to lose um the values here. There is a way to keep them, but I'm not going to show that to you right now. So, let's do this CPU and let's just hit enter there. It says you got one question correct. You got 33%. Perfect. Last thing, and then we'll move on. Some of you may want to actually have a percent sign and you might be getting a little mad that if you put the percent sign here, there's going to be a space between it. So, what you can do is actually perform something known as a string concatenation. The way you do that is you take this, which is a numeric value. Okay? And you can't add a number to a string because imagine this, right? I have something like 33 + 7. Yeah, as a human, you can read that. But JavaScript doesn't understand this because adding a string to a number uh could result in kind of a weird value. Now, in JavaScript, this actually does work. I don't want to tell you to do that because you can get some strange values. So, forget about the fact that it does actually work in JavaScript because you shouldn't do that. What you're going to do is you're going to convert whatever the numeric value is to a string. Then once it's a string, you can add another string to it. Right? So if I have 33 plus percent, then that's going to give me 33%, cuz we're just kind of smooshing the values together, which is known as a concatenation. All right? So we're going to take percent plus that. But to do this, we're going to say percent.2 string, which is a method that again does not modify the variable. It just gives us the string representation of it. Then we put the percent sign like that. Okay. So, let's clear and run. And let's go. CPU enter. And you got one question correct. And it says you score 33%. We really should have you scored 33%. Okay. So, that is project one. I know there was a lot of stuff we covered there. I'm going to go faster in the next projects, but I was assuming you had zero knowledge of JavaScript. We went through a lot of stuff here. Don't worry if it's a little bit confusing. Uh, but hopefully this was a bit helpful, taught you a bit about JavaScript, and you're ready to move on to the next project. All right, so now we are moving on to project number two. What I've done is I've created a new JavaScript file. So I've called this script 2.js and I've just copied this line in here because we're going to need to use this for this project. We'll be creating a random number guessesser where we will ask the user to input a number and then we will tell them if they are higher or lower than the random number they are attempting to guess. Then we're going to kind of keep track of how many guesses they've had and we're going to tell them at the end it took you say seven guesses to guess this random number blah blah blah. You get the idea. This will allow us to view a few new pieces of syntax in JavaScript and to practice working with math and numeric types rather than strings which is what we focused on in the last project. Quickly I'll mention that I am going to pick up the pace a little bit here. If I'm too fast for you feel free to pause the video or to go to the playback speed and reduce that. Alternatively, if I'm too slow, increase the playback speed and you can get through this a little bit faster. Regardless, would love to hear your feedback on the last project and what you guys are liking or disliking so far. Please let me know in the comments. I always take that feedback to heart and kind of try to adjust in my future videos. Okay, so let's get started here. First thing we need to do is generate a random number. Now, to do this, we're going to create a constant. We're going to call this random number. We also could call this target. I think that makes more sense, actually. Excuse me. and we're going to make that equal to math with a capital random. Now, what math.random will do is generate a random number between 0ero to one. It's going to give you like a very long decimal value. Okay? So, if we go here and we console.log the target. Let's bring up our terminal here and we run this. Uh, oops, I'm running the wrong script as I was saying. So, let's go to node and then script 2.js. You can see we get a value like this. So what we essentially need to do if we want to generate a random number between a range or up to some specific value uh is we do the following. So let's say I want my random number to be between 10 and 100. The way that I need to do this is I say 10 which is the minimum possible value we can have plus and then I'm going to say math.round [Music] and I'm going to take my math.random random and I'm going to multiply that by whatever the difference is between the maximum and the minimum. So let's say we want the maximum to be 100. Well then I'm going to generate a random number up to 90. So I'm going to multiply this by 90 which is the asterisk operator. Okay. So I take math.round which is going to round this to the nearest whole number. Okay. And we're going to take math.random and multiply that by 90. Now when we do that that's going to give us a random number between 0 and 90. So now we know the minimum will be 10 and then it can be anything between 10 and 100 because if we had this at the maximum of 90 that would give us 100. All right, hopefully that's making sense. But that's how you do a random number within a range. A lot of times you just want to do a random number that is going to be like say 0 to 100. If that's the case, then you just take this and you multiply it by 100. It's important that you round this though because if you don't, you're going to get a decimal value which you don't want. You want a whole number, right? So, we're going to round this off. So, now let's just print our target out. And notice we're going to get a bunch of different random numbers. Every time I run this, you should get something different. Or not necessarily different, but something that is random. Okay. So, there you go. We're generating a random number. Now that we have that, we want to continually ask the user to guess this number. If they go above it, we're going to tell them you're above. If they go below it, they're below. Otherwise, they got it correct. So, let's set up a few variables here. First we're going to say let and this is going to be guesses equal zero. Now what we'll do is we'll add to this every time the user makes a new guess. Now rather than doing this kind of constant asking right now for now what we'll do is just ask them one time get that logic set up then we'll move into that new piece of syntax we have not yet seen. Okay. So we're going to say that the we'll actually use let guess equal and actually no we can use constant. Sorry this is fine. We're going to say con guess is equal to and this is going to be prompt and we're going to say guess the number and we'll just put 0 to 100 so they know the range. Then we're going to put colon and a space and this going to allow the user to type in a number. Now what we're going to do is we're going to compare this number uh to the target value and see if it's greater than or less than. However, remember that when we get a guess here, this is given to us as a string, right? So it's going to be like the string of one or two or whatever the user types in. So what we actually need to do is convert this guess into a number such that we can compare this against the guess. All right? Or against sorry not the guess the target. So the way to do that is we're just going to take number here and we're just going to wrap this whole prompt statement inside of this number function. All that's going to do is take whatever we type in here and convert that to a number. And just as a note, if you were to type in something that's not a number, something like hello, you're actually going to get what's kind of convenient, which is nan standing for not a number. So if you type in not a number, number gives you not a number, which is actually a special type in JavaScript. In fact, we can have a look at this by saying console.log log guess. Okay. And then running this. And if we type in hello, notice we get nan, right? Where if I type in something like two, it gives us the number two. And you can tell this is a number because it's highlighting in yellow. All right. So now we've convert our guess into a number. Now that we've done that, we're able to compare this against other numbers. So what I'm going to do is write an if statement. And for if statement, we want to check if the guess is greater than or less than the target. How do we do that? Well, it's fairly intuitive. We're going to say if the guess is greater than, so I'm using the greater than sign, and then the target. Now, this is a valid comparison operator in JavaScript. This will compare either two strings, two numbers. It can actually compare pretty much any types or quite a few types at least. In this case, when we use two numbers, it works exactly as you would expect. We're checking if the guess is greater than because the I usually think of it as like the alligator mouth is eating this value. Uh, is greater than target. Okay, if that is for now we'll just say console.log your guess is too high. Okay. And then we'll say otherwise and then console.log. So let's do this. Your guess is too low. Now I know there's an issue with this. If you already know what the problem is, feel free to point it out in the comments or at least just make a note of it mentally. But right now, let's just see how this works and then I'll explain the problem. So, let's run this. Okay. And let's guess the number of say 56. It says our guess is too low. Now, in order for us to determine if this is working, we're just going to print out what the target value is just so that we know. So, actually, we need to do this before the guess. So, we're going to say console.log target right here. Okay. Just so we can kind of make sure this is functioning. So, it's 16 is the actual number. So, if we guess say 13, your guess is too low. Okay. Run it again. 52. If we guess 55, your guess is too high. So this is functioning. Now the issue I was discussing is what happens if I actually guess the number, right? So in this case, I guess zero. It says your guess is too low when really we've actually guessed the value. So this is where I'm going to uh introduce something known as the else if statement. Now the way the elseif statement works is it's an additional if that we will check if the first if is false. So what I can actually do here is I can go else if and just like I wrote my original if statement I can write another condition here. So I can say if the guess is less than the target. So now essentially the way this works is we check this first if statement. If this is true we just execute this block and we skip checking this. If this is false we go to the else if and we see if this is true. Now, the interesting thing with the else if is that you can put as many of these as you want and you can kind of check a bunch of different conditions in a row and be able to skip checking them if one of them evaluates to true. So, the advantage again is that if this is true, we don't check any of these. Whereas, if what I were to do is remove the elsees here and just put a bunch of ifs, what would happen is we would actually check every single one of these if statements because they're actually separate statements that aren't associated with each other. Whereas if we return to having our else's, all of these are kind of chained and put in one single statement. Meaning only ever one of these kind of blocks will ever be entered. All right? So I just wanted to show that to you. But we're going to have this else if now. So if this isn't true, check this. If this is true, do this. And now we can add another else. So now what I'm doing is using the if else if else where now in the else condition we can say console.log, log. You guessed it. Now, the reason why this works here is because if I check if the guess is greater than the target and it's not and I check if the guess is less than the target and it's not, then it must be the actual target, right? It must be the same thing. So, if these two are false, it means we must have guessed the value. There's other ways we could arrange this statement. Just wanted to show that to you. So, let's now run this. Okay. And now let's guess the number. Let's actually guess 56. Your guess is too low. Let's guess two. And it says you guessed it. Okay. So, the statement is working as we expected. Now, one thing to mention here just while we're at it, it is possible to use the less than or equal to operator. Exactly what it says. Checks if it is less than or equivalent to the value. Same with the greater than or equal to operator. Okay. You also can use the not equal to operator. So, exclamation point equals equals. If it is not equal to this, do the following. Otherwise, do this, etc. Okay. Just wanted to show you those operators. Okay, so now that we have this, what we'd like to do is repeat this until they get it correct. How are we going to do that? Well, in JavaScript, we have something known as a while loop. Now, a while loop is a loop that will continue looping while a specific condition is true. So, what I can do is put while, put a set of parenthesis, and inside of here, just like my if statement, I put something that evaluates to true or false. So, in this case, I'm actually just going to put the word true. Now I could do something like while guesses is less than 10 and that means as soon as they hit 10 guesses we're going to stop right so you can do whatever you want here for the condition but just put something that evaluates to true or false. So in this case we can just directly write true. Now what I'm going to do is take this kind of set of curly braces here and I'm going to put all of this code inside of here. Now what's going to happen is we're going to do this loop continually. Okay? Okay, so we're going to keep doing this uh forever until we break out of the while loop, which is something I'm going to show you. Now, right now, what we've done is we've written what's known as an infinite loop. This means we just keep going forever and ever and ever because this condition is always true. So, what we need is a way to either make this condition false or alternatively uh we need to kind of manually exit this loop, which is what I'm going to show you how to do. So, inside of the while loop, we have a few keywords. Now, one of the keywords is break. What break will do is immediately exit the closest internal loop. In this case, the closest loop is the while loop. So, we're going to exit out of that by using the break keyword. So, as soon as we see break, we're immediately going to stop executing the loop and go right down to what happens after the loop. Okay. So, now what we've actually done is we've implemented a loop that will continually keep asking you to guess until you get the answer correct. We'll keep adding to that, but for now, let's test this. So, clear and run. And oh, I didn't print out the guess. Um, okay. Well, we can just kind of run this. Let's guess 50. Uh, it's too low. Let's guess 75. Too high. Okay. Let's guess 66. Too high. Let's guess 60. Too high. Okay. 55. Too low. 57. Too low. 58. 59. And we guessed the value. Okay. So, you can see we exit out of the loop and we stop asking because we got it and we broke using this break keyword. Great. So that's how the while loop works. Now what we want to do is keep track of how many guesses the user has. So what we can do is we can simply go to the top of our while loop here and we can say guesses plus+. This is going to add one guess every time we enter this loop, right? Because we're just going to keep repeating this code. So then what we can do down here is we can say console.log you guessed the number in comma guesses comma tries. Okay, exclamation point like that and it will tell tell us sorry how many guesses this took. Now that's pretty much going to complete the program but uh let's go up here and just test this out. Okay, so guess the number 50 too high 25 too low 37 too high 30 okay 34 33 32 you guessed it and you guessed the number in seven tries. Okay, so I think actually that's going to wrap up our number guessing program. Just a few uh kind of final educational moments here. I guess inside of this while loop, obviously we can use this break, which is what I'm doing. Uh but we also have the option to use another keyword which is known as continue. Now I won't demonstrate the use case of this, but all this is going to do is immediately restart the loop. Okay. So, what I could do here, and this isn't really ideal, but we can write it in this way, is the following. Okay. This is just kind of an illustration of of how this works. I could actually put a continue keyword here, a continue keyword here, and a break keyword here. Now what this will do is if we enter into this statement and this can be an else- if actually as well then we're going to continue. Now what that means is bring us to the beginning of the loop don't continue executing anything after the continue statement. So if the guess is greater than the target don't go down here just continue the loop again. And then down here same thing if it's not greater than the target but is less than the target continue bringing us back to the top of the loop. And then if for some reason it's not any of these. So if we did actually guess the value then we print you guessed it and we break right which is down here exiting the wall while loop. This is a very like anti- pattern way to write this. Like I wouldn't suggest you write it this way, but I'm just demonstrating the use case, right? So if I go here, we can do this. Too low, 75, uh, too low, 95, too high, 90, 93, 92. Okay, you guessed it. And then notice this works exactly as it uh functioned before. Okay, I think that's going to wrap it up. Let's move on to the next project. All right. So, the next project I have for you is a rock paper scissors game. This idea is that we're just going to ask the user if they want to be rock paper scissors. We're then randomly going to pick for the computer rock paper scissors. We're just going to see how many wins, losses, or draws that they have at the end of the program. Let's go ahead and start writing this. So, I've created another script file. Again, I'm going to take my prompt and just paste this in here. I'm going to go a bit faster this time and I'll write kind of some more code and then slow it down. So, let's make a few variables. We're going to say let wins equal zero, let losses equal zero, and let ties equal zero. Okay. Now, what we'll need to do is we'll need to ask the user if they want to be rock, paper, scissors, and then generate um kind of a random value and determine if the computer is rock, paper, or scissors. So we're going to say uh con choice or yeah choice I guess is equal to prompt and then we'll say enter rock paper or scissors like that. Okay. And we'll allow them to enter something. Now what I want to do is I need to make sure the user actually entered one of these valid options. If they did then we'll continue. Otherwise we need to ask them to retry. We're going to put this inside of a while loop. But I like to write some more logic before we do that. So I'm going to show you something new here. I'm going to say if choice is equal to rock or choice is equal to paper or choice is equal to scissors. And we're going to put a triple equal sign here as well like I was mentioning. So what I'm actually checking here is three conditions in one and I'm chaining them together using something known as a logical operator which we've not yet seen. Now this doublepipe operator here acts as an or. Okay, so it's equivalent to writing or essentially what that means is if the left side or the right side is true then the whole expression evaluates to true. Now in this case I've confused you intentionally by writing actually two sets of ors. But all this is checking when we put the ors kind of chained like this is if any of these conditions are true meaning they typed in rock paper or they typed in scissors. Okay, you have to chain it like this how I've written it. But if any three of these things are true it evaluates to true. So we go we evaluate each individual condition only one of them can ever be true but as long as one of them is true we go in here. Otherwise we would need to say something like console.log. Okay. And then we're going to say, ""Please enter a valid choice."" Okay. And in fact, I'm actually just going to reverse this just because I think this will be a bit educational. Rather than putting the else here, I'm just going to put this in the if and I'm actually going to negate this. I'm going to say if choice does not equal rock, and I'm going to use something called an and, and choice does not equal paper and choice does not equal scissors. Okay. So now I've just reversed the condition so that you can see how we do this in the opposite direction using the other logical operator. This operator is the and it works opposite to the or. Both the left and the right hand side need to be true. So in this case I'm saying all three of these need to be true to enter into this otherwise don't enter. And then I've negated the condition. So rather than checking if it is true, I'm checking if it's not true. So I'm saying if the choice is not equal to rock and the choice is not equal to paper and the choice is not equal to scissors. So if it's not any of the valid options tell them enter a valid choice. Let's just quickly test that before we go any further. So we're going to clear and run script three. And notice that if I type in something like r says please enter a valid choice. Whereas if I type rock that is fine. Okay. So that is working. I know that's new but wanted to show that to you. All right. So if they enter a valid choice then what we do is randomly pick something for the computer. So how are we going to do this? We're going to say random and in this case I'm actually going to say index. I'm going to teach you something new again is equal to and this is going to be math.random and we're going to multiply this by two and we're going to say math.round round and then round this. Now the idea is this is going to give us a value of 0 1 or two which we're going to use as an index for something known as an array. Now I'm actually going to put const choices is equal to an array. I'm going to say rock paper scissors like this. Now an array is a ordered collection of elements. Okay. So what I do is I put a set of square brackets. This defines an array. Now every element in our array is accessible by an index. An index is an integer that represents the position of the element. So the first element rock here is indexable or accessible by index zero. Paper indexable or accessible by index one and scissors index two. Okay. So what I've done is I've generated a random index which will correspond to either 0, one or two which then in turn corresponds to rock, paper or scissors. Right? That's it. That's all we're doing. So that's kind of what we're doing. The reason I do it out of two is because while the max index is two, it's always going to be one less than the length of the array. There's a lot more to talk about with arrays. We're not going to get into all of it, but I just wanted to show you a simple use case right here. Okay, choices random index. Now, we need to generate the computer choice. So, we're going to say const computer choice is equal to choices. And the way we access an index of an element is use a set of square brackets. And then we place in here random index which is the index we want to use. So if I put zero that give me rock. If I put one that gives me paper. If I put two that gives me scissors. In this case we'll use random index cuz that'll be the random value. Now because we're not quite done we're going to say console.log the computer choice. Okay. We're going to clear and run. And we'll do something like rock. And then notice it gives us paper. Now let's run this again. Let's do paper. Gives us paper. I just want it to give me something different. Gives me scissors. Okay, so you can see it's randomly generating something for the computer. Okay, perfect. So, now that we have all of that, we're just going to check if the computer beats the player. How are we going to do this? Well, the first thing we can check for is if we have a draw. If we don't have a draw, then we can check the three different conditions that result in a win for the player. If they don't win, they lose. There's a bunch of different ways to check this, but it is unnecessary to check all nine different combinations because of the fact that we can exclude the draws and we only need to check for a win condition. So, you'll see what I mean, but I can say if the computer choice is equal to the choice, which is really the player choice. Um, and what I'll do is I'll just show you in VS Code. What I can do is I can highlight this and I can hittrl h or ctrl f and then I press this little button here standing for find and replace and I can actually put a string to replace this with. So I can say player choice like that and then I can put this capitalization here and this little underscore. And now you'll see what this does is it only selects where we just have choice. Whereas if I remove these, it's selecting like choices and it would select like the capital choice. But if I put both these on, I'm matching the spacing and I'm matching the capitalization. And now I can press this little button that says replace all and it just replaces all of those for me. Okay. So anyways, now that I've done that, I have if computer choice is equal to player choice, then we drew, right? So I'm going to console.log draw. And then I'm going to say ties plus+. Again, we're going to put all of this in a while loop in a second, but for now, I just like to write all of the logic um kind of at once. Okay, so we're checking if they drew. If we didn't draw, then we're going to check if the player beat the computer. And if we didn't beat the computer, then we lost. Now, there's three conditions where we beat the computer, right? So, we're going to say else if the player choice is equal to, and in this case, we'll say this is paper and the computer choice is equal to rock, then we won, right? So, we could say console.log log one and then we can say wins plus+. Now what I could do is write another else if statement and just do the same thing and check if we are rock and the computer's paper or we can do all the other win conditions or I can just chain them inside of here. Now might get a little bit confusing but let's do it anyways because the whole point is to learn here. I'm going to put these in a set of parenthesis. This is our first winning condition, right? If all of this is true. If the player chose paper and the computer chose rock, we won. Now, what's the other winning condition? Well, the other winning condition is, let's just copy this and paste this here. And you're going to see it goes on a new line for us. So, it kind of formats it. Anyways, now I'm going to say if the player chose rock and the computer chose paper, then we won. Okay, so that's the next winning condition. So, notice I've put these in a set of parenthesis because I need to kind of separate them out. So we have the first winning condition, second winning condition, and now the third winning condition. And I'm going to check if any of these three winning conditions are true. Cuz if they are, we won, right? Which is why I'm separating these larger conditions with the or statement. So now rather than paper, rock, we're going to say, okay, scissors. And sorry, I realized this is rock and needs to be scissors. Okay, so we're going to say if the player chose scissors and the computer chose paper, then we won. Now, maybe I'm crazy, but I'm pretty sure these are the only conditions in which we win. So now we handle that. And then we have an else and we say, okay, if we didn't tie and we didn't win, we must have lost. So we say const.log lost. And then we type losses++. All right, so that wraps that up. What I'm quickly going to do is I'm just going to add another console.log here. And I'm going to say the computer chose choose no chose colon, and then computer choice. And we actually don't need the space cuz it will automatically add it. Let's just zoom out a little bit cuz I know that's getting a bit hard to see. So we have our three variables, right? We ask them to enter rock, paper, scissors. We make sure they selected something that's valid. Now, we haven't actually put this in a while loop yet, which we will do. For now, this is going to tell them to enter something valid, even though we'd continue with the program. In a second, we're going to not do that. Anyways, we pick what the computer has selected. Okay, we print out what they selected and then we check if they won, if they lost, etc. Right? Saying, okay, if it's the same, then we draw. So, we say that otherwise we check the three winning conditions. Win, otherwise loss. All right, let's run this. Enter. Rock, paper, scissors. Enter rock. The computer chose paper. You lost. Okay, perfect. Let's continue. Enter rock, paper, scissors. Paper. The computer chose scissors. All right, seeming like this is rigged, but let's see. Scissors. The computer chose paper. You won. Okay, nice. So, you can see this is working. However, we want to now continue essentially until the user tells us to stop. So now, how do we do that? Well, we use a while loop. So, all we do is we take all the code we want to repeat. We're going to go here and we're going to say while true. Okay, we're going to wrap everything inside of here. So now we have a while loop, which means we're just going to continually do this. All right, and then what we need is a way to exit the loop. Now, first of all, let's go here and put a continue statement. So continue like that. Now, the reason we're going to put continue is because if the user uh does not select a valid value here, then we're just going to tell them to uh kind of go again, right? So we'll repeat the while loop right from the beginning which just means we're going to continue repeating this portion of code until they give us a valid value. Okay, please enter valid. This is going to be choice. All right, nice. Then we'll do all of this and then what we'd probably want to do is once we exit the loop or we need a way to exit the loop. Sorry. So I'm going to say enter rock paper scissors and then I'm going to put in parenthesis or Q to quit. Okay, first I'm going to check if they typed in Q. So I'm going to say if player choice equals equals Q, then I can just go here and I can say break. So it's just going to exit the while loop for us. Okay. So if they enter that, let's quit. And we can even convert this to lowercase so that if they type in uppercase Q, we still quit. All right. Then lastly, we'll go down here. We'll just say console.log. It will just print out their record. So, we'll say wins, wins, losses, losses, and then ties colon ties like that. Okay, I think that's going to be it. Let's run this though and give it a test. Okay, so let's just try to quit. Okay, so notice there you go. That works. Uh, let's enter. Let me zoom in a bit here. Rock. Okay, computer choice scissors. He won. All right. Uh, let's enter paper. Excuse me. Okay, scissors. Let's enter something invalid. Okay, please enter a valid choice. So, let's go paper. And let's quit. Says two wins, one loss, and one tie. All right, so I think with that said, that's going to wrap up this project. This is definitely the hardest one so far. I wanted to go a bit more challenging and show you some more different operators and things that we can use, but hopefully you guys were able to complete this and most of the code that you see here makes sense. All right. So, this project is going to be a fast one with the idea that you can extend this and make it as complicated as you want. I'm just going to show you probably in about five minutes the structure of a project like this, but it's really extensible and something that you could even kind of combine with some of the other projects. The idea is want to have a choose your own adventure game. The point is that we have all these different nested paths that we can go down. So, you might have seen those books before where it's like, do you want to fight the dragon with the sword or do you want to run away? And then it says, ""If you decide to fight, turn to page 35. If you decide to run, go to page 53."" A lot of kids books are kind of like that, right? Where you're picking the path you want to go down. And depending on the decision you make, you're going to either win or you're going to lose or you're going to end up in a different position. That's what we can do with code. I'm just going to start coding it for you. And you'll see very, very quickly how you can kind of work on this on your own. All right. So the idea is we're going to first need to ask the user for some information. So we're going to take this prompt and we'll start with something like const answer is equal to prompt. And the first thing we might ask is something like would you like to play question mark and I usually just put what I expect the answer to be inside a parenthesis so the user knows what to type. So why or no. Okay. So we're going to say if answer to lowercase is equal to yes then we'll play otherwise we'll console.log and we'll say that's too bad. Okay so that's kind of the first decision right? Do they want to play? Yes or no? All right. Now, only if they said they want to play do we ask them the next question, which means we put that question inside of this if statement. So, I'm going to say const answer two is equal to prompt, would you like to go left or go right? Question mark. Okay. And then we're just going to put here left slash. Now I do the same thing. I check if they answered left. We do this. If they answered right, go here. If you want, you can say if they didn't answer correctly, maybe you asked them to do it again. Or you can just end the game. You can pick what you want. If they give a invalid answer, I'm just going to essentially check for one answer. If they don't give me that, I'm going to assume it's the other one. So I'm going to say if answer two is equal to left, then I'm going to do something here. Otherwise, we're going to assume it's right. We're going to do something here. So I can actually make a comment. A comment is some code that will be ignored by your program. By the way, if I do two slashes just to indicate this else statement is what happens if I go right. So let's say we go left and I do something like console.log. Oops. You go left and fall off bridge. Bit bit extreme here but you get the idea. Uh you lost. Okay. So left was not the correct path. So they have to go right. So if they go right we can do something like const log. Nice. You go right and approach a bridge. Okay. You can be as creative here as you want. And then I can ask another question. So I can say con answer three is equal to prompt. And I can say would you like to cross the bridge or uh we can say something like turn around and find another way and then we'll put as the potential answers here cross slash term. Okay, excuse me. Same thing. We come down here. Let's just make this a little bit larger. And we now put another if statement and we say if answer three is equal to cross then you do something here. Otherwise you do something here. Now I don't really want to continue too far with this. So I'm just going to say console.log you cross the bridge and reach the end of the game. Okay. Otherwise, we can say something like con.lo log. You turn back and trip on a log and hurt your leg, you lose. Okay, so the whole point of what I'm trying to show you here is that we can nest these different blocks inside of each other. Okay, so I've done this very, very simply because I'm just trying to illustrate this to you quickly because this is a project that's really meant for you to work on on your own. But the point is that we only go into one block if the other block is true. So if this is correct, right? So if we do want to play, then we ask the first question. Depending on the answer to the first question, we now branch off and we go to the left or we go to the right. So in this case, if we go to the left, you lose. But you could make it so that each answer could potentially lead you to the correct scenario. Right? The whole point is that you can infinitely branch as much as you want by nesting these statements. So that's what we're doing. We have this. All right? We say otherwise. So if you didn't answer left, you're going right. Okay, nice. You approach bridge. Ask you another question. And then again, we check inside of here and only inside of here what the correct answer is. So if you cross, okay, you won the game. Otherwise, you lose. But we could just make it so you continue going down a bunch of other decisions. Now, you can even make this more complicated where you have previous decisions impact future decisions. Now, they already do. But what I mean by that is at the beginning of the game, you can ask something like, ""What weapon would you like to select? Do you want to wear boots or do you want to wear sandals? Do you want to wear a hat or do you want to take this and you can kind of, you know, collect some different items, for example, and then you can use those items later in the in the game. So eventually, maybe you reach a dragon or something and you can say, ""Oops, you didn't bring your sword with you, so you lose the game cuz you can't fight the dragon."" So the decision they made maybe 20 steps ago is now affecting them here and they have to restart, get all the way back there, but make sure they make the correct decision. So let me run this just so you get an idea of how it works. Okay. Uh, so sorry, we don't want script three, so close that. We want script four. Would you like to play? Yes. Do you want to go left or right? We go left. And it says we lost, right? So we can round again. Yes. Let's go right. Uh, nice. You go right and approach a bridge. Would you like to cross the bridge or turn around and find another way? Let's cross. And we win. But again, you can see if we go the wrong way. So I decide to turn. It says you turn back and trip on a log and hurt your leg. You lost. You get the point. That's how the game functions. Now, I actually worked as a uh kind of coding teacher at a summer camp where I was teaching kids or between about 10 and 15 how to make this exact game. This was kind of the final project they worked on at the end of the week. And I'll just say that they came up with some super creative and really interesting projects where they had like hundreds of lines of code, you know, 20, 30, 40 different paths. Uh, and they absolutely loved it. It was super, super fun. So, I know this is a simple, like relatively simple thing to do, but it makes really interesting games and something that's really cool that you can show to your friends, family, whatever, and you can see if they can actually get to the correct uh path. And obviously, the more complex and more interesting you make it, the better the game's going to be. So, please make something like this, extend it. You even could do something crazy where like one of the paths requires you to play rock, paper, scissors, and if you lose, then you then you lose, right? And you have to go back and do it again. So, all kinds of interesting stuff you can do. So, what I'll do now is quickly demo each of the finished projects. If you want to fast forward to one of them, there will be timestamps in the video player as well as in the description. This is the order in which we'll complete them. I recommend if you're a complete beginner, then just go in this order as I'll build upon each project in the next one. Okay, first project, color flipper, allows us to simply switch between some different colors for the background of the screen. And if I click on random, we will randomly generate a color. pretty straightforward, but it's allowing us to see how we connect events to button presses and how we can randomly generate colors and set DOM properties. Next is a palendrome checker. A palendrome is something that's spelled the same forwards as backwards. This actually a very famous algorithm style problem and something you might get asked in a very early stage interview. So a palendrome example is something like dad because this is spelled the same forward as backwards. So if we type check, it says it is a palendrome. If we do something like madame, right, that's a palendrome because it's same forward backwards. If we do dog, this is not a palendrome. So just a simple check showing you how we can check for a palrum. Next is a random quote generator. So what this will do is randomly give us a quote on the screen. There's lots of modifications you can make to this, but you'll notice that what I've done is made it so that we're going to go through all of the different quotes that exist before we start cycling back to one of the same ones. This means you're never going to see the same quote once or twice in a row and you're going to get through all of the unique quotes before you end up seeing a repetitive one. Kind of an interesting feature that makes this a little bit more complicated and an interesting project. Next, we have a timer or a stopwatch. This is going to teach you about set intervals and how to handle timed events in JavaScript and with HTML. So, we can of course start the stopwatch here. You'll see that it goes up. We can stop it. We can reset it. We can start it again. And this also teaches you how to handle some different edge cases. For example, what happens if I press start when it's already started? Well, in this case, we restart it from the beginning. What happens if I press stop a bunch of times? Well, stay stop. What if I keep resetting it? Right, it works. And lastly, we have a persistent to-do list. Now, this is interesting because this will actually allow us to store items in between browser refreshes. Just to quickly demonstrate this to you, you'll notice that if I start the stopwatch here, but then I refresh the page, it's going to go back to the original state. Same with the random quote generator, right? If I refresh, just goes back to the original state. Now, watch what happens with this one. So, I'm going to go add item here for hello world. And when I refresh, notice it's still here. So, we can do, I don't know, item two. Add this in here. Refresh. Still here. If I delete one of the items and refresh, it stays here. So, I'm going to show you how we can do some persistent storage using local storage in the browser, which is quite interesting. So, again, feel free to fast forward to any of these projects. Now, we're quickly going to go through the setup, which won't take us very long, and then we'll actually get into coding these out. All right, so I've popped over to Visual Studio Code. Now, this is the editor I recommend that you use for working on these different projects, but you can use anything you want. What we need to do here is get an environment where we're able to write both JavaScript and HTML code. And that's going to be easiest in Visual Studio Code. Now, what we'll do is we'll start by creating a folder. So, you'll notice I've already made one, but if I delete it, we can just remake it here. So, let's go new folder. And I'm just going to call this one because this is where we're going to put project number one. Inside of here, we're going to make two files. The first file is going to be our main.html file. And the second one here is going to be our index.js. Now, this will be the structure for all of our different projects. So, if you're going to do all five of them, you can just copy this directory and have 1 2 3 4 5 as the various different names. Once we've got these two files, I'm just going to show you a really useful extension in VS Code if you're using this editor that I recommend you install. Now, this is called the live server. If you go here to the side in the extensions menu, which is this that I've clicked on here, kind of looks like little puzzle pieces or a square with one of them removed, you'll see live server pops up here as the top result. It's got a bunch of downloads and I've already got it installed. What you'll do here is just click on install. It might make you relaunch VS Code. And I'm going to show you how we utilize this so that we don't have to keep refreshing the page whenever we make a change to our code. That's pretty much all you need. Once you've got that, you're good to go. and we're going to start working in our two different files. So, at this point, we're going to begin project number one. Make sure you install that live server extension if you don't already have one. Okay, so we're going to go into our main.html file and we're going to start by creating kind of the template or the user interface for our application. Now, in case you're unfamiliar, HTML is hypertext markup language and this is something that allows us to actually create elements that exist on a web page. What's better though is it allows us to actually interact with JavaScript or vice versa, JavaScript can interact with the HTML, which means if we say type something into an input box or we click on a button, JavaScript can handle that action for us and allow us to display different things on the screen or kind of determine what's going on. It gives us that dynamic behavior. So to begin our HTML document, there's a little shortcut you can use here in VS Code, which is HTML col5. Now, when you type that, you'll see this autocomplete shows you HTML 5. And if you click on it, it's going to give you this whole template document. Now, for some reason, that's not working. No worries. What you can do is go ahead and pause the video and you can start typing this out. What we need is the following. We need this tag up here. Let me zoom in a little bit so it's easier to read. That says dock type HTML. And make sure you type it exactly like you see it. So you have the exclamation point dock type. You have your angle brackets here and then you have HTML. We specify the language at the top of the page. It's not necessary but it's good practice to get into. So we do again our angle bracket. HTML language is equal to en standing for English. And then we specify our head tag. Now the head tag is where we put some metadata related to the application. If you're copying this out yourself, you don't need these two tags here. You can just leave it like this. So put head. And you'll notice that we have an enclosing tag here that has this slash. So whenever we're working in HTML, you'll have an opening tag and then you'll have a closing tag. And that'll denote kind of a section where we can put some different content. So in this case, we put a title tag. So we have our title opening tag and our title closing tag. And this is the title of our web page, which will appear kind of like this in the little heading or the kind of browser tab. So in this case for project number one, this is the color flipper. So we're going to name the title color flipper. We're then going to have our body tag. Now it's important that the body tag comes after the head tag. As I said, inside of this head tag here, you have metadata related to the application. Inside of the body tag is where you're going to put the content that will live on the page. Now notice that all of this is happening inside of these HTML tags. So we have an HTML opening tag and an HTML closing tag. Inside we have the head tag and below that we have the body tag. If we add some indentation, it kind of looks like this. Okay, so just make sure you have this set up here. I know I'm spending a bit of time on this, but I just want to make sure none of you get kind of led astray right at the beginning. So it should look exactly how I have it here. The white spaces don't matter. You just want to make sure it looks just like this. Okay, now we've got this. It's time to start creating the basic user interface for our application. Now to do that, we're going to write a few tags here which will represent physical elements that will exist inside of our HTML document. So what we'll do just to start and just to test things out is we'll create an H3 tag. Now for all these tags with the exception of ones like the dock type tag, which we don't need to talk about right now, you always have your opening tag and your closing tag. And the closing tag always has a forward slash denoting the end of a section or of an element. Okay? So like the body tag has its closing body tag. The H3 tag has its closing H3 tag. Inside of here, we're going to say color flipper. Okay? Now, when I save that, we're going to get a bit of formatting. Don't worry too much about that. What I want to do now is show you how we actually open this page up so we can see where our code's actually running and what it is that we built. So, we have two options here. The first option is we can simply just doubleclick and open our HTML file. So what you'll need to do depending on your operating system is you'll need to find the folder this exists in. Now in VS Code, you can simply write click on the file and you can click reveal and finder or show an explorer. So if you're on uh Windows, there should be something that says like show an explorer or show location. And if you click that, it's going to bring up a file kind of search menu for you here and show you where the file exists. So, in this case, if we just double click it, you'll see that it will show up. And if I want, I can zoom in here by hitting Ctrl+ or just by zooming in Google Chrome. And you'll see that we've got our head uh tag appearing. And we have the title, oops, color flipper kind of showing up here. Okay, so I'll exit out of that for now. But that's the first way to open up your code. The second way is to use this live server extension. Once you've installed Liveerver, you should see this go live button down here. So, we're going to go ahead and click on it. And what that will actually do is create a little server for us that's going to run this HTML file. And now anytime I make any changes, let me just put this on the side of my screen and go like color flipper one. As long as I save this main.html file here. Very important that you save it. You'll see that it will just automatically adjust. So you can see up here we're getting color flipper one in our title. Okay. So that way we don't have to constantly keep refreshing the page. Uh if you don't have live server, you will need to refresh the page for the updates to appear. Okay. So from this point forward, we can kind of move our screen over a bit so that we can see what we're doing on the right hand side and on the lefth hand side we have our code. Okay, so we have color flipper and then we have our H3 tag here of color flipper. Now again just a reminder if you're not seeing any updates here just make sure you save the file. You can do that by hitting S or by going to file and then hitting save at the top of the screen. So we're going to now work inside of our body tag. That's where most of our work's going to be because that's where we're actually creating the different elements that appear on the screen. For now, what I want to do is create a few different buttons that are going to sit here and allow us uh to click on them essentially to change the background color of the screen. So to make a button, you simply type button like this. And then again, you're going to have your closing tag. So you have an opening tag and you have a closing tag. Then what you'll do inside of the button is you'll give a kind of name to the button or what you want the text to show as. So to start, I'll start with green. Now when I save that, you'll see that this green button appears. I'll show you how to change the color in a second, but for now, we just have the green button. So now we're going to copy this, and we're going to have a button, which is going to be the red button, and we're going to have another button, which is going to be the blue button. Okay, we're then going to add one more button. So we'll copy this down here, and we'll call this the random button. Now, I'll just make this a little bit smaller, and you'll see that now it will fit all on the screen. I just have this zoomed in a lot. For you guys, it'll probably be quite a bit smaller. I'm just zooming it in so you can read it a bit easier. Okay. So, now for all of our buttons, what we're going to want to do is actually change their background color, right? So, rather than like the green button being gray, we want it to be green. So, there's a few ways to do this, but the best way is to create some CSS or a kind of styling for this button. So, to do that, we're going to go up in the head tag now. So outside of the body, make sure we're in the head and we're going to write a set of style tags. Now the style tags is where we can specify styling properties for different elements in our HTML. Now before we're able to actually kind of apply a style to these different buttons, we need to give them something to identify them with. Now we can give them a class, we can give them an ID. There's these different identifiers that we can have for HTML elements. Right now we're going to use an ID and later on we can look at a class. So for our buttons, inside of the button tags here, we're going to say ID is equal to and then we're going to put double quotation marks. And inside the double quotation marks, we're going to specify the identifier for this button. Now, this button is going to be green. It's important that for all of your IDs, they're unique values and they're enclosed in double quotation marks. You also want to make sure you don't have any spaces or any weird characters like this or brackets, okay? You just want to have kind of a standard string or a stand standard set of characters. You can have numbers, that's fine, but you just want to have kind of a normal set of characters here. Okay, so for the ID, we're going to go with green. And then for this ID, we're going to go with red. And for this ID, we're going to go with blue. So we now have a way to identify our various buttons. Now, what we're going to do is go in the style tag and we're going to style them. Now to access uh what we want to style, we have to specify the identifier. Now the identifier for using an ID is this pound sign. So when I put this pound sign and then I put the ID I want to access. So in this case like green, I'm now accessing any element that has the ID equal to green. So what I'll now do is put a set of curly braces and inside of these curly braces I can put any styling properties that I want to apply to this button. So in this case I can simply say the background color is equal to green. Now when I do that it's going to change the background color of my button. So it's now green. Now we can go ahead and do the same thing for our other buttons. So we can say red. And then inside of here we're going to have background color red. Okay. So now we have a red button. Same thing here for our blue button. We're going to say background color and then blue. Okay. That's awesome. Now, if we want to make our buttons look just a little bit nicer, there's one more thing we can do that will actually apply a style to all of our buttons. So maybe I want to make my buttons a little bit round. I want to make them a bit bigger. Uh you know, we can do whatever we want, right? But let's say I want to make them a little bit bigger and rounder. Well, to do that, I can actually just access the tag button. And now any button is going to get this property. So I can say button and I can put two sets or I can put a set sorry of curly braces. And now anything I put in here is going to apply to any of the elements that have this button tag. So here we're using the ID as the identifier. Here we're using the tag name as the identifier. And there's tons of different ones you can use inside of CSS. It's not meant to be a CSS tutorial, but I do want to teach you this. Okay, so for our button, we're going to set a border radius. And by the way, like look how many properties there are. You don't need to memorize these. Okay, I have a few of them memorized cuz I've used them before, but you can always just look up the styling properties if you want something unique. So I'm going to go border radius, and we're going to set this to be 5 pixels. When I do that, you'll notice we get some rounding on the corners. That's what border radius does. Next, we can set say the width. So, I can say the width is 100 pixels. Make sure you have the pixels here. If you don't have the pixels, you're going to get an error. And then I'm going to set the height here of 40 pixels. Okay. Now, you'll notice the buttons are a little bit close to each other. So, what I can do is apply something known as a margin. The margin is the amount of space between the different elements. And I can say we're going to have a margin of 5 pixels. And when I do that, notice they kind of get spaced out a little bit nicer here and they're separated on the screen. Okay. So, at this point, we've got pretty much all we need for the actual user interface. What we want to do now is start working with our JavaScript, which is what this tutorial is supposed to be about. So, what we're going to do is inside of this index JavaScript file, sojs, we're going to link that to the HTML. Now, to link this file, we go into our body tag. And at the bottom of the body tag, we specify a script. Okay? And make sure again you have your closing script tag. And we say that the source for this script, which is src, is equal to index.javascript. Now, this works because this index file is directly in the same directory as our HTML file. So, we just want to make sure that this file is in the same directory so we can reference it directly. So, that means all we have to do here is just write this out. And assuming you have the name spelled correctly, just always double check your naming, it's going to link these files together. So now what we can do is we can start setting up some events so that when we click on the buttons, it does something in the JavaScript which then modifies the code. So how should we do this? Well, there's a few ways that we could kind of get started here. But the first thing I want to do is access the kind of body component. So I want to access this body element so that I can show you how we change the background color of it programmatically in JavaScript. So to do that, we're going to create a variable. Now there's two types of variables in JavaScript that we can create. We can create them using the constant keyword or const. This means it's a variable that's not going to change. We're not going to modify it later on. Or we can use the let or the var keyword. And this is going to create a dynamic variable where its value can change. Now in our case, we're not going to change this variable. So we're going to say const and then body is equal to. And now we're going to use document. Now what document is going to access is the HTML document and it's going to allow us to reference any element that exists inside of here. So in this case I want to get the whole HTML document pretty much. So to do that I'm going to say document getelement and then notice that we have a bunch of options here right we have by uh tag name by name by class name etc. We're going to use tag name because we want to get the tag name of the body element. So let me zoom out a little bit here. Okay, so we're going to say const body equals document getelements by tag name and then we're going to get the body tag. Now, what this is going to do is give us the body tag itself. However, there's a little thing we need to look at. So, what we're doing is saying get elements by tag name. Notice this plural s. Now, that means that this is actually going to return to us what's known as an array of the different elements that have this tag name. because when you're getting a tag name, there could be multiple elements that have say the button tag or the paragraph tag or other HTML tags. Now, in our case, we're getting the body tag and we know there's only going to be one of those. However, to in order for us to access that tag, we have to actually index it at index zero. The way you can think of this pretty much is that body here, like this variable, so this tag, sorry, is going to return to us a list. And this list is just going to have one element and that's going to be the body tag we want to access. Now to access the first element in the list, we simply put these square brackets and we put zero. That's the index or the kind of uh pointer. I don't know how what you want to say identifier of this element because zero is always the first element in our list. So now this variable is going to get well the first element in our list which is just the body tag. Okay, I know it's a little bit confusing for a completely beginner tutorial, but I'm trying to go nice and slow. So now what we're going to do is we're going to say bodystyle dotbackground color is equal to and then we can set this to any color we want. So I can set it to say red. Now when I do that, notice that the whole thing changes, right? The background color changes to red. The reason that happens is because once we've kind of made all these UI elements here, we've linked our script tag and inside of the script tag, what's happening now is we are getting that body uh component, that body element that I was talking about. We're then changing the style and specifically we're changing the background color to be red. Now, we can change anything else we want. There's a bunch of other properties we can modify, but in this case, we just want to do the background color. Okay, so that's working really nicely. Now the next thing that we want to do here is we want to make it so that when we click on these buttons we change the color. So to do that we're going to make a function. Now a function is just a block of code that we can call that's reusable. So I can say function. This is how you start defining one. And then I can give the function a name. In this case I'm going to call it set color. Make sure you don't have any spaces or any weird characters in your name. And then I'm going to give this something known as a parameter. Now parameter is kind of a unique value that you can pass into the function. so that it can do something different based on the value you give it. So now inside of this function, so I have these uh set of curly braces. By the way, make sure you don't forget this. You got to kind of type it exactly as I have it. What we're going to do is what we just did. We're going to say body dot style dot and this is going to be background color is equal to and then name. Now name is going to represent the name of the color that we want to set the background to. So what we've just done is made a function and when we call this function we can give it a name and whatever that name is we'll set the background color to. So I can simply go here and I can call the function. The way you call the function is you write the name of the function which is set color and then you pass to it any of the parameters that it specifies. In this case the parameter value is name. So I can just pass it say green. And when I save it you'll notice the background color goes to green. Now the thing is I can call the function multiple times. So I could say red. Now it's going to go to red because first we set it to green, then we immediately set it to red. Now if we want, we can change this and we can set it to blue. We could even go to something like purple. And you get the idea here. We're going to continue to change the background color using this function. So that's great. But the thing is I want to call this function when I press on these buttons. So how do I do that? Well, I'm going to go to my HTML and inside of my button tags here, I can actually register an event called on click. Now, what on click will do is call a JavaScript function when the button is clicked. Now, that's great for us because we have our function here that we can call. So, we're going to go on click is equal to and inside of double quotation marks here, we're going to write the name of our function exactly as we have it in the JavaScript. Now, in this case, it's set color. But remember that we have to pass a parameter which is the name of the color we want to set. So what we're going to do is put two sets of parenthesis here and make sure you put single quotation marks. Okay, the reason we're using single quotation marks is because we have double quotation marks here which is kind of uh what do you call it? Giving us the ability to write this function in whenever you're working with these properties of these HTML tags you need to kind of put them inside of double quotation marks. So in our case saying okay on click is equal double quotation marks and then inside of here we're saying set color but now we need to pass a string value to our function. So in order to do that we're now going to use single quotation marks so we don't get mixed up with double quotation marks. So we're just using singles because it does the same thing as doubles but it allows us to embed them inside of a set of double quotation marks. I know it's a little bit confusing but please just use double quotation marks here. And then for this one, we're going to say green. Okay. And now what happens is when I click this button, it's going to call this set color function with the parameter green and set the background color to green. So now all we need to do is copy this for all of our different values and change the parameter here to be the according color. So it's going to be red and blue. Okay. So now I can go red, green, blue. And I can set these colors on the screen. And the last thing that's left is to set the random color. Okay, so now to set the random color, we're going to need a different function because we're going to do something different. So we're going to say function random color. And same thing here, we're going to put a set of parentheses, but this time we don't need any parameters. We don't really care. We don't want need to pass anything to the function. It's just going to do something when we call it. And inside of here, we're going to generate a random RGB value. Now RGB stands for red, green, blue. These values go from 0 to 255. Okay? And this allows us to create pretty much any color by using a combination of red, green, and blue. If we had zero red, zero green, and zero blue, we'd have black. If we had 255, 255, 255, we have the full red, full green, and full blue. Then we would have a white. Okay? That's kind of how RGB works. So, what we're going to do is start generating three random values. A random amount of red, a random amount of green, and a random amount of blue. So, we're going to create a constant variable again because these don't need to change. We just want to create them so we can store our value. And we're going to say const red, that's the name of our variable, is equal to math with a capital M dot random. And then we're going to multiply this by 255. Now, the multiplication operator is simply the asterisk here, uh, which you can find on your keyboard above the eight if you hold shift. Now, what math.random random does is it generates a random value for us between 0 to one. So you get this kind of random um you know multi-deesimal value like an example is like 0 point you know something like this. Okay. We now take that and multiply it by 255. What that ends up giving us is some value that's between 0 and 255 because if we generate a number between 0 and 1 and then we multiply that by 255 we get a random value in the range of 0 to 255. The issue is that random value is going to be a huge, you know, decimal point value with a bunch of things. So, what we need to do is round it off. So, we're going to say math.round and then we're going to put all of this inside of here. What we're actually doing is using the rounding function. We're passing in some random value we generated. And now it's going to round it to a whole number. So, we can copy this and paste this and do the same thing for green and for blue. So now we have a random red value, random green value, and random blue value that are all in the range of 0 to 255. Now all we need to do is use those values to create a color that we set the background with. To do that, we're going to do a bit of a string manipulation. So we're going to say const color. Again, creating a new variable, and this is going to be equal to, and we're going to use back ticks. Now, you may not have seen this symbol before, but if you look at the tilda on your keyboard, which is the squiggly line typically below the escape key, or at least close to there, there's these symbols that kind of look like single quotation marks. They're not. They're called back ticks, and you're going to find those on the keyboard. Okay? You're going to put a set of back ticks. And inside of here, you're going to type RGB. You're going to put a set of parenthesis, and we're going to embed the variable red, green, and blue inside of here. Now to do that, we're going to put a dollar sign and a set of curly braces. And we're going to put red. And then we're going to repeat this for green and blue. Now what we're effectively doing here is creating a color that we'll be able to use to set the background color with. So to do that, we have to have the string RGB and then we have to have three numbers, right? The amount of red, a comma, the amount of green, a comma, and the amount of blue. That all needs to be inside of a string. So, we use this kind of neat string manipulation trick with these back ticks to embed these number variables because the data type of these variables is a number, not a string. Strings are in double quotation marks or single quotation marks. Numbers are just values like 67 or 255. And we embed them here inside of this variable. Now that we have the color, we can simply say body.style.background color. And rather than using the name of our color, we can use this RGB value. So we can say color like that. And now when we call the random color function. So let's do it down here. You'll see that we get a random color. So every time I save, you'll see we get a unique random color cuz it keeps refreshing the screen for us. Or every time you refresh, you'll get a different random color. So now what we need to do is make it so when we pass press this random button, it does that. So all we have to do here is for the random button, we just go on click is equal to random color. Make sure you put your set of parenthesis here to call the function. And when we call random, we get a random color on the screen. All right, we're moving on to project number two, which as you might recall is a palindrome checker. So we're just going to check if a string is the same forward as it is backwards. Okay, how do we do this? Well, let's begin by creating our files. So we're going to have our main.html file and we're going to have our index.js file. Now, I've already done this for project one. So, if you're confused at all, go back to project one. I'm going to go a little bit faster now than I was before. So, again, if it's too much, go back and watch project number one. We're going to start by typing HTML colon 5. And then we get our autocomplete. If that doesn't work for you, go to project one and you can just copy the HTML and you can remove what you don't need or you can pause the video and you can type this out. You don't need these. You can remove those uh from the screen. I'm going to zoom in a bit so it's a little bit easier to read. Okay. So now we're just going to change the title of our document. So rather than having this, we're going to have palindrome checker. And for the interface for this one is going to be quite simple. We just want to have a title that says pal and drum checker. And then we want to have the ability for someone to type into a little box and then to press a button to check their string. So we're going to start inside of our body by having an H1 tag and we'll just say pal in drrome checker like that. And what we can do if we'd like here is we can rerun the live server which will give us access uh to view this code as we're writing it. So what you'll notice here is that if you look at the bottom right hand side of the screen you'll see this thing that says port 5500. If that doesn't work you can also just type live server. The way I open this by the way I know I went a bit faster is I hit control shift and the character P on my keyboard. This opens the command pallet in VS Code. So it's either command shiftp or control shiftp depending on your operating system. and I typed live server. When you do that, you'll see you have open with live server and stop live server. So, first I'm going to stop the live server because I had that running before. So, you saw that stopped it. I also could have just pressed the button down here. And now, if I click on go live or again I have control shiftp and then I go live server and then open with live server, it's going to open up that HTML document which you saw right here. So, what we'll do is we'll just leave this on the right hand side of our screen. We'll move this over to the left uh so that we can kind of see what we are doing as we write the code. Now let's make this a little bit smaller so that we can actually see the full title. Okay, so now we have our title. The next thing we want to do is create an input box as well as a button for the user to type in. So in order to get an input box in HTML, you simply type input. Now this is what's known as a self-encclosing tag. Meaning you can simply type a forward slash and the closing angle bracket like this. You don't need to type like slashinput like we had before. In fact, that won't work if you do that. And here for the input, we're going to specify the type of the input, which is going to be text. And we can give this a placeholder. And we can say type something. Okay. Let's make this a little bit smaller. So now you'll see a little input box pops up here and I can type inside of this. That's the basic uh HTML tag. You can also use this for numbers, dates, all kinds of stuff. Now, as well as the input button or input box, sorry, we just want to have a button that you can click on. So, we're going to say button. And then for the button, this is going to say check. You'll notice a button appears. And now, nothing's happening cuz we don't have this linked up, but you could click on the button. Okay. Lastly, we're going to link this to our HTML or to our JavaScript, sorry. To do that, we're going to create a script tag at the very bottom of the body of our HTML document. Then, we're going to say source is equal to index.js. js. Again, recognizing that this only works because the index.js file is inside the same directory as our main.html file. Okay, so make sure you have that set up. All right, now we're just going to give an ID to our input. The reason for that is I need a way to actually get what the user typed into the input box. There's some other ways to do it, but the cleanest way is to simply give this an identifier. So we're going to say id is equal to you can call this whatever you want but I will just call this the input. Okay again don't use any special characters just use kind of a normal string like this. Okay so that's pretty much it for our HTML. We've got our very simple interface here. And now what we want to do is start writing in our JavaScript. So let's open up our JavaScript file and we'll do the rest of the work from here other than a few small things we'll add in the HTML. Okay, first thing we need to do is figure out how we can get what the user has typed in this box because before I can check if it's a palenrome, well, I need to know what it is that they typed, right? So to do that, we're going to say const input. We're declaring a constant variable, one that's not going to change, and this is going to be equal to document.getelement by id. Now, what this allows us to do is get one element by its identifier, right? which is the ID that we set. Now, in this case, the ID is input. So, what I do is I put input inside of double quotation marks. Just to quickly show you, we have ID equals input. If it was input one, we would go here and we would change this to input one. Okay? I know it's confusing cuz I did the same thing, but just it's the ID. Okay? It's not the name of the tag, it's the ID. We're doing it differently this time than we did in the first um project. Okay. So, now we've got the element. When we have the element, it gives us access to this whole input box. So we could change the styling. We could clear what's inside of it. We can also get what's inside of it, but that's not what this does. This just gives us the whole tag or the whole element itself. And then if we want to get the value that's different. So let's write a function here called check. Okay. And inside of this function, all we're going to do is we're just going to output what the value is. So to do that, we'll say const value is equal to input dot, you guessed it, value. Now, you might notice that I'm putting these um semicolons. You don't need them in JavaScript, but they're what's known as a line terminator. This just means we're ending the current line and then moving to the next one. Again, you don't need them. Like, it's fine if you don't have them, but if you see me add one, it's just out of habit. Anyways, what this does is give us the value of the text input. So now if I'd like I can use something known as an alert. An alert is a message that will pop up in the browser and I can simply alert the value. So now all we need to do is make it so that when we hit check here we call this function and it will tell us what the value is. So to do that we go to our button here and we say on click is equal to check with two sets of parenthesis. Okay or sorry one set of parenthesis because we have the opening and we have the closing. So now when we click this button, it calls the check function. The check function gets the value of the text input and pops it up on the screen. Let's test it with test. Click on this and notice it shows us in the alert box test. Okay, so now we know how to get the value. Now what we need to do is figure out how to determine if this is a palendrome. Now recall that a palendrome is simply something spelled the same forwards as backwards. So if we have dad, that's a palendrome. If we have dog, not a palendrome. Okay, so how do we check this? Well, there's a bunch of ways, and I challenge you at this point, if you know some basic JavaScript, try to see if you can figure this out. But I'm going to walk you through it. Now, the easiest way to do this is for us to simply reverse the string and then just compare it to the original string and see if they're the same. So, what I mean by that is, okay, we have the string dad, so let's now reverse it. Well, that gives us dad. We're going to check if they're the same. They are the same, so they're a palrum. Whereas if we have something like dog and we reverse this, we're going to get god. Well, these are not the same. Okay, so it's not a palandra. So now we got to figure out, okay, how do we reverse string? Now I'm going to show you a fancy way to do this and then we can go through a manual method as well. So I'm going to write a function called reverse string. Now this is going to have the parameter str. This is a value that will get give us input to the function. A function is simply a reusable block of code that you can call as many times as you want. So what we're going to do is we are going to first take this string. So a string is anything again in double or single quotation marks and we're going to convert this into a list or to an array. Now an array is a collection of elements that are ordered. So we can have an array that has the values like this. Okay. Now the way you access the elements in an array are by using its position or its index. The first position in the array is always the zeroith index. We always start counting at zero in programming. So here this is position zero or index zero. This is index one. Index two. Oops. Let's go here. Index 3 and index 4. Okay. Now, the interesting thing with arrays is there's all kinds of what's known as methods, which are essentially operations or functions that we can call on the array that can manipulate them. So, what we can do is we can take our string, which is a different type, right? It's just a set of text essentially. We can convert it into an array. We can then reverse the array and then we can take the array and turn it back into a string. It's not the most optimal way to do this, but it is a way uh that we can kind of do this in a single line. And I'm going to show you those operations. So, what we can do is we can say return str.split. Now, what dossplit does is it takes a string. Again, anything in double or single quotation marks, and it splits it based on what's known as the delimiter, which is the value that we specify here. Now, often times you would use this split operation to take a string and maybe get all of the words that exist. To do that, you would have a delimiter of a space. And that means that we're going to look for all the spaces. And as soon as we see one, we're going to take whatever's on the left side and whatever's on the right side, and we're going to add those as unique elements into an array. So, if we were to split on hello world, and we used the delimiter of a space, it would give us hello and world in an array. So now we have all of the words like that are in a sentence. Right? Now if we split on an empty string, all that means is take every single character and put it into an array. So in the case where we have hello, it just turns that into an array that has those five characters. So we're going to split. Now after we split, we're going to reverse. Now notice I'm using this dot notation. You can use this on certain data types and it's like calling a function on that thing. So we're calling split on the string. Then we take all of this and we call reverse on it. So we're now reversing the array. Now that we've reversed the array, that's going to give us the reversed array. So in the case of dog, right, that would give us G, O, and D. And what we want to do is we want to compare this to the original input. But remember the original input is simply the string dog, right? In in this example that I'm using. So what we need to do is need to now take this array and we got to convert this into the string version of it that looks like this. How do we do that? Well, there's another method we can use which is join. And what do join does is it takes all of the different elements that are in our array and it combines them together into a string with a separator or a delimiter. Now in this case, if we use the empty string delimiter, we just get all of the characters smooshed together. Join is kind of the opposite thing of splitting, right? It's taking the array elements and turning it into a string. Whereas splitting is taking the string elements and turning it into an array. If I were to join with a space, then we would get this. But when I join with the empty string, we just get the string. Okay, so that was my long explanation of how these methods work. Again, I'm trying to be really thorough, especially with the beginner projects. Let me know what you think of this in the comments. Okay, so we have reverse string. So now we can reverse a string. So now let's just do a test and let's say okay const reverse is equal to reverse string of value. All right. So what we're doing now is we're calling the reverse string function. We're passing in the original value. We're now returning a re reversed version of that. So now let's simply alert reverse. Okay. Now let's go here and go hello. And notice we get the reversed version. Now, I need to make sure I remove the space here because you can see it's kind of spaced out. So, let's run this again. Again, every time when I save this, it's going to automatically update. So, just make sure you're saving it. And you see we get it reversed. Okay. So, now that we have it reversed, we're just going to check if it's the same as the original. So, to do that, we're going to make an if statement. An if statement allows us to check a condition. A condition is something that evaluates uh to true or to false. And the way that we can do this condition is we can say value equals equals. So two equal signs to reverse. Now it's actually best practice to do three equal signs. I don't really want to get into all of that in this second, but either two or three equal signs doesn't matter for this example. And what this will do is it will compare these two values for equality. It's going to check, are these the same? That's what happens when you use multiple equal signs. Don't think you can use like four or five equal signs. It's just two or three. They have different meanings. But in our instance, they'll do the same thing. So we're going to use three here. We're going to say if value is triple equal to reverse, then inside of a set of curly braces, we're going to alert and we'll say pal in drum like that. Okay, I'm just making it a little bit excessive. So that's if this is the case, then we go inside of these curly braces and we do this. We have an alert. Otherwise, which is where this else statement comes in. So, we're going to put an else and we're going to put a set of curly braces. We're going to alert and we're going to say not today exclamation point. Okay, so that's it. Um, this is a basic check. If statement again, you have some condition. In this case, we're checking if these things are the same. This is going to give us either the true or false value. If they're the same, it's going to give us true. And if this thing is true, we do this. Otherwise, we do this, right? That's all how this works. So, if I go here now and I type dog, we get not today. But if I type madame, I get palindrome. Okay. So, now the thing is you might be noticed when I click this, it keeps this input here. I don't really want that. It's going to be a little bit better if I actually remove this input after I press this button. So, I can do that by simply going here and saying input. remember that's this variable here dot value is equal to an empty string. So rather than um getting the value, we're actually setting the value here. So I'm setting the value to an empty string. So now you'll notice if I type hello and I click on check, it says not today and then it gets removed, right? We changed the value to be nothing. This is just clearing the value from the input field. So now we are moving on to project number three which is our random quote generator. Let me first stop the live server here. So this is going to stop and let's make a new folder here called three. And let's go in here and make our file. So main.html and index.js. I'm going to go a little bit faster. Again we're just going to progressively pick up the pace. If you're getting confused, go back to the previous project because that's where I really break it down in more detail. Okay. So for main.html, we have a random quote generator. We're going to begin by setting up our HTML document. So we can type HTML col 5 and hit enter. Let's remove this so we can view it more. Again, if that doesn't work for you, then you can simply pause the video and type this out or you can go and copy some of the other projects. Also, this code will be available on GitHub in case you want to copy it. You don't need this, so you can remove that if you want, although you can also keep it. And for the title, we're going to change this to be the random quote generator. Now, I'm going to copy this and we're going to create a header tag here inside of our body. So, we're going to say h1 random quote generator. And now, we just need to simply make the interface. Now, for the interface, we're simply going to have a paragraph tag, which is this p tag just for some standard text. We're going to say the ID is the quote just so we have a way to identify this tag. And this is where we're actually going to put what the random quote is. So when we generate it from JavaScript, we're going to populate this paragraph tag with it. Now we're going to create a button. Now for this button, we're just going to say generate quote. And inside of the button properties, we're going to say on click is equal to and we're going to call a function called generate quote with our double parenthesis like this. Again, if it's confusing, please go back to the other video. I already explained how all of this stuff works. Now, we haven't yet written this function in JavaScript. We're going to write it in a second. So, now all we need to do for this interface is we need to make our script tag. So, we're going to say script at the bottom of the body. Make sure it's at the bottom. Source is equal to index.js. Keeping in mind this only works because index.js is in the same directory as our main file. Okay, that's the HTML. Let's go live again this time. And now you can see that we have this generate quote random quote generator. When we click this, nothing happens. That's fine. Okay. Quick thing. By the way, at this point, I guess I'll show you that if you're on Chrome, if you rightclick and click inspect, it's going to bring open this kind of developer view. If you click on console, you can see any errors that might be happening. So, if you're getting some issues, you can see in the console what's going wrong. I should have showed that earlier, but I'm I guess we didn't have any mistakes yet. Uh, so if I refresh, you see it gets cleared. And now, if I press this button, it's telling us, oh, uncaught reference error because we haven't defined this function. Okay, just wanted to quickly show that to you. Anyways, let's now go into index.js. We're pretty much done with the HTML and let's write our random quote generator. So, first things first, we need some quotes. Now, I'm just going to copy in a bunch of these. You guys can kind of find your own quotes. You can write them or you can just stop and you can write these out or you can go to the link in the description. There'll be a GitHub link where this finished project code is and you can just download all of these quotes or kind of copy and paste the text and paste it in. just to get started. If you want to just test this, you can just have quotes that are like 1, two, 3, whatever. Okay, something super simple. Now, what we're doing is we're putting this inside of an array. Now, remember I was talking about an array in the previous project where this is an ordered collection of elements where each one of these quotes here, even though they're quite long, they have an index or a number that allows us to access them. So, this is index zero, this is index one, this is index 2, index 3, index 4, etc. And that's how we'll grab our different quotes from our kind of collection of quotes here. So what I'm going to do is create a new data structure that we haven't seen yet with a variable called used indexes. Now this is going to be equal to a new we're going to use this new keyword which I'll discuss in a second set. Now let's quickly discuss a set. So a set in JavaScript is a unique collection of elements. Now the set typically is denoted with the curly braces although in JavaScript doesn't really have that type of notation and inside the set you can only have values that are unique. So I could have like 1 3 four but I can't have two ones. Okay, you just have a single instance. So the set doesn't keep track of order. It doesn't keep track of quantity. It just tells you if you have something or if you don't have something. So, we know, okay, yeah, four exists in the set, and we know that five does not exist in the set. That's all a set is used for. Now, you might be saying, well, Tim, can't I just use an array for that with all these elements? You can, but the thing with a set is it's actually more performance. So, it's a faster data structure when all you care about is if an element exists or if it doesn't exist. In our case, when we're going to be generating these quotes, what we're going to do is we're going to put the index of quotes that we've already used inside of the set so that we can check really quickly if we've already used that quote or not. So that way we don't recycle the same quotes until we've gone through all of them. That's what makes this project a little bit more complex. We're introducing this set. Now, in this case, I use this new keyword. Now, you have to use this with some certain data structures in Python. Essentially, what we're doing here is we're creating a new instance of the set class. You don't have to worry about all that terminology. It doesn't matter that much for a beginner, but it's just a bit different than creating something like an array where you can just define it like this. Okay, so for the set and for some other data structures, you need to actually use the new keyword. So, I'm saying, okay, we're making a new set. All right, that's it. So, now we have the two variables, quotes and sets. What we want to do now is we want to populate the paragraph tag with a quote. So we'll begin by simply randomly picking a quote and then we'll start using this set to make sure that we're not recycling the same quotes. So we're going to say function generate quote. Okay. Now inside of here the first thing we've got to do is we've got to get access to that paragraph tag. So this one right here. So that we can set its value. Now what I'll do is I'll create another variable here. I'll say const uh and this can be quote tag is equal to document dot getelement by id and the ID of this I believe is simply quote we can go back and reference that and you see yes it is quote okay so what we're doing is we're just grabbing access to that paragraph tag right now you don't see it because there's no text in it but when we start using it it will be I'm actually just going to call this quote element so it's a little bit more clear. Okay. Inside of here, if we want to set the text of this paragraph tag, we can simply say quote element dot and we have a few options, but the option I'm going to use here is inner HTML with all capitals for HTML. What this does is set what's in between the opening and the closing tag. You can use this on other tags as well, but for us, we'll just use inner HTML. And we can just make this equal to like hello world for now just to test it out. So when I press this now, you should see that hello world appears in the tag. If I refresh and press it again, you see that we're populating the inside of the HTML of that paragraph tag with hello world. Okay, so that's kind of what we're going to use to actually set the quote. So now what we've got to do is we got to randomly pick an index inside of our quotes array, select that quote, and then populate it inside of the paragraph tag. Now, we've already kind of done this, but let's do it again. We're going to say const random idx is equal to math dot floor. And then inside of here, we're going to say math.random. And we're going to multiply this by the quotes.length. Okay, so we just used a few new pieces of syntax. Let's quickly talk about this. Math.random, as we saw before, randomly generates a value between 0 and one. Now what we're doing is we're multiplying that by the length of our quotes. So you can use this.length property tells you how many elements are inside of the array and that's going to give us now a random value that's between zero and whatever the length of the quotes are. In this case I think we have like 10 quotes or nine quotes or something like that. Okay. Now what I'm doing is I'm saying math.f floor. Now what floor will do is always round down. The reason I'm always going to round down is because the length of the quotes is actually going to be one index beyond what we can access. So let's say here, I don't know how many this actually is, but let's say we have 10 quotes. Okay, if we have 10 quotes, this last quote has an index of nine, right? Not 10, nine. So if I try to access quotes at index 10, we're going to get an error. It's going to tell us that this index doesn't exist. So what I'm doing is I'm saying okay well we'll generate a random number between and this is going to be 0 and one and multiply it by the quotes.length. The thing is it's never going to actually be one. The most it will be is like 0.9999999999 whatever. Right? So when we take that and we multiply it by quotes.length we might end up getting something like 9.999999. Okay. If that's the case we simply take that value and we round it down to 9. And now we're getting the last quote as opposed to if we were just to round it, it would round up to 10 and then we'd be trying to access an index that doesn't exist. Okay, so that's why I'm using floor. There's also a seal that will round it up. Also, not sure if you guys can hear the supercar behind me, but I'm currently in Dubai and that has proven to be a bit of an issue that there's too many Ferraris and Lamborghinis driving around. So, kind of a fun fact, but uh yeah, that's where I'm recording. And if you heard that, well, there you go. Sorry, not much I could do about it. Okay, so we have random index. Now that we have the random index, we're going to use that to get one of our quotes. Okay, so to do that, we're going to say const quote is equal to and this is going to be quotes and this is going to be at index random index. Okay, so we've generated a random index. We've now used that to access the quote in our array. And can you guess what's next? Well, we're going to populate the paragraph tag. So we're going to say the quoteelement.in inner html is equal to the quote. Okay, so now let's run this and it see it starts giving us random quotes. However, you'll see that sometimes we'll get the same quotes and like pretty um close together because we don't have that other component that we're going to implement now. Okay, so let's make this a little bit larger. All right. Now, what we want to do is we want to make sure we're not using the same quotes. So to do that, we're going to keep generating a new random quote or a new random index until we haven't yet used that. So to do that, we're going to make a while loop and we're going to say while true. Okay? And then we're inside of curly braces here. We're going to take all of this and we're going to paste it here. Now what we're going to do is we're going to generate this random index. And we're first going to check and make sure that we haven't used it yet. So we're going to go here and we're going to say if the used indexes do has Okay, so this is how you check if the set has a value. We're going to say if it has the random index that we just generated, then what we're going to do is use this continue keyword. Now notice that I didn't actually have to write the um what do you call it? parenthesis here or these curly braces. The reason for that is because if you only have one thing you want to do with an if statement, you can just write it directly to the right or directly below the if state uh definition. You might not have known that in JavaScript, but it's kind of a nice shorthand syntax. Anyways, what I'm saying is, okay, if the used indexes has this random index, it means we've used this quote before. So, we're just going to continue. And what continue will do is simply bring us to the top of this loop. Now, this loop is going to continue looping while this condition is true. So I say while true. So while this is true, it's always going to be true. We keep going through here. And then if this is the case, we're going to continue. So it's going to bring us up to the top of this loop. Now you might be asking, well, doesn't that mean we're never going to exit the loop? Well, as of right now, yes. However, I'm going to show you how we can do that. So if we are in a position where this does not have the random index, what will happen is we won't continue, which means we're going to continue down to these lines. kind of a weird way to say that, but will essentially advance to these lines if this condition is not true, which then means down here I can say break and what break will do is break me out of this while loop. So as soon as the break keyword is encountered, you simply go to wherever the while loop is finished and you just continue there. That that's all that does. Okay? So it just gets you out of the loop. If you have while true, you're going to need a break to make sure you don't have an infinite loop. Now the last thing we need to remember to do is to add the index we used to that set so we keep track of it. So we're going to say used indexes add and we are going to add the random index. So what that's now doing is adding that to the set and telling us okay next time you try to generate a random index don't use this one because we just used it before. All right we're almost finished with one more thing but I want to just show you that this is working. So if we run through here it's still functioning. However, if we do this enough times, you're going to see that we'll actually get an error and no more quotes will be generated. Notice no more generated. The reason why that's happening is because we've run out of quotes that we can pick from. And right now the browser, if I refresh, you'll see it's actually in an infinite loop. So, I need to close this out. Uh, the reason it's an infinite loop is because of something we implemented that I'm going to fix for us in a second. So, let's just go live again and we'll see if we can figure out what's going wrong here. Okay. So, let's have a look at this code. And before I kind of answer the question here, try to ask yourself or try to figure out, let's zoom out a bit. Why did I just get that error where my browser was kind of frozen? Like it wasn't generating any more quotes. Pause the video if you want to try to figure it out. I'm going to go into the answer now. So, you'll notice what happens here is we have this while loop. We say while true, we generate this random index. We then check, okay, well, does it exist inside of the set? If it does exist, we're just going to try again. So, we could be trying quite a few times, but eventually we're going to get an index that does not exist in the set, right? So, then what happens is we will advance down here and we're going to grab the quote, set it, and then add it to the set. Now, at some point in time, what will happen is we will have exhausted all of the available indexes and we will have used all of them. So, what will then continue happening is we're going to be in this while loop. We're going to try to generate a random value. will do that. But no matter which one we generate, it's always going to be inside of the set, which means we're just going to continue doing this portion right here a ton, right? That's what's going to happen. So, how do we avoid that? Well, the way we avoid that is right here before we go in the while loop, we make sure we do actually have a quote that we can pick from. So, to do that, we can say if the used indexes do size, for a set, you use size. for an array you use length. We're going to say if that's greater than or equal to the quotes.length, what that tells me is that we've used all of the quotes, right? If the number of elements which are all unique inside of the used indexes is equal to the length of my quotes, that means we've used all of them. So what what do we do? Well, we simply reset and we say used indexes doclear. Now, doc clear will simply remove all of the values from the set which now kind of sets this back at the beginning state and allows us to continually keep generating uh new quotes but now kind of right back from the beginning. So now all of the quotes are available and we go through the exact same thing again once we use all of them. Then we can start to recycle them. So this way you're only ever going to see the same quote uh in the number of quotes which is equal to the number of uh quotes that exist here. I know that's a bit of a mouthful but that's kind of how this works. So now if we start generating them, you'll see that we're never going to get the same quote until we've exhausted all of them. And then we'll get a random one. And then same thing, we won't get the same quote again until we've used all the other ones that exist. All right, we are continuing project number four. Let's make a directory and let's make our two files main.html and index.js. Now for HTML, you already know the drill if you watch the previous projects. We're going to go a bit faster. html col 5. That is going to create for us this kind of template HTML file. You do not need these two. If for some reason that shortcut does not work, you can simply type out what I have here. Let me zoom in a little bit. Let's set the document title. This is going to be our timer/s stopwatch. It's actually really more of a stopwatch. So, let's call it a stopwatch. Okay. And inside of our body tag, let's give an H3 that says stopwatch. And now let's run our live server. We're going to dispose of the old one and we're going to rerun this new one. And you're going to see that stopwatch appears in our browser. Okay, so we've got the basic setup. What we're going to do for the stopwatch is we're going to have some functionality that allows us to start, stop, and reset a timer that will appear on our screen. Now, I just want to be clear. I'm going again a bit faster in this one. If it's too fast for you or too complicated, go back and watch some of the previous projects because I'm much slower in project 1, 2, and three. But as we go through, I assume you've watched those or you're already experienced enough that I don't need to explain like the really, really basic stuff. Okay, so now that we have stopwatch, what I need to do is start setting up the user interface. Now, for the interface, we are going to have something that shows us the time. Then we're going to have three buttons, start, stop, and reset. So, let's begin with the time. I'm going to put this in an H1 tag. We're going to give this an ID of time and we're going to start with 0 0 0. Okay, so this is just showing us the minutes and seconds. We can do with hours if we want, but for now we'll just do minute seconds. And you'll see how you can adjust this to go as, you know, long as you want. Now, we're going to have our buttons. For our buttons, we're going to have on click. For our on click, we're going to call a few functions, which we will then write in the JavaScript, which will handle when we press these buttons essentially. So, right now they're not written yet, but we'll write them in a second. So, the first one's going to be start clock. And then inside of the button, we're going to have start. Okay, let's copy this and paste it twice. And just adjust these now to be stop and reset. Okay, so now rather than start clock, it's going to be stop clock. And rather than start clock, it's going to be reset clock. Okay, so we've got three different functions that we're going to need to write. Start, stop, reset. Now we need to link our JavaScript. So we're going to say script source is equal to index javaScript. And that's all we need. That is our HTML. So now you see we have start, stop, and reset. We have our 00. We have our stopwatch heading. And now we can go into index.js and we can do the fun stuff which is the JavaScript. Okay. So for our JavaScript, we need those functions. So let's start by stubbing those functions out. When I say stub, that just means you write the function, but you don't actually write the logic for it. Okay? So, we're going to say function start clock. We're going to say function stop clock. We're going to say function reset clock. Okay. So, now we have our three functions that we're going to need to write in a second. Now, before we go any further, there's a few variables that we're going to need here. and I'll talk about how we'll actually do this timing component which involves using something known as a set interval. Now, first we need to keep track of how many seconds have elapsed. Okay, so we're just going to track how many seconds have elapsed since we started the clock. And then if we stop the clock, we'll just stop counting the seconds pretty much. And if we reset, we'll reset them, right? Otherwise, we'll just keep adding one to it every second, which will allow us to well have a stopwatch. So, let's begin by having our variable. And we're going to call this seconds elapsed. Okay. Now, this is going to be equal to zero because when we start the clock, well, 0 seconds have been elapsed. And until you start it, well, 0 seconds have elapsed, right? We're then going to have something known as the interval. Now, for now, we're going to set this equal to null, which just means we're kind of defining a variable. We're saying, okay, we're going to change this later, but for now, we're going to make it null. Null just kind of means nothing, empty, right? Undefined. I mean, it's a different value, but in this case, null is fine. Okay, so we're saying second elapsed and notice we're using a let. When we use let that means that we can actually change this value later on as opposed to if we had const then we wouldn't be able to change it. Okay. Now we're going to grab the actual time uh kind of paragraph tag here or header tag so that we're able to modify it later. So we're going to say con time is equal to document.getelement by id. The idea of this was time and this is okay to be a constant because this doesn't change just what's inside of it will change. Nice. So now what we need to do is figure out well what are we doing when we're starting the clock stopping the clock etc. So to start the clock we'll go in here and we'll start writing this. We need to create an interval. Now an interval is something that can run at any predefined kind of period of time. So every second, every 2 seconds, every hour, every 10 minutes, whatever you want. Okay, you can specify the time in milliseconds, which I'll show you. And what it will do is call a function whenever that increment hits. So every,000 milliseconds or 1 second, we will increment the clock, right? So we'll say second elapsed plus equals 1. So to do this, we're going to say interval is equal to set interval. This is a function that's built into JavaScript. So you can just write set interval. And then what we do is we call a function which we'll write here in a second. And we put the number of milliseconds that we want to call this function in between. So in this case I'm putting a,000. And now we need a function to call. So we're going to make a function. We're going to say function timer like this. Okay. And inside of timer all we're going to do is say second elapsed plus+. Now plus simply means add one. That's all it means. It's equivalent to plus equal one. It's equivalent to this equals second elapse + one. Okay, so we have second elapse plus++. And now what we do is we put timer just the name of the function. Notice I don't call the function. I just put the name of the function here as the first argument to the set interval function. So, what's going to happen now is when we start the clock, we're going to set this variable interval to be equal to the set interval, which calls this timer function every 1,000 milliseconds or every second. The thing is, if I do this now, if I refresh and I run and I click start, you'll notice that nothing's actually happening because we're not updating this. So, what we need to do now is we need to update this every time we change the value of our timer or of the second elapsed. Okay? So to do that, we're going to make another function and we're going to call this set time. Now the set time function is simply going to be responsible for telling us how many seconds have elapsed and updating this value right here. So all we can do in here just to keep this super simple for now is we'll say time inner HTML. So let's go here is equal to and then this is just going to be time. Okay, or sorry not time this is going to be seconds elapsed. And now inside of the timer after we increment the seconds we're going to call the set time function. So what happens now is okay we have the interval. Every second we call timer. It adds one to the number of seconds. We then call set time. Time goes here and it then changes this text to be equal to the number of seconds. You're going to see what happens. But let's run this out. And you'll notice that it starts simply counting up, right? 1 2 3 4 5. However, what will happen if we let this run long enough is going to start giving us 61, 62, 63. And it doesn't really look like that kind of stopwatch we're looking for. We want it to be in that hour or in that minute notation. And also, these buttons obviously don't work. And when I click start again, you'll notice it starts counting even faster because we now have multiple intervals that are running. So, we got to fix all of that. I'm going to show you how that works. Okay, so first things first, let's make it so that when we adjust this, it actually looks proper. How do we do that? Well, we need to determine first of all based on how many seconds have elapsed, how many minutes have elapsed and then how many seconds have elapsed. So to determine the number of minutes, we simply need to take the number of seconds. We need to divide it by 60 and we got to figure out the even division of that. Right? So we don't want something like 2.3. We just want 2 minutes and then the remainder we'll have as our seconds. So we're going to say const minutes is equal to and this is going to be second elapsed / 60. However, again, we don't want to have a decimal value, which we're going to get, right? So, we want to put math.f floor. Now, we're not rounding. We're flooring, meaning we're going down to the nearest whole number because even if we have something like 1.9999 minutes, we don't actually have 1.99 minutes. We have 1 minute and 59 seconds, right? Or whatever the remainder value is, which is what we'll calculate next. So, we always round down. So next we're going to have const seconds. Now the number of seconds is simply equal to the second elapsed mod 60. Now the modulus operator is the remainder operator. This is the percent sign. What this will do is give you the remainder after division by 60. So if we had something like 61 mod 60 it gives us 1. 62 mod 60 gives us 2. 59 mod 60 gives us 59 because you cannot divide 59 by 60 evenly. So you get 59 as a remainder. Okay. So now we have the number of minutes and number of seconds. What we need to do is format this into a nicely padded string that will appear here. So right now naively you might say, ""Okay, well Tim, I remember you showed me this back tick trick."" If you look at the tilda on your keyboard, which is the squiggly line, it should be on the same key as that. Back ticks kind of look like single quotation marks, but they aren't. They're typically in the top leftand corner of your keyboard. What you can do is put a dollar sign and then two curly braces like this or an open and closing one. And you can put minutes colon and then we can do the same thing here with seconds. Okay, so we do minute colon seconds. And what this is going to do now is take these numeric values and embed them inside of a string with a colon separating them when we call this set time function. So now we're not quite done, but watch what happens if I click start. You'll see we get 01 02 03. Again, still doesn't look great. We need that leading and trailing zero, which I'm going to show you how to get, but this is a decent start. And now again, if we were to have this go up to 60, you'd see that it would start showing us the minutes. Now, to prove that, let's just make this 61. And let's go with start. And then notice you get 1 minute 3 seconds, 1 minute, 4 seconds, etc. Okay, let's make that back to zero. All right, now that we've got this, we got to pad our values. So padding the values simply means, okay, well, we're going to look at the values, and if they're not two digits, then we're just going to add a leading zero, right? So if it's less than nine, pretty much add a leading zero. We can do this in a function. So didn't mean to do that, but I'm going to say function pad start. This takes in a value. And what we're going to do is actually return something from this function. This just means we get a value back when we call it. So we're going to say return. We're going to take our number because that's what's going to be passed inside of here. And we're going to convert this to a string. when we convert it to the string that allows us to use this method called pad start and for pad start we specify how many characters we would like the string to be in this case I would like the string to be two characters so I put two and then we put the character we would like to pad the string with so now what happens is we take the numeric value convert it to a string and we pad it with a leading zero if it is not two digits long hopefully that makes sense so now for minutes and seconds we can simply just call these with pad start and that's going to return to us a string that has those padded zeros. So we're going to say pad start like that. So we're taking this as a value passing this into the function. It's then returning to us a value that we will bed embed sorry inside of here in the string. So if we go ahead and we can refresh this and we start you'll see now that we get a stopwatch that's a little bit more familiar and what we're actually looking for. Now, the next thing we should look at at this point is what happens when you press start multiple times because you'll notice if I click it, it's just counting up really, really fast because it keeps making these new set intervals. Now, that's not what we want. What we would like to do instead is essentially clear the previous interval if we click start again. And we want to also reset the timer. So, what we'll do is we'll say, okay, well, if we had this clock, right? So if we've already started it, so we're going to say if interval, then we're just going to reset the clock and we'll write the reset clock function. So sorry, let me just scroll down here. What I'm doing is I'm checking before I make this new interval. I say, okay, well, if the interval exists, reset the clock. Resetting the clock should reset everything for us. And then we will just redefine the interval here. Okay, that's pretty much all it's doing. Inside of the reset clock, what we're going to do is we're going to stop the clock. We're going to set the seconds elapsed equal to zero. And then we're going to set the time just so that it shows us 0 0 again. And then inside of the stop clock, we're going to say clear interval. And we're going to clear this interval. Now, I have some chaining of functions. That's actually intentional because I want to show that to you in this project. It's a bit of a learning thing, but you can see that what I'm doing again, if the interval, reset the clock. So now we go to this function. Inside of this function, when we reset the clock, the first thing we got to do is stop the clock. So when I click stop the clock, I clear the interval. Now when I clear the interval, all that does is just stop counting. Okay? It doesn't change what's like being appeared here. It just stops making this go up by one every time. So that's what stopping does. Now, after I stop, I now reset the second elapse to be zero. So, that's resetting the clock value. And then I set the time. And the reason I set the time is so that we see that we've actually reset the clock back to zero. Okay? Cuz if you don't call this, you're not going to see the update on the screen cuz that's what's updating the screen. So now, if we just press stop clock, it doesn't actually show us anything different on the screen, right? It still stays at like seven or 8 seconds or whatever is appearing. It just cleared the interval. Which now means if we start the timer again, it doesn't reset. It just starts to count. So let's look at this. If I click start, starts counting. So I click stop, doesn't reset, just stops counting. I click start, then it starts counting from the beginning. Now, actually, that gives me reason to want to do something else. So let's remove inside of start clock if interval reset clock and instead of that for start let's actually just clear the interval interval. So we can actually say h how do I want to do this here? Yeah, I'll say if interval stop clock and then I'll just make the interval again. Now, I know this seems a little bit weird. I'm going to explain this, but this is actually something I just caught while I was doing it. So, I'm starting. Okay, I'm stopping. And when I start, it starts counting again. Okay, so the reason I did what I just did there is I don't want when I click start for it to reset and then start counting. I just want it to resume what it's at. and I only want the reset button to reset it back. So, what I did instead is I said, ""Okay, well, if an interval already exists, let's remove that interval."" So, we're saying clear interval and then we'll just set it again. That way, we never have like 2 3 four five intervals going at the same time. We've just removed the previous one and then we've reset it. So, we've just kind of continued it on. That's what I'm doing when I'm start the clock. So, whether I'm starting at zero or whether I'm starting with an interval already, it doesn't matter, right? We just keep counting. So if you press start when it's already started, then it just keeps going. Now when I click on stop again, it's going to stop. If I click on start, it will start. I click reset, brings me back to zero. I can start and I can reset while I'm started. And you guys get the idea. Okay, so let us now move on to project number five. Now, this is the most advanced project by far. I'd probably classify this more an intermediate project, but if you've made it through all the other ones, then this one is kind of a natural stepping stone. So, I think you'll still be able to follow along with it quite fine. I just want to be clear that I'm going to go again even faster. So, make sure you watch the other projects if you haven't because anything I explained there, I'm not really going to recover here. So, let's begin by making a folder for project 5. And inside of here, let's call this main.html. And let's make another file. and this will be index.javascript. So we've got two files, main.html, index.js. We're going to set up our HTML boilerplate. At this point, I think you've heard me say this many times, so I don't need to repeat myself. Just get the HTML up and running. For the name, we are going to call this the to-do list. Remember, this is the persistent to-do list, which will remember the items that we had. We're going to stop the live server from our previous project and we're going to restart it for this one, which will open a blank browser tab. Now, inside of our body, we're going to link our script. We'll just do this first and we'll say source is equal to index.js. To get that sorted out, we're going to have a H1 tag. This is going to be the to-do list. We're then going to have an H2 tag, and this is going to be the items list. So for the to-do list, we have two components. We have something that specifies all the items in the list, and then we have uh kind of a place where we're able to actually add the item, right? So for our items, we're going to create a div. Div stands for division, and it's something where we can actually just place items inside of. So I can take all my items and kind of render them inside of this div. So we're going to say id is items. So we're able to access that. We're going to create a very basic input so that someone can add an item. So, we're just going to say input like that. Remember, this is a self-encclosing tag. You don't need the separate closing tag. The ID is going to be the item input. The type is going to be the text and the placeholder is going to be to add an item. Okay, save that. It should appear on the screen. Next, we're going to make a button. And the button is going to say add item. And then for the on click, we're going to call the function add item. Like that. Okay, that is all of our HTML. Zoom out so you can see all of it. Again, we have our header. We have the H2 tag for the items. We have the div. This is where we're actually going to render all of the dynamic items. So when we do something like hello and we click add item, it's going to appear inside of the items list. Okay. Then we have the input so that we can add the item and the button obviously which will take that and add it to the screen. So now let's go to our JavaScript and let's start. So let's start first of all understanding what it is that we need to do and then writing this out. This is going to be a little bit longer. So it's worth having a bit of a plan for what we want to do here. So what we need to understand first of all is that we want to store these items persistently. That means that we need to have the ability to well store them. We also need to have the ability to load them. Now, one thing to consider is that we're going to probably have an array of items, right? This is the order in which we have our individual items. We're going to have the ability to remove items and we need to show the reflection of our items on the screen. So, when we first load them all, we got to render them on the screen. Means we got to actually put them there. And then when we remove them, we got to remove the correct item and then kind of rerender them onto the screen. So, there's a few things we got to do, right? We got to save items. We got to load items. We got to render items. And we have to add and we have to remove items. So what we can do is start writing out some of the core function names so that we know those operations and we can tackle them one at a time. So we're going to say let items is equal to an empty array. We'll get into some other things in a second, but for now we understand that we're going to have items inside of an array. We now know we also need to load items. So we'll write a simple function so that we remember that that's something we need to do. We also know we need to render the items onto the screen. So we'll write a function for that. We know that we need to save the items. So let's do that. And we know we need to remove and add. So we're going to say function add item and function remove item. Okay. So that's kind of that. The first thing I think makes sense for us to do is to figure out how to display an item on the screen. Once we know how to display an item, then it's a little bit easier for us to understand loading, saving, adding, removing, etc. But we need to say, okay, well, let's say we had some items in here, right, that we wrote ourselves. How do we show them on the screen dynamically? Because we might have one item, might have five items. We don't know. We're going to have to kind of loop over all of them and show them on the screen. So for render items, what we need to do first of all is understand where do we want to put the items? Well, I want to put them inside of this div. So I need to access that div. So we're going to say const items div is equal to document dot getelement by id and this is items. Now let's just take this and put this at the top of the screen and let's start writing our render items function. So, inside of render items, the first thing I'm going to do is I'm just going to clear this div to make sure that any other items that were in there, I get rid of because I'm just going to read them in. So, kind of every time I'm rewriting all of the items. It's not the most optimal thing in the world, but it's totally fine for this example. So, I'm going to say items divin HTML is equal to null. And all that's doing is just removing everything that's inside of the items div. So, now we've got a fresh slate and we can start adding our items. Now, what I want to do is I want to loop through all of my items. So, if I have one item, I want to add one item. If I have 10, I want to add 10, right? I want to loop over them. And I want to create what that item is going to look like and then put that inside of the div. So, we start with a for loop. And a for loop is what you use when you know the number of times that you want to iterate. A while loop is what is what you use when you don't know the number of times you want to iterate. So, in this case, we know the number of times it's equal to the number of items. So I'm going to say constant and inside of square brackets I'm going to say idx which stands for index and item of object entries. I'm going to explain this don't worry and then items and I'm going to put a set of square brackets. Now what this does is it will take all of these items. It will essentially give us pairings. Now the pairings are going to look like this. Zero item one item two. What that means is that the index here is going to be equal to the index corresponding with the item which will be stored in this item variable. So when you kind of do this object entries here and you pass an array, it just allows you to loop through and to access both the index and the item at the same time, which is what we want. There's other ways to do this, but I wanted to show you this kind of neat syntax in case you haven't seen it. Now, what I want to do here is for now, we're just going to create some text. And this text will just be whatever the item actually is. And we'll just add that inside of the div. But later we're actually going to add another div inside of the div that's going to contain the text content as well as a button. Okay. So let's look at how we do this. We're going to start by saying const text is equal to document.createelement. Now, we can create an element in JavaScript and then put that on the DOM. The DOM is essentially just the interface that you see over here. And by the way, oh yeah, the to-do list is already appearing. Okay, so that's good. So, we're going to create this element P. Now, we have this element though that's like it doesn't really have anything. It doesn't have any text. It doesn't have any styling. So, what we're going to do is we're going to set the content. We're going to say text.ext content is equal to the item. Okay. Okay, so now we've created a paragraph tag. We've set the text content. And now what we want to do is add it into this div. So to do that, we say the items div dot append child. And then we just simply add the text. So what this does is it creates the text element and then it just adds it inside of the div as a child. So we can keep adding different text elements. Now, we'll use the other components of this later, but for now, I just want you to see how this works. So, I'm going to go hello world 1 2 3. I'm just going to call this function. And you'll see when I save that we get two items appearing inside of our div. Okay, so that's great. That's how we dynamically render items. Now, the thing is I want to actually render some more complex elements here because I want each item to have a button that says remove. So, I need to kind of add inside of here, not just the text, but also the button. In order for me to do that, though, I need to have those inside of one element that I add to the div. So, what I really want is something that looks like this, where I have a div that has a paragraph tag and then I have a button like this, right? That says remove. So, I need to create this programmatically and then add this whole thing, this whole div as a child inside of the items div. It also gives me some more flexibility with styling, which we'll see in a second. So, we'll keep the text tag, but before we make the text tag, we have to make like a container that's going to be storing all of this stuff that we want to put on the screen. So, I'm going to say con container is equal to document.createelement. and we're going to create a div. Then we're going to say the containerstyle dot margin bottom. This just means we're going to add a bit of space at the bottom is going to be equal to 10 pixels as a string. Just that I separate these different containers a little bit. If you don't have this, you'll see they'll get really squished together. So we make our container, we make our text. Now we want to make our button. So we're going to say const button is equal to document.createelement. create element. We're going to create a button. And now for the button, we're going to say button.ext content is equal to delete. Okay. And now we want to set the onclick for the button. Now the on click for the button is going to call this remove item function which is going to remove the item from our list. However, in order to remove the item from the list, we need to know the position in the list where the item exists. So that's why we have access to this index. So what we're going to do is for remove item, we're just going to specify that we want to take the index of the item that we want to remove. And that now means that when we want to call this function, we need to pass the index. So what I'm going to do is I'm going to say button.onclick on click is equal to and then what I'm wanting to do here is I want to call the remove item function and I want to pass the index of this specific element. It's very important that we have the index because we're dynamically rendering different elements. So for each one of these elements we need to have something that identifies where it is on the screen, right? Or what position in the list it is so we don't delete the wrong element. So that's why we're passing the index here to this function. The problem with this is when we see this line here, JavaScript will actually call this function for us. It's different than inside of here. So notice here when I have the uncclick, I actually write the call, right? Which is the parenthesis. In this case, this only actually gets called when we click the button here. As soon as JavaScript encounters this statement, so even if the button has not been clicked, it calls this function which will automatically delete the item, which we don't want. So what we need to do instead is wrap this in a function that then calls this function. A little bit complicated, hence why I left this for the last project. We're going to use this arrow function notation. So what we do is we put a set of parenthesis. We put this arrow which is the equal sign and then the angle bracket and then we call remove item. Now what this essentially is doing is wrapping the call to this function in another function. So it's a bit difficult for me to explain this entirely, but what we're essentially doing is we're saying, okay, we're going to have a function that calls this function. So that means this whole thing here, right? When we call this, so if I were to do this, this actually valid syntax by the way, but if I did this, then it calls this function, which in turn calls this function. So the point of me doing that is that now when we have the onclick event, it calls this function which then calls this function so that we don't call this before we actually want to be calling it. I know it's a little bit confusing. I'm hoping it's clear. You guys can let me know in the comments if you have any questions about this kind of wrapper syntax, but this is a unique thing you should know about and that you're actually going to use quite a bit in JavaScript. Okay, so that removes the item for us. Now what we want to do is we want to take the button and take the text and we want to add that into the container and then we add the container into the div. So we say container.append child and we're going to append the text and then we're going to say container.append child. Okay. And then we're going to append the button if I can type this correctly. And then rather than appending the text here, we're going to append the container into the div. So now let's refresh. Uh, and I guess we're getting some kind of error. Oh no, we just didn't call this function. So let's call render items. And you'll see now that we get our containers that contain the item and the button. Now when we press the button, it doesn't do anything, but that's fine. You get the idea. Okay, so that's render items. Now, the thing is we want this delete to be appearing to the right side or to the left side. We don't want it below. So, in order to fix that, we're going to use a display property on our text. Now, you may not be aware of this, but every element in HTML is either a block or an inline element. A block element means that it will actually take up its own uh row inside of the document. And any element you put after it's going to be on the next row. So in this case, paragraph tags, P tags are block elements, meaning that anything you render after them goes on the next line by default. Same with header tags, right? These are block elements. Whereas something like an input tag or a div or a span, these are inline elements. Okay, which means anything you add just goes in the same row inline. Now, we can actually change the display type of elements with their style property. So I can say text.style.d display. And if I change this to inline and we actually call render items, you'll see now that our delete goes after the text. Now, it's not ideal because there's no spacing. I'll show you how we add that in a second, but you can see that I've changed it from inline, whereas before it was block. If we change it back to block, then we get what you saw before. So, kind of an interesting thing you might not have known about. Now, what we'll also just do here is we'll say text dotstyle dot margin right and we'll just make this equal to 10 pixels. So, we just add a bit of spacing between this and the button. We also, of course, could put the buttons on the left side if we want them to be lined up vertically. There's a bunch of things you could do here, but in this case, this is totally fine. Okay, so there you go. We have now everything we need to render our items. So, now that we have the ability to render the items, we want to be able to add them and to delete them. Now, actually, let's start with delete cuz we already kind of have that hooked up. So, to remove an item, all we have to do is remove it from the list or from the array and then just rerender the items on the screen. So, to do that, we say items. Now, splice will simply remove an element at a specific index. So, what I can do is say splice idx and then one. Now, what this is saying is, okay, well, what element do you want to remove? I want to remove the element that exists at this particular index. And then one is saying how many elements do you want to remove from this index. We just want to remove one. Okay. So you can see it says start and then the delete count. So we're deleting one element and we're doing it at this index. You could delete multiple if you want. So that's how you remove an item from the array. Now what we're doing after this is updating this screen by rendering the items. So, if we refresh this now and I click on delete, you can see we delete that item. Let's refresh. Delete 1 2 3. We delete that item. Okay. So, it deletes the correct item. Obviously, this is not being persistently saved, but we're going to get to that in a second. Okay. So, we've now removed. Now, we want the ability to add. So, let's get rid of the already existing items here. And for render items, we can now remove that. And we can just do that when we add an item. So to add an item, we want to get whatever is inside of this input box and we just want to add it as an item. So we're again going to go to the top of our program. We're going to say const the input is equal to document.getelement by id. This is going to be the input item item input. What did I call this? Let's see. Item input. Okay. So let's change this back to be item input. Okay. And now what we're going to do for add item is we're going to get the value of that. So we're going to say const value is equal to the input do value. What we're now going to do is add that. So we're going to say first of all if not value. So if you didn't give us any value, we're not going to add an empty string to the list. So we'll just say alert and then this is going to say you cannot add an empty item. And then we can just return. So when we return early from the function, we no longer will execute any lines beneath it. So this is called a naked return. Some people don't like it, but in JavaScript it's fine. And this is essentially saying, okay, as soon as you hit this, just get out of the function. We don't need to give any value back, but we're just going to exit the function as soon as this uh keyword is encountered. Then down here, we're going to say items.push, and we're going to push the value, which is whatever they typed into the input field. and we're going to rerender the items by calling the render items function. Then lastly, we're going to say the input value is equal to an empty string. So we clear whatever they had typed. So let's go here and let's add item one. And you can see it gets added. We can add item two. And you can see that I can delete the items as I did before. If I refresh though, of course, they go away. Okay. So now we need the ability to save the items and to load the items and then we are pretty much done. So what we're going to do here is use something known as local storage. So just to give you a bit of a primer on local storage, this is essentially storage inside of your browser. So it's stored on your computer and a bunch of websites will use this to keep track of information that can make it more convenient for you as a user. Now, you should never store any sensitive data in local storage because it can be accessed by pretty much anyone that's utilizing the computer. And there is ways that you can store data on the server side, but in our case, we're going to be storing it on the client side, which is userfacing, right? It's what you're using. So, we're just going to store all of the items that you had, and then we'll reload those every time you open up this website again. Okay. Now, when we use local storage, we can't store anything. we can only store specific values. So we can store like strings, numbers, etc. In our case, we have a list or an array. So what we're going to actually have to do is convert that into a string and then once it's a string, we're able to store it. So we're just going to go into save items and I'm just going to write this out and then I can kind of walk you through it. So what we're going to do is say const string items is equal to JSON in all capitals do stringify. and we're going to stringify the items array. So it just means we're converting it to a string. Okay, so we're just taking the list, converting it to a string. Now that it's a string, what we can do is we can store it in local storage. So we can say local storage, which is the built-in variable that you can write dot set item and we're going to set an item which is equal to a variable I'm going to define here. So I'm going to say const storage storage key is equal to and then this is essentially what you're going to use to access the storage that you're using. So you can set as many keys as you want. You just make them unique. So I'm going to make a key called items. And I'm saying okay well I'm going to set the key which is the storage key. In this case it's items and I'm going to make it equal to the string items. Now what this will also do is it will override any key that already existed. So if I already had something in local storage called items, I'm going to change what its value was to be this new value so that I'm always keeping the most upto-date version of my items. Okay. Now in terms of loading items, you kind of just do the same thing but in reverse. So we're going to say const old items is equal to local storage. This time it's going to beget item. And now what item are we getting? Well, we're getting whatever the item is associated with the storage key. However, this is a string. So, what I need to do now is convert this into an array that I can then use in JavaScript. So, I'm going to say first of all, if we actually have anything, because it's possible that we don't have any items stored. So, if I do have some items stored, which is what I'm checking here, then I'm going to say that my items, which is this variable right here, is equal to, and this is going to be JSON.parse parse and then old items. Now, what parse is going to do is it's going to read through this and it's going to convert it to a JavaScript object. In this case, the JavaScript object is an array. It could be an object, it could be a different type, but it's just going to be uh an array. Okay? So, it's going to give us an array that contains all the different items from that string that we put in the storage. Then, we're simply going to render the items. So what we want to do now is we just want to call load load items as soon as the document has loaded so that as soon as we kind of open up this website we load the items and then we'll call save items anytime we do something different to the items. So we can actually do that first. We'll go down here and we'll say save items. So we're going to save items after we add an item and we're going to save items after we remove an item. So if we remove or add the only two operations we can perform on the items then we're just going to save it. Okay. Now though we want to call load items. So we're going to say document.adde event listener and the listener is going to be the DOM content loaded. Okay. And then we're going to say load items. Now let me just explain what I did cuz this might be a little bit confusing. So what we're doing here is we're adding an event listener to our HTML document. And we can listen for different types of events. In this case, the type of event we're listening for is the DOM content loaded, which means it's actually loaded all of the HTML onto the screen. As soon as it does that, we're going to call the load items function. So again, we don't actually call it. We just put the name of the function, and then this will automatically call it for us. Now, you'll see that I have two items popping up cuz I already had them stored in local storage for this exact project. But, uh, we can delete them. them and when I delete them now and I refresh like it'll be persistent. Okay, so that's it. This is the finished project and I just want to show you it works. So we'll say hello world. We'll add that. Before if we were to refresh it would have gone away because it wasn't being persisted. But now it's being persisted, right? So if I refresh, it's still there. If I delete it and now I refresh, we get the updated version. So I just wanted to quickly show you how to use local storage. There's a lot more you can learn about it, but the basics is you can assign a string key to some kind of value. In this case, we're using a string. And that's how we can store our different items and we can retrieve them whenever we rerun this code. Now, the first step here is going to be to set up our environment to write JavaScript code. Now, if you've already done this and you have an editor and you know how to run and execute your code, then skip forward to the timestamp I'll put on screen, or if it's not there, you can go down in the video player and you'll see where all of the different projects start. This section is for people that are really complete beginners that have never done this before and need to set up their computer. So, in order to write JavaScript code, the first thing we need is a code editor. Now, we're going to be using VS Code or Visual Studio Code. It goes by both names. And we're just going to download that. Now, it's completely free and you can do that by simply clicking the link in the description or going to code.visisualstudio.com. You can see I'm on the page here. From here, you're just going to download it for the appropriate operating system and then run through the installer. Usually, that will be in your downloads folder. Next, we're going to go and download NodeJS. Now, there's multiple ways to run JavaScript code, but for this tutorial, I'm going to show you how to do this just plainly in your terminal. So, you don't need to know HTML, you don't need to deal with CSS, and you can just very simply run your JavaScript code from the terminal. So, to do that, we need NodeJS. So again, go to this website and just download the latest version of Node.js. Again, run through that installer and if in the installation process it asks you if you want to add this to the path, then go ahead and press yes. So again, if it asks you to add to path, then press yes. Okay, that's it. Visual Studio Code and Node.js. The next step is going to be to open VS Code. So you can do that from the spotlight search up here. Just typing VS Code or Visual Studio Code. Then on Windows, you could do that from like the Windows search bar. Okay, so let's open up VS Code. Let me zoom in a little bit so you guys can actually see this. And your window might look a little bit different than this. But what we want to do is we want to open up a folder. So you can actually close this welcome tab if you see that. And this is now the code editor where we're going to write and execute our code. So just like we would write something in Microsoft Word if we were writing an essay for code, we're going to do that in VS Code. Okay, so we need to open up a folder. Now there's many ways to do this. The first is to click on these documents up on the top lefthand corner, which is your explorer. When you do that, you should see something that says open folder. If you don't see that, you can go up to the top bar here. It might be hidden for you. And then file, open folder. Okay, so we're going to go to open folder. And this is the first step I usually do whenever I'm working on a project. So I'm going to go new folder. And I'm going to make a new folder called JavaScript tutorial. Now, you can name this whatever you want, but just make a new folder and press on create and then go ahead and click on open. So, at this point, you're probably going to see something that looks similar to this. Again, it might be a little bit different because I have some extensions and stuff in VS Code. We're going to click on the X here from the welcome and we're going to press on this new file button. So, now that we've opened the folder, you can kind of see the name of the folders right here. We can make a new file by pressing on this button or we can go to file and then new file. So, we're going to make a new file here, and we're just going to call this tutorial and then.js. Okay. So, you can name this anything that you want, but I recommend that you don't include any spaces in the name. And make sure that it ends in.js.js stands for JavaScript. And you'll notice we're getting the little JavaScript logo popping up here indicating that we are writing in JavaScript. Okay. So, we're going to go ahead and press enter and make that new file. To open the file, you can just double press on it here, but it should open by default. If you close the file, you can open it again by just clicking on it. Okay, so here is where we're going to write our JavaScript code. Now, we're going to write a really simple kind of a test line of code, per se, just to see if we can execute this before we move on to the next step. So, we're going to write the following console.log and then just hello or hello world. This is usually the first thing you write whenever you're learning a new programming language and it's just kind of a test um like output so you can make sure that your code is actually working. Okay, so we're going to do console.log log hello world and notice that I get this little white dot appearing near my file name. Now what that actually tells me is I haven't yet saved the file. So what we need to do if we want to run the code is we need to save it. So anytime you make a change you need to save the file and then when you execute it uh the new change will kind of be applied. So if you're wondering like why am I writing stuff and nothing's happening? It's probably because you forgot to save the file. It's the most common error that almost every beginner runs into. Now there's a lot of ways to save the file. You can go up here to the file menu and press on save or you can hit controls or commands on your keyboard, which is what you'll see me doing all the time. So, control S or command S depending on your operating system. Okay, so now we've saved the file. We don't see that little white dot. And what we're going to do is open up the terminal. Now, if you just put your mouse down to the bottom of the screen here, you'll see that you get a little up arrow and you can drag a terminal like this. Now, another way to open that is to use command and then the back tick. Uh, but you probably don't know where that is. So, you can just open it like this. Okay. So, you're going to open up the terminal. Now, from here, this is where we can execute our JavaScript code. So, in order to do that, we're going to type node and then the name of our file. Now, the name of our file should be this, right? So, we're going to say tutorial.js and we're going to try to execute the code. Okay. Now, when I do that, notice that we get the output hello world. Now, obviously change this file to be whatever you named your file. Make sure that this looks exactly as you see it here and that you're typing it like this. If you're getting some weird errors, you can destroy the terminal by hitting on the trash and then just drag this up again and it will give you a new terminal instance. Okay, hopefully that's clear. I know I'm going really slow, but a lot of people have issues with this and I want to make sure that this is covered for everyone and you know how to execute the code. Just for reference, if I were to make a file like 1.js js and I wanted to execute that. I would now need to change this to say node and then 1.js. Now notice when I execute this nothing happens though because I haven't done anything in my file. So it's executing it but we just don't see any output. Okay. If you want to delete a file you can click on it and press on delete. Okay. So that's pretty much it in terms of running your code. Uh now that we've done that we're going to move on to project number one which is our choose your own adventure game. All right. So, we're diving into the first project here, which is a choose your own adventure game. Now, a choose your own adventure game allows the users to kind of direct themselves through kind of a maze or a puzzle. And you might have seen this before if you've read certain books where it's like, you know, if you want to go left, turn to page 73. And then it says, if you decide to swim across the river, turn to page 35. And there's just all these different decisions and kind of like a branching route or path that you can go down. That's what we're going to build here. So the idea is you might start by saying, ""Hey, do you want to choose a sword or an axe? Do you want to go left or right? Do you want to cross the bridge? Do you want to go across the water?"" And there's one path that's correct and will lead you to kind of win the game and the rest of them will eventually terminate because you chose the wrong option. Okay, so let's build that. However, there is a few things we need to learn um kind of to start because if you don't know anything about coding or JavaScript, well, you know, there's a bit of a foundation we need before we can build that project. Okay, so whenever we write code, you saw that we have the ability to actually output something to the terminal. Now, that's what this is right here, console.log. In other languages, in Python, for example, it's print. In some languages, it's, you know, system.out, but in JavaScript, it's console.log. So, whenever you want something to go to the terminal, you actually want to see some results or some output, you use console.log, and then you put these two sets of parenthesis. And inside of these sets of parenthesis, you put a double quotation mark. So, a set of them. So, an opening one and a closing one. And then anything that you want to type out. Now, you already saw this, but I'm just going through it slowly because it's really important. Now, notice that we can't have like extra spaces here. I can't have, you know, I'm missing the period. Like, if you do anything wrong at all, even having like a capital here for log, you're going to get an error in your code. So, you want to make sure that you do everything exactly as I show you in this video because especially when we're coding, all of the characters are very particular. And I know it seems silly, especially if you come from something like Microsoft Word or when you're writing an essay where you can have different capitalization, etc. Here, it's really, really specific. Now, just to show you what happens, let's say I do something like console dot and then I accidentally put two L's. So, I make a mistake, then I save my code and I decide to run it. So again, I can bring up my terminal and I can type node and then tutorial.js. You're going to see that I get this kind of error message. It says console.lll log is not a function. Now you might not know exactly what these mean, but always try to kind of read through the result that you're seeing here. All of this is gibberish, but mostly like the main line underneath here that's in white because it's can sometimes give you a hint to what you've done wrong. So if you're getting an issue, uh, kind of check through this response here, and you'll see that it actually tells me JS line one. So the colon and then the number here is what line this issue occurred on. So that kind of helps you, line one. And then you can see that I have two L's. So it's kind of pointing to the mistake. And then you should be able to figure out, oh, you know, I put two L's. I just need one. So let's fix that. And then let's run it again. And there we go. We get hello world. Okay. I'm just going slowly here, just trying to help you get through this because if you're a beginner, there's a lot of errors. you potentially will run into and that's totally fine. That's going to happen even for me. I just want to help you be able to solve them. Okay, so that's logging something to the terminal. Now, the next thing we need to cover is something known as data types. Now, whenever we write code, we're dealing with different pieces of data. And that data has classifications or types. And there's a few important ones you need to understand in JavaScript. So, the first type that we have is a string. And that's anything surrounded in double or single quotation marks. So something like hello or hello. All of these are strings, okay? And a string again is anything in double or single quotation marks. There's a few more advanced types as well, but these are the ones you need to be aware of. And you can type literally anything you want inside of these quotation marks. So whenever you see a set of double or single quotes, that means you're working with a string, which again is just a set of a bunch of different characters. And that's what we use here when we want to log something, we put a string. Even the number like one here, this is a string because it's surrounded by quotation marks. Now the next type that we have in JavaScript is the number type. Now the number type is anything that is a number. So something like 23. Notice it's highlighting in purple. That's a number. Something like 23.5, 23.58, something like -9, 0, 0, a bunch of different values. All of these are numbers. Okay. So that's another important type to understand. The next type we have is boolean. Now boolean is simply true or false. That's it. And notice that it's typed exactly like this. Okay? So with a lowercase t and a lowercase f. Uh this is true or false or the boolean values. If you're familiar with computers and binary, true would be one and false would be zero. If that means nothing to you, ignore that I said that. Okay. And there's a few other types we want to be aware of. Another type that we have is undefined. Again, notice it kind of highlights in a certain color here because this is a reserved keyword in JavaScript, which means it's like a type. Okay, so we have undefined. This is a type of itself and it means when something is undefined, when we don't yet know what it is. And then we have null. Now, null is a different type and this is used when you explicitly want to set something to be kind of empty or non-existent. So undefined means we don't know what it is, doesn't exist. And null is indicating, hey, this thing is empty. it's, you know, uh, non-existent. We are just explicitly like we're making sure that it's known that we're setting this to nothing. I know it seems a little bit weird, but those are types that you might see. So, you just want to be aware of them. Now, we also have another type which is known as an object. We can look at that later, but um, yeah, just something to be aware of. Okay, so main types for now, just as a quick recap, we have strings. Anything in single or double quotes. Then we have our numbers. So anything like this is number. Then we have our booleans which are true or false. Then we have our what was next? Our undefined type. So undefined is just simply undefined itself. Like the type of undefined is undefined. I know that's a bit confusing but that's what it is. And then null. Same thing like the type of null is null. So just that one keyword. Okay. So now that we've looked at our data types, let's look at how we store this data and how we interact with it in our program. So just like in math class, when we program, we have variables. And variables, you can really just think of them like buckets that store some value. So in order to make a variable in JavaScript, we have three different options. The first and most flexible option is to use the var keyword. So what I can do is say var and then I can give my variable a name. So just something like maybe variable or x or Tim or name or whatever you want to call it. But usually it's a good idea to name your variable something that kind of makes sense with what it's storing. So let's go with var name. Now what we can do is put an equal sign here and then we can assign a value to this variable. That just means that we'll give this variable something to hold or to store. So I'm going to say var name is equal to Tim. Now, when I do this, all I'm saying is I'm making a new variable indicated by this var keyword. The name of the variable is name. So, maybe let's just change this to x so it's a bit more clear. So, the name of this variable is x. We're using an equal sign which says, hey, we're going to assign something to this. And then we indicate Tim here, which is saying, hey, the variable x is going to be equal to. Now, what that also means is that this variable here, we can say that it's of type string. So notice when I hover over it, it's kind of giving me this uh little line here and it's indicating that X is holding a string. And that's because the type that's inside of it, the data that we're storing, well, its data type is a string. Okay, so that's the first way that we declare a variable. And if we wanted to access the variable and use it, we could write something like console.log and then we could just put x here. Now when I use x, I'm referencing this variable that I just created. And since this variable stores Tim, if we run our code, we'll see that this will print out Tim. Okay, so that is the first little thing that we can understand. We have var x equals Tim. This is how we create a variable. And by the way, now that I've defined this variable, it's been created. If I want to change it later on, I don't need to use the var keyword again. I can just say x is equal to and then I can go with something like John. And if we run this now, you'll see that now the variable has been changed to John. Okay, so this here is known as our initialization. We've initialized the variable. We've given it a value. In this case, it's Tim. Now that this variable exists, if we want to change it, we can just do something like x equals John. And if we want to use it or access it, we can just refer to it by its name. Now, if I tried to access a variable like y, which doesn't yet exist because we haven't created this. If I go here and I print out, you'll see that we get an issue. It says reference error Y is not defined. Now, it's saying that because there's no variable with the name Y. Okay, just wanted to quickly show that to you because that's something that you might get. Okay, so that's variables. There's a few more things to go over there. Now, when you name a variable, there's a few rules. For example, it's not okay to have something like a space. So, if I have name space 2 or let's just go with two like this, you'll notice that it's giving us an error with this kind of red underline. The reason for that is you can't use a space in a variable name if you wanted to have a variable that was multiple words. You would need to use an underscore. Okay? So, an underscore is a valid character and you're also allowed to use numbers in your variable name. So, if I wanted to, I could do name underscore2 or I could do name two like that. But really when we write code in JavaScript, the way that we typically separate multiple words is using something known as camelc case. So if I wanted it to be name two, I would do name and then I put a capital for this. So name two like this. Just kind of a common convention. Doesn't really matter if you use an underscore or not, but a lot of people in JavaScript, you'll notice they kind of write their variables like this. Now, a few more rules. You can't have all these special characters. If you try to add, you know, parentheses or amperands or dollar signs and stuff, that's not going to work. And you also can't start the variable with a number. So if I do something like to name, that's going to be an issue. We can use a number, but it just can't be the first character. Okay? So keep that in mind with your variable names. Now, another thing that's important is that our variable names are case sensitive. That means that the variable name 2 is different than the variable name 2. Okay? So make sure you're checking your capitalization because uh it is case sensitive and you need to make sure you have the same capitalization when you're using variables. Okay? So that is the first way to make a variable. Now really what's typically preferred in JavaScript is actually rather than using the var keyword to use the let keyword. Now when you use the let keyword you're doing the exact same thing that you just did with var except you're indicating that this variable here can be changed later on in the program. Now I don't really want to explain the difference between var and let uh because that's a bit more advanced that we need to get into in this video. But just know that there is this let keyword. This is the way we'll typically define variables. And when we let something be equal to some value, we're indicating that it can change later on. Okay. Now, there's another one that we can use here and this is known as const. Now, const here stands for constant. And when we define a variable using constant, by the way, all three things you just saw here, they're all variables, just different types of variables. That means that we can't change this variable later on. So if I try to do something like name to is equal to five, I try to change its value and I go up here and I run the code, you see that we get an error and it says assignment to a constant variable because we can't change that. That's what const means. So whenever you're defining something that's not going to change, which can happen quite a bit, you use const or constant. And if you're defining something that will change later on, you can use let. Okay, there's a lot more things with variables, but that is really all you need to know in order for us to get started with the project here. Okay, so now that we understand variables, we understand data types, it's time to talk about collecting user input. So, sure, it's great to be able to print things out like, you know, hi, how are you, whatever, hello world. But often times, we want to respond to what the user saying. Now, unfortunately in JavaScript, it's a little bit tricky to grab user input, but I'm going to show you kind of a trick that can allow us to get it a bit easier. So, what we're going to do is open up our terminal here, and we're going to write the following command. So, bear with me here. So, the command we're going to type here is npm install and then prompt-sync. Okay, now this will install the code that we need in order to collect user input. Just bear with me. I understand it's a bit confusing, but this is what we need to do. Okay, so that's going to install the package for us. By the way, if you want to get rid of whatever's in the terminal, you can type clear or if you're on Windows, you can type cls and that'll get rid of all that. So, I'm going to remove that for now and just make that a bit smaller. And now we're going to start using this. Now, to use this, I'm going to say const prompt is equal to require and then prompt dash sync. And then we're going to put another set of parenthesis. Now, I know I'm going fast, but you can pause the video if you want to type it all out. I'm also going to explain what this is doing. So we're saying const which means constant, right? So we're defining a variable called prompt. Now prompt is going to be equal to require prompt sync and then we have to call this. I know seems weird, but this is just how you bring in this code. Okay, so this is code someone else has written that's going to allow us to really easily collect input from the user. Now we want to test this out to make sure it's working. So we can type prompt a set of parenthesis and then we can type a question that we want to ask the user. So something like what is your name question mark. Okay. Then I'm going to do a space. Now what I'm able to do now is I'm able to have this printed to the terminal. So down here. And then afterwards so after this string here it's going to allow the user to start typing. And that's why I've put this space here so that there's uh what they type is not going to be kind of squished in with this. And prompt itself is just the name of the variable that we define. So if we called this something like you know h e then we would have to change this to h e. Okay. So that's how we're using this. Hopefully that's a bit makes sense a bit or isn't too confusing. I I hate how it's so complicated in Node.js and Python to collect user input, but it's just how it is. Okay. So now what I'm going to do is run the code to test this. So, we're going to do node tutorial.js. Now, notice it says, ""What's your name?"" And it hasn't finished the program yet. We actually get our cursor here. And now that I can start typing. So, I'm going to type Tim and then hit enter. Okay, perfect. So, prompt is working. Now, obviously, that's great, but we probably want to be able to store what the user typed that we can maybe print it out or we can use it in some meaningful way. So, let's do that. We're going to say const name name is equal to and then this right here. Now what's going to happen now is whatever the user types in is going to get stored in this variable name. So I'm going to save that and then we're able to use the variable. So if I wanted to I could say console.log and then name. Okay. So now I'm going to run my code. So let's clear and run. And we're going to go with Tim and it says Tim. Okay. So now we've collected what they typed and now we're printing it out. Perfect. Now, the next step after this is we probably want to say something like hello, you know, whatever their name is, like give them some kind of greeting that's customized with what they typed in. So, let me show you how that works. What I can do here is I can put something like hello and then I can put a comma and then I can put the name and I can say how are you question mark. Now, what I'm able to do is I'm able to print multiple messages or multiple strings. So, I can say console.log log and then I'm going to print out hello. Then I put a comma and then I put the next thing I want to print which is Tim or whatever the name is that the user types in. Then I put another comma and then I put how are you. Now it's going to print all of these things that I've separated with commas and it's going to separate them with a space. So if I run this now and we type in let's go with something different like Joey, it says hello Joey, how are you? Okay, so you can print multiple things using the comma to separate them uh inside of a console.log. Now, another option is we can actually what's known as concatenate these strings together. So, let's say maybe we didn't want to have the space. I can use a plus sign instead. And when we use the plus sign with different strings because remember this is a string. The name, whatever the user typed in is going to be a string. And then this is a string. We just squish the strings together. So, if I run this and I go Tim, it says, ""Hello, Tim. How are you?"" And actually, you know what? This is a good learning moment. Notice that we're getting the same result as before and it's not squishing the values together. The reason for that is I see this white dot here and I forgot to save my file before I ran it. So, let me save this and run it again. And now you'll see if I type in Tim, we get the results squished together. So, if you're ever like you're not getting um you know, whatever change you made, just check if you saved the file or not. Even me all the time I forget to do that. Okay, so now we're able to greet the user. So, let's just change this back so we're using the comma so there's a bit of space. And the next thing we want to do is we want to start working on our game. So, we're going to say hello, how are you? Uh, and maybe rather than how are you, we can say something like, do you want to play? Or maybe actually let's welcome them to the game. Hello, Tim. Welcome to our game. Okay, so now that we've done that, let's ask them another question. So I'm going to say const should we play is equal to prompt and then we're going to ask the user if they want to play. So we're going to say do you want to play question mark. Okay. So now I'm going to ask them and I'm going to put a space here so they can type something. And what we'll do after this is we'll check if they typed yes or no. And if they typed yes then we'll start the game. If they type no, then we will obviously not start the game. Now, I know I'm going really slow, guys, but I'm just trying to make this really accessible for everyone. So, if it's too slow for you, feel free to fast forward in the video or to increase the playback speed. And don't worry, for the future projects, it will be a lot faster. And all the stuff we already covered, I'm just going to quickly go over. Okay, so now we're asking them uh if we should play. So, what I'm going to do now is I'm going to run the code and test this out. Okay, so let's run this. And we're going to type in Tim. and we get what is your name? Hello Tim, welcome to our game. Do you want to play? And then we can type something like yes. Okay, so that's great. But obviously now we need to check what they typed in. And if they type yes, we need to start playing. Otherwise, we need to um what do you call stop playing or tell them, you know, too bad you missed out on the opportunity. So to do that, we're now going to learn about conditions. Now whenever we're working with code, we have ways that we can compare different values together. Now in this case we want to check if what the user typed in is equal to in this case yes but we could check anything that we want and we do that using some comparison operators. Now in JavaScript we have the following operators. We have double equal sign a triple equal sign a not equal to a not and then double equal sign. We have a less than a greater than excuse me a less than or equal to and a greater than or equal to. There's a few other ones that are kind of uh you know less used, but these are the common ones. Now, you'll notice we're getting kind of all of these red lines. So, what I'm going to do now is introduce a comment. Now, a comment is simply a way that we can write something in our code that the execution will ignore. So, right now, if I were to try to run the code, we'd get an error because I have all of these symbols that just don't make sense to uh kind of what's known as the compiler or the interpreter. We don't need to get into that, but that's what's running the code. But if I want it to ignore that, I can simply do a double slash. Now, when I do a double slash, it's going to make this line gray or comment out the line. And that means that now when we run the code, whatever's on this line will be ignored. So, I could just do this on all of these lines, right? So that I have this comment and now the red line goes away. And we're going to ignore these lines. Or I can do what's known as a multi-line comment. Now a multi-line comment is a slash an asterisk and then you can end this with an asterisk and a slash. Now when we do this we can comment out multiple lines at once. So this whole part right here now is a comment which will be ignored when we run our code. Anyways that's a comment. Okay, so let's go through these different operators and I'll show you quickly how they work. Now the double equal sign is what's known as a loose comparison. And this means we're going to check two values and see if they're equal to the same thing. we're not going to look at their type. So, it's a little bit weird, but that means that we could do something like seven is equal to seven. And now we're going to actually just check if these things kind of equate to the same value, but we're not going to be concerned with if their types are different. So, in this case, the string 7 is different than the number seven. But since if we were to convert this here to this type, they're both the same, that means that this is actually going to return to us the value true. So whenever we use these different operators here, the result of an expression. So if we write something like this is either going to be true or false. It's going to be boolean. Okay. Now this is referred to as a condition. So when we use an operator, so a conditional operator, and we use an operand, that's what these are called here, a left and right operand. This is going to give us a result or evaluate to true or false. Okay? So the double equal sign is a loose comparison. And I recommend that you don't use this because it can give you some weird results that you're not expecting. Now, I don't want to get into it too much, but again, remember this will actually like not really concern itself with the types and just check if these things are equal to each other without looking at the type. Okay, that's like not a completely accurate explanation, but for you right now, that's what you need to know. You can look into it more if you continue learning JavaScript. Now, the next is the triple equal sign. This is the strict equality operator and this will make sure that two things are exactly the same and the type does matter. So if I do something like Tim or actually let's go back to the other example something like one is equal to one. Whereas if we use two equal signs this would be true. When we do this we're going to get the result false. And that's because yes these are the same but they are different types. So they're not the exact same. So we get false because this is a strict equality operator. There's some more examples I could go through here, but pretty much always use the triple equal sign unless you have a really good reason to use the double equal sign. Now, the not equal to works the same way, but in reverse. So, if we do exclamation point and then equals to, this is the loose not equal to. Now, this checks if two things are not the same and if they are not the same, it returns true. If they are the same, it returns false. Now, in this case, this will actually give us false. The reason for that is that these two things if we checked them with the double equal sign would be true. They would be the same. So when we do not equal to it gives us false because it's the reverse of that. Whereas if we did not equal equal then this would be true because these things are not the exact same when we consider their types because one is a string and one is a number. Okay. So that's those four operators covered. We then have the less than sign. Now you can actually use this with mismatch types. So we have like a string versus a number but it's a bit confusing so we don't need to look at that but it pretty much just tells you if something is less than the other thing. So in this case this would give you false because four is not less than one. Whereas if we swap this to greater than well four is greater than one. So we would get true. Then we have greater than or equal to. So if we did you know four greater than or equal to four that would be true. If it was strictly greater than this would be false because they're the same. Okay. Then we have the less than or equal to. So if I go four less than or equal to 5, of course that would be true. If we change this to six, then that would be false. Okay, so those are our comparison operators. Now let's see how we can use those to see if we should play the game. So first let's do the following. We're going to say const condition is equal to and then I'm going to go with should we play is equal to notice I'm using three equal signs and then I'm going to say yes. Then I'm going to console.log the condition. Okay. Now when I save my code and run what's going to happen is we're going to print out true if we should play the game and we're going to print out false if we should not. And we're going to do that by looking at what the user typed in and we're going to take whatever they typed in and we're going to compare that to the string yes. Now, if it's the exact same, then this will be true and we'll play. If it's anything different, it's going to be false. So, let's go here and run our code. We're going to say, what is your name? Tim. Do you want to play? Yes. And we get true. Run this again. What is your name? Tim. Do you want to play? No. And we get false. And just for one more example, Tim. And if I type something like yes with a capital Y, it actually says false. And the reason for that is capitalization matters. So a yes with a lowercase Y and a yes with an uppercase Y are different. So it gives us false. Now if we wanted to avoid that, what we can actually do is we can take whatever the user typed in and we can convert this to a lowercase string. So I can say dot two and then lowercase and then put a set of parenthesis. What this is known as is a method. You don't need to worry too much about the exact kind of naming here, but what that's going to do is it's going to act on this string and it's going to uh kind of turn this string into a lowercase version and put that right here. So, it won't actually change the string itself, but it will get whatever the lowercase version of that string is and kind of put that in place of the line you see right here. So, if we type in something with uppercases, it will just convert them all to lower cases and then compare that to yes. So that way if they type something that's yes but with different capitalization it will still work. So if I do this and I type Tim and then I type like yes s it says false and that's because I forgot to save. So if I fix this and run it again and we go Tim and we go y like that it still says true. Okay so sorry about that before I just forgot to save but you can see now it is working when we convert this to lowercase. Okay, so all of that is great, but now what we want to do is we want to say something to the user if they want to play the game. So how are we going to do that? Well, I've kind of hinted at it the way that I said that, but we're going to use something known as an if statement. Now, an if statement allows us to check if something is true. So that's where the conditions come in. So the syntax for an if statement, which is the way in which we write it, is the following. We write if, we write a set of parenthesis, and we write a set of curly braces. Now the parenthesis here is where we put something that is true or false. So in this case if I put my condition this is going to be equal to true or false. So if this is true we're going to do whatever is inside of these curly braces. So if I do something like console.log okay we will play. Then what's going to happen is only if this condition evaluates to true will we print this out. Otherwise we just won't print anything. So let's look at this now. We're going to go clear and run. Going to go Tim and then yes. And notice it says okay, we will play. If we run again, Tim and no, it doesn't say anything because this did not run. Okay, so that's it. That's the if statement. It's pretty straightforward. We say if this thing is true, do whatever is inside of here. Now there's one line here, but we could put multiple lines and we will in fact do that in a minute. Now, one thing to note is that we don't need to kind of write it how we've written it like this. I can take this line and I could paste that here and remove this. And this is perfectly valid. As long as whatever you have inside of here ends up being true or false, then it's going to allow us to kind of get inside of the if statement. Okay, so let's run it one more time and go Tim and then yes. And notice it still works. Okay. So, you can do it in a variable or you can do it like this how I've just done it. Now, that's great, but we probably want to say something to the user if they don't want to play. So, if they don't want to play, I'm going to put an else statement here. And an else statement is something that only comes after an if statement or as a part of kind of an if statement block. I can't just go down here and write an else statement. It needs to be associated with an if. Now, the else is just the other side of the if. So, if this thing is true, do this. Otherwise, or else do this. It's pretty easy. But if I just go here and go console.log and then, you know, okay, sad face. Now, if they don't type yes, then we're going to print this out. So, if this is not true, go in here and do that. That's all that is. So, let's look at this now. We're going to go Tim and then no, it says okay, sad face. Whereas, if I type Tim and then yes, it says okay, we will play. Okay, so that's the else. Now, this is the basics on the if else statement, but there's one more thing we need to look at, which is the else if. Okay, now the else works the exact same way as an if, but we only check it if this is not true. So, it's kind of like a chain. We say if this thing is true, do this and then skip the rest. Otherwise, check this thing. Otherwise, do this. Okay. Now, we can actually have multiple else ifs, but let's just look at an example of this. So, let's say we have should we play? Let's just copy this and put this here. And let's say that it's equal to no. Maybe we'll take the okay here and we'll put that inside of here. And then we'll change this to say invalid input dot dot dot. Okay. So, we have console.log. Okay. Will play. Okay. Sad face and invalid input. Now, the way this is work is going to work, sorry, is we're going to ask the user if they want to play. If they type in yes, we're going to execute this and we're going to skip the rest of this. If they type in no, which I'm checking here, so if they didn't type in yes, we're going to check if this is the case. If they type in no, we're going to print this out and we're going to skip this. Otherwise, so if none of this is true, we're going to print invalid input. I know I explained that a little bit weird. Also, it doesn't matter if you have a space or if you put this on the same line. It's valid either way, but let's run it and just test this out. Okay, so node Tim, let's type in no. And notice we get okay. Let's type in maybe invalid or something like that. And it says invalid input. Okay, so again, if this thing is true, skip the rest of this. If it's not, check this next if statement. If that's not true, do this. And if we wanted to, we could have another else if. We can have as many else-ifs as we want, but they just have to come after an if statement. Okay? So, in order to use the else- if or the else, you need to start the block with an if statement. Now, as soon as we see the else, that kind of terminates this if statement block, which means I can't come here and do like else if. Now, that's invalid because the else was already placed. It always goes at the end of the statement. Okay, last thing. If I want to do another if statement, that's fine. I can do that down here and start a different block. Okay, so that's it. This is uh our if else if and else. And now we actually want to start the game. We know enough to build this out now. So as a reminder, the way this game works is we're going to ask user users questions. Sorry. And based on the answer to their question, we're going to move down a different path and eventually the user will either reach the end of the game or they'll reach a path where they're not able to complete the game or they lose. So this is the first thing we ask them, right? Do you want to play? Okay. Yes, they want to play. Now, if they say yes, what we're going to do is remove this. And inside of this if statement is where we're going to write the logic for the game. So, I'm going to say game logic here. Okay? Because only if they typed yes are we going to execute kind of like the game code. Otherwise, we're going to handle this. Okay? So, we're going to go inside of the game logic. And the first thing we're going to do is kind of think of what we want to ask the user to start. Now, I like a simple question like, do you want to go left or do you want to go right? And you can be as creative as you want with this, which is why I love this game, but I'm going to make it basic so you guys can extend it and make it really cool. So, what we're going to do is the following. We're going to say const, and we're going to say left or right is equal to prompt. I'm going to say you enter a maze. Do you want to go left or right? question mark. Okay. Now, let's make this a little bit smaller so you guys can read this. So, now inside of here, I need to check what they typed in. So, I'm going to say if left or right is equal to left, then I'm going to do something here. Otherwise, so if they didn't type left, I'm going to do something here. So, you can see that we're going to kind of branch in here with multiple if statements. So, I'm saying if left or right is equal to left, then maybe this was the right decision. So if it's the right decision, we can do something like console.log, you go left and see a bridge dot dot dot. Okay. And then we can ask them another question. So I can say const something like cross is equal to prompt and I'm going to say do you want to cross the bridge question mark and then same thing I'm going to say if cross is equal to yes do this if not equal this. We'll keep going in a sec. I just want to slow down a little bit cuz I know I'm going a little bit fast. So again if they want to play we're going to ask them another question. Then for this question, well, we need to check what they answered. So if they said left, then this is like the correct choice. So we're say, okay, you go left and you see a bridge. Otherwise, we're going to say console.log. We're going to say you go right and fall off a cliff. Okay, so a little bit aggressive, but you can see we're saying, okay, well, if you go left, well, you lose the game. That's the wrong decision. So you don't want to do that. So then they'd have to run the game again and try to go down the correct path. So here now if they go left we're going to continue going because this is the correct decision. So we're going to say if cross is equal to and again you guys can make this whatever you want. I'm just showing you the layout of the game is equal to yes then we can do something like console.log log and we're going to say you cross but the bridge was weak and broke and you fell like great English there and we'll say you lost dot dot dot okay otherwise so if they don't want to cross so if they type anything else pretty much then we could continue the game or we could say something like console.log blog. Good choice. Dot dot dot. You win. Let me just make this a bit larger so you can see. Now, obviously, you want to keep going and make this more creative and you don't have to allow people to, you know, die or lose at every uh avenue. If you wanted to, you could have both paths be valid paths. You also could get even more creative here and you could have multiple options. So, maybe you enter the maze. Do you want to go left, right, or straight? And then rather than left or right here you would just have another else. Uh so you do like this else if and then here you would say else if left or right is equal to straight. Then you would do something else here. So you can have multiple different options. Right? So look at this code kind of study it a little bit. I know it's a bit difficult to read but the point is we have these branching paths and the paths can get like quite large and you can have quite a complex game. I'm just showing you the basic layout of it for this tutorial. And I know I wrote a lot of code here, but all of the code you see on screen now, you already understand because we already went through it. And we're just kind of laying this code out in different sections and different paths to create this game. So, let's just run this one right now just to kind of make sure this is working. So, we're going to say, what is your name? Tim. Uh, hello Tim. Do you want to play? Yes. You enter a maze. Let's go left. You go left and see a bridge. Do you want to cross? No. Good choice. You win. Okay, let's do a different path this time. Let's go, Tim. Yes, let's go right. If we go right, you go right and fall off a cliff, right? So, you can see based on like prior decisions that we've made, that affects the game. So, we can go Tim. Yes. Uh, let's go left this time. And then let's cross the bridge this time. And it says, you want to cross the bridge. Cross. Good choice. You win. Uh, let's see. Maybe I did this wrong. Oh, if cross equals yes, that's why. So, if cross equals cross, that's what we should be checking. Um, do you want to cross the bridge? Oh, what did I type? Okay, no, this is correct. I just typed cross rather than yes. I don't know why I did that. And you get the point. Okay, so this can can continue working. I'm even confusing myself here because I've now been recording for an hour straight with no breaks. Okay, few more things to cover here. Uh, if you want, you can convert these to lowercase as well. So if they type something like, you know, yes, this will work. So to do that, we can say dot to lowercase, right? And now if we do that after what the user types in, we'll convert that to lowercase and then we'll store that in the variable. So now it doesn't matter the capitalization they type in, this will just work. But obviously if you convert this to lowercase, make sure the string you're checking is lower case. Cuz if you do something like yes, then that's never going to work because we're always converting this to lowercase. Okay, last thing we're going to cover here is checking multiple strings uh in one of the options here. So maybe we want the user to be able to type in yes or we want them to be able to type in y. Well, how do we check that? Well, now we're going to quickly cover the and, or, and not, which are the logical operators in JavaScript. So, let me zoom in a little bit here. Okay, so we have three operators you need to be aware of. The first is a double amperand, which is, the second is a double pipe, which is or. And the last is an exclamation point, which is not. Okay, let me just get my slashes correct. Now, the not is really simple. The not simply reverses something from true to false. So, if I do not true, this is valid, by the way. This gives me false. If I do not false, this gives me true. So, sometimes what you'll see is something like, you know, x is equal equal to two, whatever, and then there's a not sign here. Now, when you do that, you're just saying, okay, whatever's inside of here, if it's true, I want it to be false. If it's false, I want it to be true. So, the knot just flips it, okay, from true to false. That's that. Now, the and is how we can check if two things are true. So, true and and true is going to give you true. True and false is going to give you false. If you have false and true, this is going to give you false. Essentially, what it's doing is it's checking both the left and the right and making sure both those things are true. So, if both of them are true, you get true. If any of them are false or all of them are false, you get false. Okay? Now, it doesn't really make much sense when you're just writing false and true. But oftent times, you'll see things like, you know, x is less than two and x is maybe not equal to1. Maybe that's something you're going to check. I don't know. But the point is if you do that now, if both these things are true, this whole thing here is going to give you true. Otherwise, it's going to give you false. Okay, that's the and operator. Both the left and the right need to be true. The next operator we can look at is the or operator. Now, the or operator just checks if the left or the right is true. And it could be both of them are true. That's fine. That will give you true. It could be one of them is true then it's going to give you true but if both of them are false it will give you false. So quick example true or false is equal to true. Okay false or true is equal to true. True or true is equal to true. And the only situation where you're going to get false is you have false or false is equal to false. Okay. So these are what are known as the logical operators and they allow us to combine multiple conditions together to check more complex things. So for example, if we go here when they're typing, you know, crossing the road, we're going to say if or crossing the bridge, sorry, if cross is equal to yes or cross is equal to y, then we'll let them cross. Okay, so that's what we're doing here. We're saying, okay, let's check multiple things. If they typed in yes or they typed in y then we're going to go down this path. Right? Now if you wanted to uh you could check multiple. So we could do another or we could say or cross is equal to okay whatever you want to check where you can check multiple things then this will work as well. So you can combine ands and ors and multiple ors. We don't need to get into all of that in this video. Uh but I just want to quickly show those to you because they are pretty important and can allow you to make a more advanced game. Okay. So there you go guys. That is the choose your own adventure game. I know I really just built kind of a basic version out, but I really want you to extend this and make it more complicated and mess around with it before proceeding. So, I just gave you kind of the base and now you can make something really cool. Now, this is going to be a textbased calculator. That means that we're going to get the user to type in two numbers. So, the left side operand and the right side operand and then some kind of operators like a plus, minus, uh, multiplication, division, etc. So, let's go ahead and dive in. We're going to start by using prompt. So in order to do that, we're going to say const prompt is equal to require and then this is going to be prompt-sync and then we are going to call that with the parenthesis. Okay. Then we're going to ask for two numbers. Let me just zoom in a little bit here. So we're going to say const number one is equal to prompt and then this will be please enter number one or we can just say enter number one and then let's copy this and actually let's fix this first and put number two and then change this to number two and then lastly we're just going to call this operator and we're going to say enter sign. Okay, cool. So, it's going to ask them for the first number, the second number, and the sign. And then we're going to perform that math. Now, what I want to do here is essentially check the sign and see if the sign is a plus or a minus or a division or a multiplication or all the different arithmetic operators that we have, which actually I should go through now. And based on what they enter, we're going to perform that arithmetic. So, as you saw, we have plus, minus, division, multiplication. We also have the modulus operator. This gives you the remainder after division, but we're not going to go through that right now. Uh, and these are kind of the core arithmetic operators we can use. There's a few more, but these are the most popular ones. Now, this allows us to add values, subtract values, and essentially perform operations with numbers. So, what we're going to do here is actually learn about a new feature in JavaScript called the switch statement. Now the switch statement looks like this. And it's very similar to how the if statement works except it's just checking the value of a single variable. So if I say switch on my operator, what I can do now is write some different cases and we're going to check uh essentially to see what the operator is equal to. So rather than having a bunch of if statements and saying if operator is equal to plus, if operator is equal to minus, if operator is equal to etc. we can just switch on the operator and then write the cases that correspond with what we want the operator to be equal to. Don't worry, this will make sense in a second. So, we're going to say case and then we can go plus and then colon. Now, what we'll do is after the colon in an indented block here, we write anything that we want to run if operator is a plus. So in this case what we want to do is something like result is equal to number one. So let's type this correctly plus number two. Then we can say console.log the result and we can break. Okay. So this is a simple case in a switch statement. Now you need to have case. You have what the value is that you're checking. So again it's for the value of this variable. Then after the colon, you can write anything that you want to happen in this case. So here we're going to say result is equal to number one plus number two and then we're going to console.log the result and break. However, what we're actually going to do is first define this variable. So we're going to say let result. Now you may not have seen this before, but we can actually define a variable without initializing it or giving it a value. So that's what I'm doing here. And then I can say result is equal to and I can kind of assign a value to this variable. So right now result will be equal to undefined. That's fine. Uh but it's just something that you can do. So you can kind of say hey I want to have a variable called result. I don't want to give it a value quite yet but later I will give it a value. Okay. So that's the first case. And then what I can do is copy this and paste it. And notice we have this break keyword. Now the break keyword ends the case. And it's very important that you have this. A lot of people miss the break, then they get errors in their code. So you need to make sure you have the break. This is what separates the cases. So now I'm going to have a minus. Now for the minus, we're just going to change this to be a subtraction. Now you get the idea. We're going to copy this for the other operators that we want to have. So we can have a division and then change this to division. And then we can have an exclamation point and change this to sorry an exclamation point asterisk which is multiplication and then an asterisk for multiplication. Okay, let me make this a little bit smaller so it's easier to read. Okay, so these are the four different cases that we have plus, minus, division and multiplication and essentially we just check if the operator is equal to any of them and then we go into that case. Now we start by checking the first case and then we move down in sequential order. So let's just run the code and see what we're getting right now. So we can go here and clear and go node and then project 2.js and enter number one. So let's go with eight. Enter number two. Let's go with nine. Uh we'll do a plus. And notice that we actually get 89. Uh okay, that's a bit weird. Let's try a different case. Let's go 9 2 and minus. And that time we get seven. Okay. And what happens if we go 3 4 and then a asterisk? we get 12. So the reason why we got 89 here when we added 8 and 9 is that when we use this prompt function here this actually gives us back strings. Now JavaScript is a really weird language and when you try to do operations with strings when you try and when you try to do arithmetic operations like plus minus division multiplication etc using strings you can get some wonky results. Now in this case you saw that when we added these two numbers together since they were both strings we actually got a string concatenation. So 8 + 9 was equal to 89 because these were strings and we simply squished or concatenated them together. Now it works properly with our other cases because of some weird ways that JavaScript works. But what we need to do to ensure that we get the correct result is first convert these strings into numbers. So to do that, we're going to use the function parse float. So what I can do is simply surround my prompt with this parse float. And what it's going to do is simply grab whatever the number is that we type in and convert it to a floatingoint value or the number type. So that way when we get a number, we convert it to the number type rather than the string type. So when we perform this operation, everything works properly. So let's go ahead and do that. We're going to clear and run. And let's go 9 and plus. And notice this time we get the correct answer which is 18. Okay, so that's good. Now you might have noticed down here that when I do this console.log, I'm pretty much just doing the same thing four times. So rather than me actually doing this inside of the switch statement because it's very repetitive, what I'm going to do is take it and move it outside of the switch statement. So I'm going to go down here and put console.log result. Okay, so now let's run the code and just make sure that this works. Uh let's just go four, five, and division. And you see that we get 0.8. Okay, very good. However, what happens if I try to type in a sign that doesn't exist? Well, that's where we're actually going to implement a new case here called the default case. Now, the default case is kind of like the else statement in the if else block. And this will execute if none of the cases above it were the case. So, inside of default, I can do something like console.log log and then invalid and then I can break out of this default case. Okay, very good. So now if you type anything other than one of these cases, we're going to go into the default block. Again, this is like the else statement and we'll print out invalid. But what does that mean for our result? Well, let's try it out. We can always just test things and mess around. So if I go here and go with eight and maybe nine and like go with something weird like a colon, you can see that we get invalid and then we get undefined. Now really we don't want to print anything out unless we actually have a valid result. So why don't we do something to make sure that we have a valid result before we print this? Well, what I can do is actually set up something known as a flag. I'm going to say let valid equal true. Now the idea is I'm going to have this variable which is a boolean. We've set it equal to true and we're going to assume that we have a valid result. However, if we reach this default case, then we can say valid is equal to false because if we didn't go inside of any of these cases here and exit the switch statement, then we know that we had an invalid operator. So we'll say valid equals false. So then I can go here and say if valid, then we'll print out the result. And notice that I did something weird here. I didn't write the curly braces for my if statement. Now, when you just have a single line that you're using after the if statement, you actually don't need to use the curly braces. It only works like this if you just have a single line that you're executing, which is what I'm doing right here. And I can write the code like this, as you see here. And this is perfectly valid. Or I could even do it like this if I wanted to. So, I'm going to do that just to show you the shortand. Now, for the result, what I'm going to do here is the follow. I'm just going to print out a little bit of a better um kind of output. I'm going to print number one, and then I'm going to print operator, and then I'm going to print number two, and then I'm going to do a comma, an equal sign, and then the result. So, this way we just print out the whole expression so we can see exactly what we got. Let's zoom out again to make it a little bit easier to read. Okay, so let's run this now. 8 9 plus and now it says 9 + 8 equals 17. Okay, so I just wanted to get the kind of nice output here. Very good. So there you go. We have our switch statement. But what happens if we enter a number that's not valid? Let's try that out. So if I go here and run my code and try to enter something like hello and one and maybe I add these together, notice I get nan. I get not a number. Now, why am I getting that? Well, when I use this function right here, parse float, if I accept something in here that's not a number, so a string like hello, then it simply returns to me the type nan, which stands for not a number. So, what we need to do ideally is we want to ask the user to keep giving us input until they give us a valid number. So, if it's nan, we got to say, hey, no, that's not valid. You got to give us something else. So, how can we do that? Well, let's write some code that can handle that for us. But in order to do that, we need to learn about something known as the while loop. Now the while loop is something that can keep repeating code until a certain condition is met. So what I can do is something like while and then condition and then uh we'll go here do this. So this is kind of the syntax of a while loop. We say while this thing is true. So whatever we put inside of the parenthesis while that's true keep doing whatever is inside of the loop. So just keep repeating it over and over and over. Now, this is really good for when we're collecting something like user input because we can say, well, we don't have valid user input. Keep asking them to give us input. But let me show you a few examples of how the while loop works. So, we're going to say uh let equals zero. And we're going to say while I is less than 10, I'm then going to say I ++. This is actually a way that you can add one to a variable. So, plus adds one. Minus minus subtracts one. Plus equals 1 adds 1. plus= 1 adds two minus equals 1 or minus= 2 subtracts 2. I'm just showing you a few ways you can do this here. So I'm going to say I ++ and before that I'm going to say console.log I. Now if you want to pause the video and take a guess at what the output of this code is going to be go ahead I'm going to explain it now. So this is a while loop. We have a variable I and I tracks how many times this loop has ran. So we say while i is less than 10 we print out the value of i and then we add one to i. So at the first iteration i is zero. So we print out zero. Then we add one to i. i. Now becomes 1. We then check if 1 is less than 10 and it is. So we keep looping. So we print out i. So we print out one. We add one to i. So i is now two. And we repeat this process until eventually i is 10. When i is 10, this condition now is false. So we stop looping. Okay, so let me show you how this works. I'm just going to comment out the rest of the code so I can run this. And let's go here, bring up our terminal, and notice we get 0 through 9. If we wanted to get 10, we need to make this less than or equal to 10 in order for that to work. Okay, so that is the basics on the while loop. But there's a few keywords in the while loop that we need to understand. The first keyword we want to look at is the continue keyword. So what I'm going to do down here is say if I is equal to five then continue. Now what continue will do is simply go up to the top of the loop. And I just need to change this a little bit so that it makes a bit more sense. Okay. So continue just simply stops the while loop where it is and goes back to the beginning. Doesn't change anything. Just goes back to the beginning of the loop. So as soon as continues hit, we skip whatever's beneath us and we just go back to the top of the loop. So what I'm implementing here is essentially a skip on five. So I'm not going to print out five if I is equal to five. That that's what I'm doing here when I run this code. And I've adjusted this slightly, but you'll see that when I run this now, we get 1 2 3 4. Notice we skip five because I had the continue here. And then we get 6 7 8 9 10. Okay, there you go. Now the next keyword is the break keyword. So if we rewrite this loop, we can actually do it like this. We can say while true, we can say console.log I, we can say I ++ and we can say if I is equal to 10, then break. Okay. Now what I've done is just written the same loop that we looked at before except rather than having a condition up here, I've used a different pattern or a different way of writing this where I implement a break. Now what the break does is simply exit the while loop. As soon as you see the break keyword, you just escape the loop. So we say while true constant log I add one to it. But if I is 10 break out. So now if we run this, you see that we get the same thing 0 through 9. Okay, perfect. So that is the while loop. And now we're going to use it to actually validate our input. So what we're going to do is the following. We're going to say while true and we're going to put this number inside of here. Okay. Next, we're going to say if and then is nan number one then we need to console.log invalid input. Okay. Otherwise we are going to break. So this is nan function here simply checks if something is not a number. So if when we try to convert this to a number it gives us is nan then that means this is invalid. So we just print invalid and then we ask them for a number again. Otherwise we break out of the loop. It's as easy as that. So I wrote a simple while loop. I said while true. So this means loop forever. Now, by the way, if you fail to have a break keyword and you have a loop that has while true here, then you're going to have something known as an infinite loop, which means you're just going to be running forever and it's never going to stop unless you manually close the program. So, you want to avoid infinite loops and make sure you always have a way to exit them. Okay, so we have while true, ask for the number, convert it to a float. If it's nan, that means it's invalid. So, we print out invalid and we ask them to try again. So, let's test this out. We're going to go here and we're going to say hello invalid number. Okay, this this invalid9 and you see that that works. Okay, perfect. So, let's just get out of this. Now, I want to do the same thing for number two. So, we can just copy this and paste this here, but change this to say number two and then say enter number two and then change this to be number two. Okay, so let's run the code now and just make sure it works for both operators. So we're going to say uh nine. Okay, invalid. And then it works. We can do our plus. Uh and we get an issue here which I'm going to talk about in one second. Okay, so let's fix this problem. So this problem here that we're seeing is it's saying that number one is not defined. Now the reason it's saying number one is not defined is because I've defined this inside of the while loop. Now when we use this const this means that this variable that we've defined is local to where we defined it. So in this case it's defined inside of the while loop. Now I don't want to get too far into something known as scope here. But essentially to fix this issue what we can do is say let number one like this and we can also just go let number two while we're at it. And now rather than using this const we can just remove that and say number one and number two. So now these variables are defined in this what's known as the global scope because it's like the furthest left in the program. It's not inside of any blocks. So that means that this switch statement now will be able to access number one and number two. Okay. So let's run this and test this out. Okay. 1 2 plus. And we see that we get the result we're looking for. Okay. Now any of you uh that are being kind of uh what do you call it? vigilant here, I guess, would notice that we have pretty much the exact same code two times in a row. Now, if you know anything about programmers, they're lazy. They don't like writing the same thing multiple times. There must be a way to optimize this or make it better. And in fact, there is using something known as a function. Now, a function is a way that we can write reusable code. I'm going to go down to the bottom of my program and introduce a basic function and then we'll show you a more complex one. So, a function works like this. You just say function. You give the function a name. And by the way, the name of the function follows the same rules as the naming for variables. So it can't start with a number. You can use underscores. If you have multiple words, you can't use spaces, for example. So I'm going to do function and let's go maybe get number is what we want. And I'm going to write a set of parentheses and a set of curly braces. Now this function is something that's callable and can contain reusable code that we can call whenever we need it. So pretty much the way that this this will work is you have this function named here this way. So the way this function will work is you have a name you have a set of parenthesis and inside of the parenthesis you can take what is known as a parameter. Now a parameter is input to the function that you can then use within the function. It's like a variable you pass to the function. Now within the function you can do something and if you want you don't have to you can return a value. Okay, so we've actually already seen functions and we've been using them a ton. In fact, parse float, this is a function. This is a parameter or a value we pass to the function. And the float function here returns a value to us. It returns a number. Okay, so we're going to write our own function that does this. So let me show you here. I'm going to say get number and I'm going to take in just some number. Okay. Now, this will be like what number we want. So, it'll be like number one, number two, like the number of the number we want. I know it's a little bit confusing, but that's the parameter that I'm going to take in. And in fact, uh let's just call this number string maybe to make it a little bit more clear. Then, what we can do inside of this function is we can copy what we had here. So, let's copy this and I'll show you how we write the code in a function. So rather than saying number one is equal to parse float, we're just going to say const number is equal to parse float. And then same thing with is nan because this function is going to be reused multiple times. Now rather than having enter number and then one, what I'm going to do is write a string concatenation. So I'm going to say enter number plus the number string plus and then this is going to be a colon and a space. Now the reason I need to do this is inside of the prompt function I cannot pass commas or different values. So I just need to pass one string. So I'm going to create one large string. Now number string is going to be like this like first second. So it's going to say enter number one or sorry number string is going to be one or two or three how I have it here. So it's going to say enter number one enter number two enter number three etc. That's what I'm kind of trying to get at here with this input. So now we check all the same stuff that we did before except this time what I can do is rather than having the break here I can say return and then I can return the number that we got. Now this return keyword allows us to give a value back to whatever called the function. So the way you call a function is you write the name of it, you put a set of parenthesis and then any parameters that it needs you pass them. So I could say get number and then you know we could say one or two and then what will happen is this is going to return to us whatever the number is that the user typed in. That's how the function works. But the great thing is is I can call the function multiple times and reuse this code in as many places as I need and really write some cleaner easier to understand code. Okay, there's a lot of other benefits of functions but that's how it works. Now this return keyword can be used multiple times. However, as soon as this keyword is encountered, the function immediately exits. So, the reason I removed the break keyword here is that we don't need it because the return acts as a natural break for this while loop where as soon as we see return, anything that's happening in this function stops and we go back to wherever this function was called. I know it's a little bit confusing, but I'm just going to take this now and show you how we use it. So, let's remove this and this. Okay. and we're going to go to the top of our program because typically we write our functions at the top and we're going to put get number. And now we're just going to use it. So we're going to say const number one is equal to get number and we're just going to put one. And then we're going to do the same thing for number two. So let's copy this and paste it and go with two and then number two. Okay. So now we're doing the exact same thing we had before except we're reusing this code inside of a function. So we're not writing the same thing multiple times. Now one thing to note, you can take in multiple parameters. So if you wanted to, you could write another variable here that's required for the function and then you would have to pass it like this. We're going to look at more functions later on. So don't worry too much about them. But this is a way to write reusable code and it's very important and we use it a lot. Okay. So now we have this function that gets number for us. we handle a lot of the stuff that's going on here with the arithmetic. So, let's run the code. Let's enter a number like this. Okay, invalid input. Let's go 98. Let's enter something invalid. Okay, invalid because we're using that function. Let's go -9. And let's divide them. And there you go. We get 10.88889. Great. Now, we can try this as many times as we want. But let's see what happens if we do something like this. 89 0 and then division. Now notice that gives us infinity. Now we probably don't want infinity. Instead, we probably want to give like a zero division error. So let's see how we can fix that. I'm going to go to my division here. And I'm just going to add a check. I'm going to say if and we're going to go with what is this going to be. If number two, which is the one that's at the bottom, is equal to zero, then I am going to do the following. I'm going to say valid equals false and console.log zero division error. Okay, otherwise actually we can still set the result because it doesn't matter. Uh but then down here we just won't print out the result because well it will be invalid because valid is equal to false. Okay, so I just want to check that this works. So let's run this. enter some number zero uh divide and we get zero division error. Okay, so that's pretty much it for project 2. Uh all of this code will be available from the link in the description by the way in case you want to paste any of this in. But I just wanted to show you for example the while loop, the switch statement, how you do things like convert strings to numbers, different errors that can pop up, how we write a function. Uh so hopefully you learned a lot from this project. In the next one, we're going to learn even more. The idea here is I want to build a simple application that allows me to manage my contacts. So something like a contacts app in your phone. A contact is just going to have a name and an email, but technically we could add as many values to it as we want. Now this contact app is going to have some different functionality. We're going to have the ability to add a contact, delete a contact, search for a contact, view the contacts, and then exit the application. So I want to start by just defining what that functionality is and kind of setting up some routing in my application because this will be a little bit larger and showing you how you create something slightly more complex. Anyways, let's get into it. So let's start by importing prompt. We're going to say const prompt is equal to require prompt dash sync. And then we're going to call this and I just want to print out anformational message here that kind of displays the functionality. So let's make a function. And to do that, we're going to say function and we'll just say print info. This doesn't need to take in any parameters and it doesn't need to return anything. And we can just kind of log some information about the system. So we can say contact management system like that. We can go console.log and we can print out some of these. We can say console.log. And then I'm going to define the different operations we could perform. So the first operation is going to be add a contact. Okay. Then we're going to go to delete a contact. Then we're going to go with three which will be view contacts. Then we're going to go with four which will be search contacts. And then lastly, we're going to go with five, which will be exit. Okay, so let's test this out. Let's call the function print info. When we call the function, it will just run this, and we should get some information. So, let's go clear and run. And oops, I'm running the wrong app. So, let's just go through this. Okay. And let's change this to be project 3.js. And you see that we get some information. All right. So now that we've got this, what we're going to do is start setting up kind of some routing in our application. So what I'm going to do is make a switch statement. And that switch statement will handle the different operations that the user could potentially enter. So let's start with print info. That's fine. And then let's do kind of a prompt here. So we're going to say const. And this is going to be number is equal to prompt. And we're going to say enter an operation. Okay? Okay. And that could be 1 2 3 or 5. And we can kind of give them some hints here by saying, you know, it's 1 through 5. Okay. Then here we're going to set up the switch. So we're going to say switch on number. Okay. And remember that number is a string. So what I'm going to do is set up some cases. So I'm going to say case one and then break. And then I'm going to say case two and then break. Now I'm just kind of setting up what we'll handle in these different cases. And then we're going to say case three and then break. Case four and then break. Not broadcast channel. And case five. Oops. What's going on here? Okay. Come on. Case five. And then break. And then lastly, we're going to do a default case. So I'm going to say default. And then I'm going to go console.log. Maybe we'll go unknown. and then we will break. Okay, now let's actually I don't know why I added these spaces. Let's remove them so it's easier to read for now at least. But the point is we now have five different cases. Now for each of these cases, we're going to handle the different operations. And what I actually want to do ideally is just ask the user to keep entering these different operations. So what I can do is simply set up a while loop here. I can say while true and then I can put the switch inside of this. Okay. So, if we want, we can kind of indent this in so it's a little bit cleaner. And let's make this a little bit larger. Okay. So, while true, we're going to do this. We're just going to keep asking them to enter operations. Now, the first thing I want to do is I want to allow the user to get out of this loop. So, actually, we'll set up a variable and we'll just say let keep going equal to true. And then we're going to use keep going here. So I'm going to say while keep going and I'm going to go to case 5 and what I'm going to do is say keep going is equal to false. So all I'm doing in case 5 is saying hey if we type in five that means we want to exit right that's the operation we have here. So we're just going to set this variable equal to false which means we'll stop looping. So we'll stop kind of handling the routing of what it is that we want to do. Now, for the rest of the cases, I want to set up a function that allows us to kind of handle what we need to do. So, I'm just going to write five functions here. So, I'm going to say function add contact. Okay. I'm going to say function delete contact. I'm going to say function search contact. And I'm going to say function list contacts. And for this, I'm going to take in the contacts that I want to list. Okay, we'll talk about that in a second. But here are the four functions that we need. So now I'm just going to call these functions. So from one, I'm going to say add contact. From two, I'm going to say delete contact. From three, I'm going to say search contact. And from four, I'm going to say what was this one? Uh, list. I think actually I have it in the wrong order. So this is going to be search contact. And this, I believe, is going to be list contact. Okay. And this is list contacts. So I think that's what we have. Uh yes, looks good. And then we have to remember pass contacts here. Okay. So now this is like the router if you want to think of it like that. So what happens if you type in one, we go to this function and we do whatever we're going to put here. If you type in two, we do this. And this is how I like to start writing my programs because it gives me really clear kind of separation and allows me to write one of these functions at a time, which just makes my life so much easier when I'm programming. So you can kind of see like I'm writing this from scratch. I haven't written this before. So I'm just planning things out by kind of making these different functions, some different areas in my code. So now I just need to tackle one function at a time. But before we can do that, we need to learn about arrays. Because arrays are how we're going to handle storing our different contacts. Now, an array looks like this. Const a ar r r is equal to a set of square brackets. It's essentially a way to store multiple elements that have a position or an index. Okay? So, we can say const array is equal to a set of square brackets. This is an empty array. But I can put some values in here like 1 2 3 4 5. Now each one of these values is accessible using their position or their index and their index starts at zero. So let me just go the comment here. So number one or value one is actually at position zero or index zero. Two is at position one, three is at position two and four is at position three. Okay? So you always start counting at zero when we're talking about the index or the position in the array. Now the reason that's important is with this array I can modify a value by using its position. So I can say array use these square brackets at zero is equal to something like 9. If I do this now the value here will change and we can prove that by printing out our array. Let me just comment out the rest of this code. So when I run it we just get this. Okay. So if we look here and we run you see we get 9 2 3 4. Okay. So you can access values using their index or their position and you can change them as well. Now if I wanted to, I could just maybe print out the value of array at index one and that's going to give me two because I'm accessing this which is the second position, right? Which is the first index. So I know it's a little bit weird, but we start 0 1 2 3. Now a few more things about arrays you need to know about. You can access their length using.length. So if you want to see the length, you can do it like that. And there's a bunch of methods you can use on arrays. So one of the reasons arrays are useful is that you can actually add values to them. So I can say array.push and I can push for example the value 10 and then print out the array. And you'll see now when I run this the 10 gets added to the end of the array. So the size has increased. Now just like we can push values into the array we can pop them or remove them. Now when we pop this simply removes the last element from the array. So when I run this now we get 1 2 3. Now we also have the ability to splice. So splice can remove an element based on its index. So if I wanted to remove three I would go splice two and then comma one. Now the one here specifies the number of elements after the index that I've specified that I want to remove. So when I do 2 one that means just remove this element. But if I were to make this two that means we're going to remove three and four. So you can see here if I go and run my code I get 1 2 4. Okay. So that's arrays. But next we're going to talk about objects. Now objects are a way that we can group information together. So here's an example of an object. I can say something like const contact is equal to I use a set of curly braces and then I can do something like name is equal to Tim and maybe email I need to do a comma here though is equal to timgmail.com. Now an object is like a key value pair. We have a key which is known as a property. So that's this right here. We do a colon and then we can assign some value to it. Now in this case I'm assigning a value like a string. But I could assign a list. I could assign uh another object. And sorry when I say list I mean array. I could assign another object. I could assign a number. I could assign a boolean. It doesn't matter. We can put anything that we want here. Now these properties can be accessed in the following way. We can say contact dot and then we can use the name of the property. So like name or email if we wanted to access it. If we want to change it, we can do contact.m email is equal to something like this. That's perfectly valid. And we can also add additional properties or we can do something like contact name is equal to Tim and we can use this kind of square bracket syntax. So you can see how this would be useful for us to store for example a contact because we can group a name and an email together and we could have additional information if we wanted to. Okay, so that's how that works. Now a quick note here. You might have noticed that I defined my array using a constant yet I'm changing the array afterwards. Now the reason why this works is an array and also an object many types in JavaScript are what's known as mutable. Mutable means that once they're defined they can be modified. So it's different from creating a new array. We're modifying this array here. So the array itself is like the same array, but the contents of it are changing. So that's why const is allowed because I'm not adding a new array here. I'm just modifying the existing one because it's referred to as mutable. Mutable meaning changeable. Now, if I tried to do like array is equal to this, this wouldn't work because now I'm trying to take a new array and assign that to a constant variable. Okay, so hopefully that makes a little bit of sense, but that's a concept known as mutable or mutability. So, let's remove this now and let's now create a array. So, I'm going to scroll up here and I'm going to say const contacts is equal to an array. This is what we're going to use now to store our different contacts and it can grow larger and larger as we add new contacts. Now I'm also going to go to list contacts and I'm just going to pass this array now so that when we pass or we call list contacts it will show it and we're going to go in list contacts and just really quickly write out console.log and then contacts. We're going to make this look better later but for now we'll just print out the different contacts. Okay, great. So now after that we're going to go to add contact and now we have the ability to add a contact. So when we add a contact what we want to do is ask for the name and the email. We're then going to create an object that stores that information and add that to our contacts array. So I'm going to say const name is equal to prompt and then this is going to be name colon like that. I'm then going to say const email is equal to prompt and then I'm going to take in the email. Then what I'm going to do is create my contact. So I'm going to say const contact is equal to name name and email email. Okay. So we've just created an object and then we can just say contacts dotpush and we can push the contact. Perfect. So now we have the add contact function and we can test it out and see if it's working. So let's run this and we're going to go add a contact. We're going to go Tim and then tim@gmail.com. Then we can list the contact. So actually let's add another one. Let's go Joe and then Joe atgmail.com. And now we're going to do operation three. And you see that we get our two contacts and then we can exit with five. Okay, perfect. So, that is a good start. Let me make this a little bit smaller so it's easier to read. So, now we have the ability to list the contacts and to add them. However, we probably want the list to look a little bit nicer and to do something like kind of, you know, print them out a nice nicer formatted way. So, to do that, we're now going to learn about a new feature known as a for loop. Now, anything that you can do in a for loop, you can do in a while loop. Now, a for loop is typically used when you know the number of times that you want to loop. And usually you use it when you're interacting with some kind of structure like an array. You don't have to uh but it's very common to use it with arrays. So what I'm going to show you is a basic for loop. It looks like this. Just bear with me. We say for let and then we create some kind of variable. This variable is going to track the number of iterations that this for loop has gone through. So this will look familiar to the while loop. But I'm going to say for let I equal z. I'm going to say i is less than 10. This is my condition for looping. And notice I have a semicolon here. It's important that you have that to separate these. And then I'm going to have my increment or my change. So I'm going to go I ++. What I'm saying is I want to start I at zero. I want to loop while I is less than 10. And every iteration of this loop. So as soon as one of it finishes, I want to add one to I. Now I could add two to I. I could start in the reverse direction like let I equal 10. uh I is you know greater than zero and I minus minus if you want to pause the video and see how that would that would work feel free but you can do any kind of combination you want here but what's common is to loop up to you know some number for example and notice I know how many times the loop's going to run here so what I could do now is say console.log i and if we kind of comment out all of this let me just do it like this and I run my code you'll see that we're going to count up to 10. So we go 0 through 9. Okay, similar to what we did with the while loop previously. Now that's useful, but a lot of times we actually use this to iterate through an array. So for example, if I have an array like this and I have you know const array is equal to 1 2 3 or let's do something else. Let's go like apple uh you know peach pear. Okay, so we have some fruits. What I might do is something like let i equal z i is less than a r. a length and then I might print out ar at index i. Now what I'm doing is I'm using this for loop to loop through all of the values in the array. So what I'm doing is saying okay I'm going to treat i like the index. So what I'm accessing in the array I'm going to start it at zero because that's the first one and I'm going to go up to the array.length but I'm not going to include that one. Then I'm going to add one to i every iteration and I'm going to access the array at index i. So if I do this now, you'll see that when I run the code, we get apple peach pair because I'm looking at each index in this array and printing it out. Now if I were to maybe make a mistake and do less than or equal to, meaning we're going to go up to three, index three, which actually doesn't exist here, you'll see that what happens is we get undefined. So no crash or error occurs in our program, but we try to access an index that doesn't exist because array.length uh is not an index that's valid. It's only one less than the length of the array. So we got undefined. Okay, that's our for loop. So we're going to use the for loop now inside of list contacts, but we're going to use a variation of it that's a little bit cleaner. So we're going to say for and we're going to say uh let contact of contacts. So you saw previously that what I did is I accessed the values by their index. But we don't actually need to do that. What we can do instead is we can just use the structure itself and get all of the elements. So what you looked at before is iterating by index. This time we're going to iterate by item. So you can say let contact of contacts. This variable can be anything that you want. You just need to use let and then you can say of something like uh an array. And when you do this now JavaScript is going to give contact each of the values inside of the contacts array. So rather than having to access the index manually, this will just be equal to each contact in the order in which they exist in the array. And then we can print them out. So I can say console.log and I'm going to say contact.name and console.log contact. Because remember contacts are objects. Each object will have a name and an email. So once I access the object from my contacts list then or from the array sorry I'm going to keep using list because I'm used to Python. Then I can access its name and its email. And we can just add a little bit of formatting here and just go kind of name like this. And we'll go email like this. Okay. And what else do we want to do? We're just going to add something like this. Print. and then a bit of separation. So, let's just do some number signs so it's a bit easier to see. Okay. So, I just want to print out or test out my listing contacts. So, let's go here. Let's go add a contact. Tim tim@gmail.com. And let's list this with option three. And we got an error. What is the error here? It says print is not a function. Okay. My apologies. Where did I put print? Uh believe we might have put that. Where did we put print? Ah, okay. So I found it here. My apologies. This needs to be console.log. So let's test that again. Okay. Run one tim timgmail.com. And then we'll go three. And you can see that it prints out this contact. Now if we want to add another one, we can do that. So, let's go Joey and then, you know, joey@gmail.com. And we'll go three. And you can see that we now get both of our contacts. Awesome. Now, we probably want to uh just add a little bit of separation here to make this look a bit cleaner. So, what I'm going to do is after the operation, I'm going to say console.log and I'm just going to log an empty line here. Now, that's one way to do it. Okay. Okay, so now that we have that, I'm also just going to go to my add contact here. And after we add the contact, I'm just going to say console.log and then added. Okay, nice. So now we're going to move on to the delete contact. Now to delete the contact, what we're going to do is list each of the contacts, but this time we're going to list them with a number beside their name. Now we're going to do that so that we can delete the contact by simply referencing the number of the contact. So the idea is we'll print out all the contacts with like you know 1 2 3 etc beside their name and then we can just delete the one uh with what number we select. So if we select number two we'll delete you know contact number two. So to do that we're going to use a for loop and we're going to say four and this is going to be let i equals z i is less than contacts.length and then i ++. Now the reason I'm using this style of for loop now is because I want to know what number contact I'm on. I want to know the index associated with it so that I'm able to delete it later. Whereas here I don't care what contact I'm on. So I just do it like this. But if I want to know the index or the position then I need to use this style of for loop. There's actually other styles as well but these are the two most common ones. So now I'm going to say con contact is equal to and this is going to be contacts at index i. Then I'm going to say console.log and I'm going to log and we're going to go with I + 1. And then actually we're going to do something different so that you guys can see how this works. We're going to go I + 1 dot 2 string plus a colon and then this is going to be comma contact dot name. Okay, so I know this is a bit confusing, but what I'm doing is I'm taking I which will start out equal to zero and I'm adding one to it. That way we don't start with contact number zero. We start by displaying contact number one. We then convert this to a string. And the reason I'm converting this to a string is so that I can add a colon to it without having a space. So I take this expression which is i +1 which is a number. I uh surround it in parenthesis. And then that way I can take that whole thing and convert that whole thing to a string. That's how you do that by the way using tworing. And then now that it's a string, I can add it to this colon. And now that I can add it to this colon, I can then print out contact name after that using the comma separation so that I have a space in between. So let's just quickly test this first before we go any further. So let's go here and run this and add a contact and go name. timgmail.com. Uh let's go now to delete a contact. And you can see that it starts listing our contacts. So we have one Tim. Perfect. So what we'll do now is we'll just add maybe a console.log here and we'll say contact numbers or contact ids maybe. Okay. Then we're going to do a prompt here. So we're going to say const number is equal to prompt and we're going to say enter an ID. Okay. Now, we're just going to parse this as an int. So, we're going to imagine that they do give us a valid number. I'm not going to check for that input. And we're just going to make sure that this is within the range of our contacts. So, we're going to say if number is greater than contacts.length, then what I'm going to do is what's known as a naked or a bare return. And I'm just going to return. So, I'm going to say is okay, you know what? If you gave us something that's not valid, we're not even going to give you any uh error message. We're just going to return and exit the program. Now, we could give them an error message if we want to now that I think of it. So, we can just say maybe like this console.log invalid. Otherwise, we can remove the contact. So, to remove the contact, we can do the following. We can say contacts do.lice and we can splice at whatever the number is. They gave us minus one and then one and then console.log. So let's go back here. Removed. Okay. And let's add a capital R. Perfect. So pretty much what I'm doing here is saying, okay, we're going to grab uh this ID that they want to delete and convert it to an integer. If it is greater than contacts.length, and I guess I supposedly can do this, too. If it's nan, so if it's not a number or it is greater than context.length, then it's invalid and we can return. Otherwise, we're simply going to remove it by using splice. And the reason why I'm doing number minus one is because they're going to give me ID 1 or ID 2 or ID3. They're not going to give me ID zero. So, I need to subtract one from whatever they typed in to convert what they're typing in to the corresponding index that we want to remove from our contacts list or from our contacts array. Sorry if I keep saying list. In Python, it's list. In JavaScript, it's array and I usually work in Python, so I keep mixing it up. Anyways, point is this should work and it should remove the contact from our array. So, let's try this now. I'm going to go to add a contact. I'm going to go tim timgmail.com. Okay. Uh let's list it and we can see that we have that. And now let's try to remove it. So let's go here and what is the issue this time? Uh we got a problem saying parse int is not defined because I spelled parse incorrectly. So let's spell parse correctly this time. So parse like that. Okay, that looks better. Let's clear rerun. Whiz through this quickly. Okay, and then delete. And we're going to enter ID maybe two. Invalid. Okay. So, let's try again. Enter ID one. Removed. Print it out. And we don't have any contacts. Uh, and then we can quit with five. Okay. Amazing. So, now we have the ability to add contacts, to delete contacts, to list the contacts, and the last thing we need to do is search for contacts. So to search for contacts, what we're going to do is create kind of a results array. And we're going to put contacts in there where the name that the user typed is contained in that contact. You'll see what I mean, but let's start here. So we're going to say con uh search string is equal to prompt and we're going to say search colon like that. Now they're going to enter some kind of name. And what I want to do is check if that name exists in any of my contexts. So for example, I might have contacts like Tim, Timothy, and John. And the user might type in something like TI. Now since TI is contained within both Tim and Timothy, like this substring exists inside of these, that means that I would return these two contacts. Whereas if I type something like, you know, oh, well, oh exists inside of John, so I would return John. So that's the basic search kind of algorithm we're going to write. You can make it more complex if you want, but that's what we're going to do. Now, I'm also going to convert this to lowercase. So, we're going to take whatever they type in and just immediately convert it to lowercase. Okay. Now, we're going to use a for loop and we're going to say const results is equal to an empty array. And we're going to store our results in that array. And we're going to say for and this is going to be we'll go con contact of contacts and this should be a let my bad and what we will do is we will say if the search string or if the contact name doinccludes the search string don't worry I'll explain what that does in a second then we're going to say results dot push and we're going to push in the contact. Okay. So what I'm doing is I'm getting the contacts name and I'm using this dotinccludes. Now dotinccludes simply checks if whatever string I put here exists inside of this name string here. So it's doing exactly what I explained before. If it does, we're going to say results.push and we're going to push this contact into the results. And then lastly, we're going to say list contacts and we're going to list the results. So I'm using this function again, but this time rather than using all of my contacts, I'm just passing the results so that I can reuse this code. Okay, amazing. So let's test this out and see if that works. So we're going to say add Timgmail.com. Okay. One. We're going to go Timothy. Uh, Tim O@gmail.com. And let's go one. John@gmail.com. Okay. And then let's go three. Okay. We're listing them out. Let's go with four to search. And let's search for TI. And for some reason, we didn't get any results. And the reason we didn't get any results is because we've converted this to lowercase, but we haven't converted the name to lowercase. So what we're going to do is we're going to add a dot to lowercase like this. And by the way, this is valid even though it's not super clean. We can go contact to lowercase. And then we can check if this whole thing, which is the name converted to lowercase, includes this string. And hopefully that should work for us. So let's quit this and try again. Okay, we're going to go one Tim Timgmail.com. One Tim Oie timo@gmail.com. Okay. One John and then John at hotmail.com and then we're going to go and list and then search and we're going to search for TI. And you can see that we get Tim and Timothy. Now let's try searching again with maybe T I M O and we just get Timothy. Let's try searching with J O and we get John. Okay, amazing. Now for this project, we're just going to start by creating kind of a board where we'll store the X's and O's and this will allow me to explain the project a bit better. So what I'm going to do is make an array. And I'm going to call this my board. And I'll just start with a simple array like this. Now, what we're actually going to do is we're going to learn about a concept here known as a nested arrays or multi-dimensional arrays. Now, when we talk about a board, the idea is we're going to have certain rows and columns, right? For example, maybe we have an X, we have an O, we have an X, right? Maybe we have a blank, an X, an O. But you get the idea, right? This is kind of what our board could potentially look like. Now, in this case, we have three rows and we have three columns. And each one of the positions here we can kind of represent by their row and column position. So for example we could say you know this is uh column 012. And then we could have let's do it on this side. This is row one or sorry row 0 row one and row two. So if I want to access the middle position that would be position one one or we could say 1 one. Doesn't matter what way we want to read it. If we want to access this position we could say that's at 2. Okay. So, we want to find a way to do this or represent this in code. And that's where our multi-dimensional array is going to come in. So, what I'm going to do is inside of this array, I'm going to create three new arrays. Now, each one of these arrays is going to represent one of the rows inside of our board. Now, by the way, this is perfectly valid. You can have arrays inside of arrays. We can go to any level of nesting that we want. And what we'll do is we'll create some strings here. And we're just going to make them empty strings for now. Okay? case, we'll have a space inside of them. And we'll do that three times. Now, these are going to be the positions in our board. And don't worry, this will make a bit more sense in a minute, but I just want to kind of set this up. Okay, so now we have three rows. And inside of each of these rows, we have three strings. And these will represent the different positions in our board. So eventually, what we'll do is we'll place maybe an X here. We'll place an O here. You get the idea. Okay, that's what we're going to end up doing. Now, let's talk about how we use this array because this is probably something you haven't seen before. Now, this is again known as a multi-dimensional array or a nested array. And the way that I access the elements here is like this. So, if I do board and then I access index zero, that gives me the first element in my array, which is simply this array. So, it accesses this entire array. So, again, that would go to this array. Now if I wanted to access an individual position within the array, I would need to index it again. So I could do for example 0 0 and when I do that this portion accesses this array and then we have this array and I'm accessing the zero index on that which is the first position here or the top leftand corner. If I wanted to access this then I would do two. Okay. So we can kind of access which row we want and then what column within the row we want to see. Now that's the same if we want to change it. So I could do, you know, is equal to X or whatever I want. Uh, that's perfectly valid. So that's how a multi-dimensional array works and that's what we're going to be using here to represent our X's and O's. So the first thing that I want to do here is I want to write a function that allows me to insert an element inside of this board. So what I need to do is I need to get a row and a column that I want to insert this inside of. And then I need to know whether I'm inserting an X or an O. So I'm going to say function. And we're going to call this maybe make move. And what we're going to do is take in the turn and the board that we want to insert this move into. So the turn is going to be whether or not it's an X that we're placing or an O that we're placing. And the board will simply be this array that we're going to insert inside of. Now what we'll do is we'll start by collecting some input from the user. So we're going to say const row is equal to prompt. We'll write that in 1 second. and we're going to say enter row. Okay, so the user is going to give us the row and then they're also going to give us the column. So let's put that here. I'm going to say const call and then enter call. Now because we're using prompt, I do need to import that. So I'm going to say const prompt is equal to require and then prompt-sync and then we're going to call this. So now we're able to use that. Okay. Okay, so we're going to grab the row and the column. And just like before, what I want to do is convert these into numbers. So, we're going to wrap this in the parse int function. Now, we're just going to assume that they give us valid numbers here. Although, actually, we can handle if they give us not a number. We'll look at that in a second. And again, remember, I haven't already written this, so I might change some things around. I'm trying to kind of show you my thought process as we build this out. So, I have my board, and I want to just start by being able to insert X's and O's inside of here. So my idea is I'll ask the user to enter a row and a column that they want to insert their uh you know X or O into. So where they want to make their move. Okay. So we have the row and the column, but we need to check and make sure there's not already an element there that they give us a valid row and column. For example, if they say the row is seven or something, well, we only have three rows, so that doesn't make sense, right? Uh same thing if they give us a row and column where there's already an element, like they can't place something there, override it. So what we're going to do is we're going to make sure first of all that the row and the column are within the range of the board. So we're going to say if the row is less than one or the row is greater than three uh then we can say console.log invalid row. Okay. Otherwise we can say else if and then we can check the column. We can say if the column is less than one or the column is greater than three then we can say console.log invalid column and also while we're at it we can check if these are nan. So I can say if is nan row or this and I can say if is nan call or this and let me just move this over. Okay. So what I'm doing is I'm setting up some if statements, right? So I'm going to say if it's not a number or the row is less than one or the row is greater than three because we're going to get them to enter either 1, two or three, right? For the valid rows, then we say it's invalid. And same thing with the column. And then otherwise what we would do here is we would insert the uh correct X or Oro into the correct position. Now uh like before we want to keep asking them to enter a row and column until they give us a valid row and column. So what we can do is set up a while loop here and we can say while true if I can get the indentation here correct and then I can put all of this inside of here. Okay. So we're going to say while true do all of this and then in the else statement we're going to break out. Okay. So what will happen now is we're going to check all right is the row valid. If it's not then we're just going to print out invalid row. And then we would just ask them again to enter another row and column. Now same thing for the column. We're going to check okay is the column valid. If it's not then we're going to ask them again to enter a row and a column. Otherwise we're going to break. But before we break, I'm going to insert into the board whatever the user's turn is. So I'm going to say board row minus one and then call minus one is equal to and then this is going to be the turn. But I also need to make sure that there's not already something in the board. So let's check that as well. So let's make another else if and we're going to say else if the board at row minus one call minus one does not equal the space then we're going to say console.log invalid position. Okay. And we're going to fix our indentation. Okay. So I know I'm kind of doing a lot here but we're checking if the row is valid. We're checking if the column's valid. And then we're looking inside the board at the row minus one and the column minus one. The reason I'm subtracting one is because we start at the zero index, but we're going to have them enter like 1 through three. So if they enter row one, really we want to use the row at index zero. So we need to subtract one from what they've entered. So I look at the board at the row and the column position and I make sure that it's equal to a uh empty string or a space. If it's not equal to that, then that means that there's something else there. So we say invalid position. Otherwise, we're okay to go ahead and uh enter in whatever the return is to the board and then break. Okay. So, what I want to do now is I want to say make move. I'm going to do a turn of X and pass my board. And then I'm going to console.log my board. Now, I'm just going to repeat this two times and I'm going to make this with an O just so that I can test this out and see if it's working. Okay, so let's run our code and give this a test. So this is going to be project 4.js. And it says enter a row. So let's try maybe negative 1 and five. And you can see it says invalid row. Okay. So we need to enter another row. Uh so let's go row 2 column 4. Okay. Invalid column. That's working. Let's go two. Okay. Now notice we enter now in the middle position our X. Now it's working for the O. So let's do maybe 2. An invalid position because the X is already there. But if I do 1 one, you can see that we enter O at position 1 one. Okay, amazing. So that's working. Now what I want to do is I want to make it so that our turns alternate. So the first player is X, then the O player goes, and we keep alternating until the board is full. So let's remove this and let's set up a variable to keep track of whose turn it is. So we're going to say let turn equal X. And then we'll kind of toggle the turn from X to O as we go through here. I'm then also going to create a variable called turn count and we're going to make this equal to zero. And this is just going to keep track of how many turns have occurred. We're then going to say while the turn count is less than and this is going to be nine because the maximum number of turns that we could do is nine, right? Because we have nine positions we can enter in the board. And then I'm going to enter this while loop. Now the first thing I'll do is I'll just increment my turn count. So to say turn count plus+ to add one to it so that we know we're kind of on the first turn. Now actually yeah let's leave that there. But we're going to put that at the end of the while loop. I just like to add some kind of increment to make sure that I'm not going to get that infinite loop. Now what we'll do is we'll ask the user to make a move. So we're going to say make move and then we're going to put the turn and the board. Okay, perfect. Then we are going to cycle the turn. So we're going to say if the turn is equal to x, then what we want to do is say turn is equal to o. And I think that's an o, not a zero. Let me just make sure cuz they kind of look the same. Okay. And then we'll say else turn is equal to x. So all this is doing is just swapping the turn between x and o. So if the turn is equal to x, switch it to o. If it's o, we switch it to x. Okay. And then we increment our turn count down here. Perfect. Now, we also want to print out the board. So, let's go and say console.log. And then we'll log the board. We're going to write a function that will make this look a little bit nicer for us. Uh, but that's the basics. Okay. So, we have we're making move. We're kind of cycling between the two turns. And let's see now if we can enter kind of nine positions. So, let's go one, one. Okay. Let's go one, two. Let's go 1 3. Let's go 2 1 2 2. And you can see we're kind of switching between X and O. 2 3 1. Okay, that's invalid. So, we're going to go 3 2 3 3. And you can see we have our X's and our O's being entered in the board. Amazing. So, now let's make it so we print out our board a little bit nicer because obviously this is kind of difficult to see and it doesn't look very nice. So let's make a new function and let's call this just print board. Okay, so if I can type correctly here, function print board. Okay, I'm really struggling here. All right, we're back. Function print board. We're going to take in the board and we're going to print it out. So in order to print the board, what I want to do is print kind of each symbol and then have like a separator like this so we can kind of see the rows and the columns. Now, in order to do that, I need to actually loop through my board. So, I need to loop through each row and each column or each element inside of that. And that's going to involve using something known as a nested for loop. So, we're going to do one for loop to print the row. So, we're going to say for and I'm going to say let and we're going to go row equal z or actually let's go with i. Let i equals z. We're going to say i is less than the board.length. And then we're going to say I ++. Okay. Now, what this is going to do is loop through all of the different rows that we have in our board. So, we can say the const row is equal to board at index i. And that's going to give us this whole array. But now that we have this whole array, we want to print out each individual element in this row. So, what we're going to do is make another for loop inside of here that now is going to loop through the row that we have. So now what we can do is we can say four and we're going to use a different variable this time. So not I, I'm going to use J so that I can keep track of the row index as well as the column index. And we're going to say that's equal to zero. We're going to say J is less than. And then this is going to be board I.length. And then we're going to say J ++. Now the reason why I did B I sorry board I.length here is because we're looping through this row. So actually we can just say row.length length to make that a little bit more clear and we're just seeing okay how many elements are inside of this row. Now we know it's three but just to make it a bit more dynamic we're going to use actual length of the row we're looking at uh and that's how we'll iterate through J. So now we have one variable I and for every single time we iterate through our row and for every single time we do this loop here we're going to do this loop three times or however many rows or how many columns sorry we have inside of the row. So this for loop inside of here is going to end up running nine times because this for loop runs three times and then this exterior for loop runs three times. So because this happens three times for each one of this it ends up running nine times. This is a concept a lot of people get confused with. I feel like I didn't explain that the best. But the point is this runs three times, right? Every single time this runs, what's inside of here is running. And since this for loop runs three times, whatever's inside of here ends up running nine times because it's three times. Four three times. So you multiply them by each other and you get nine. Now you could keep going with multiple layers of for loops inside of each other. Uh but this is how this works when we iterate through our board or a multi-dimensional array. Okay. Now inside of here, what we need to do is print out the different symbols. But we want them all to be on the same line. So what we're actually going to do is create a string. And then once we finish creating that string, we're going to print it out. So what I'm going to do is say let and we're going to say row string equal to an empty string. Then what we're going to do is the following. We are going to say row string and we're going to say plus equals because we're just going to add a string to this. And we're going to add our row at index j. Now what this will do is add whatever element we have. So either it's a space or something like an X, it's going to add that to our string. However, we don't just want to add this. We actually want to add a little bit of spacing. So what we're going to say is the following. If so, we're going to put if statement here. If J does not equal row.length minus one, then we're going to say the row string plus equals. And we're going to add a space and a pipe. and then we're going to add another space as well. Now, what this effectively is going to do is it's going to add a separator between the symbol that we just added and the next symbol that we'll add. Now, the reason why I've done this if statement here is I only want to add this separator if we're not on the last element. The idea here is that if I'm on this position, right, so the last column, I don't want to add a separator after it. I only want to add separators in between. So that's why I'm checking to make sure um that I'm not in that last position when I add this separator. So what we're doing is creating a string and the string will look something like this. Okay, that's what we're going to get. So whatever's in the row, maybe it's a space, it'll look like this. If it's an element, it will look like this. Okay, so that's the string we're going to create. So then once we create the string after this for loop, we can just simply log it. So we can console.log the row string and then we can console.log a separator for the row. So, we're going to do this. Okay. But same thing here. I only want to log this separator if I'm not on the last row because I don't want to have a separator like this, right? I only want to have one in between the different rows. So, same thing as before, but this time we're going to use the I variable because this keeps track of the row and this keeps track of the column. And we're going to say if I does not equal and then this is going to be the length of the board. So, board.length length minus one. The reason why I use this.length minus one is that's the last possible element that we have inside of our board. Now, the reason I do board.length minus one is that this will give me the last index that I have inside of my board or inside of the array that I'm looping through. So, if in theory we made this larger in the future, then this code would still work. So, it's better practice than writing, for example, two because if you do two, then this only works when the board has three elements inside of it. Now, we know that's going to be the case, but here I like to use thelength minus one because that dynamically gives me access to the last element. Okay, so now let's use this print board function uh and see if this works. Maybe I made a mistake. Let's see. So, rather than console.logging the board, I'm going to print the board and we'll just pass the board that we want to print. So, now I can go up here and I can run and we're going to say enter row and let's go maybe 2 1. And you see that we get our board. Actually looks pretty good. So now let's go maybe 33. And you see that the O gets entered. Perfect. Now I'm just going to clean this up a little bit so it's a bit easier to read. To do that, I'm going to add a console.log. And we'll do that, I guess, after we print the board. So you'll make a move. It will then print the board. And I also just want to print the board one time and have a console.log log before we start just so you can see an empty board. You can make your move. Then we'll print out the board and then we'll add some space before the next person goes. Okay. Another thing I want to do really quickly is I just want to add a few more of these. So I'm going to add one more dash just so that we get a little bit of a nicer formatted board. Okay. So let's run this again and make sure it looks a bit better. Okay. So you can see now we have a space so it's a little bit easier to read. We can go 3 three. Okay. That gets entered. two one okay 3 2 you get the idea perfect okay so that works nicely and one more thing I'll add now is I'll just say whose turn it is so I'm going to console log an empty string and then I'm going to say console.log log. And actually, let's do that at the top of the program here. We'll say um maybe how should we do this? We'll say it is the and then turn players turn. So, this will just print out whatever the turn is, whether it's X or O, so we know whose turn it is. And actually, we can just go turn players turn like this, just so that it's not super long. Okay, so that is it in terms of printing the board and making a move. But obviously, we need to check if someone wins. So, how do we know if someone wins? Well, we need to check all of the lines that potentially exist here. So, we need to see if any of the rows are filled. We need to see if any of the columns are filled. And we need to check the two diagonals. Now, there's multiple ways that we can go about writing this, but I like to implement something that looks like this. So, I'm going to write a function and kind of show you one way to do this. Again, there's multiple ways that we can do it. So, I'm going to say function check win. Now, when we check the win, we're just going to take in the board. Now, inside of check win, what I'm going to do is write an array that contains all of the positions of lines that could potentially win. So, you'll see what I mean here, but I'm going to make an array. I'm going to call this lines. Now, inside of this array, I'm going to have arrays. And inside of those arrays, I'm going to have more arrays. just so I can kind of show you how this works. Now, what we'll start by checking is row zero. And what we're going to do is we're going to put the positions of all of the elements that would need to be the same in order for a user to win. So, we're going to say lines is equal to we have an array and the first array inside of here is one line. And that array is going to be 0 0 1 and 02. Now, what this is representing is these three positions, which is one line that could make you win. So, hopefully you get the idea, but I'm going to write all of the lines that could allow you to win. And then I'm going to check all of these lines and see if they're all filled with the same thing because if they are, that means you win. Okay, so we have this first line. That's row zero. Now, let's write the second line. So, for the second line, we're going to check row one. So, it's going to be the same thing, but now we're going to have row one. Okay. So, again, like 1 0 is this. 1 1 is this. 1 2 is this. So, it's the three positions that need to be the same in order for a win. We're going to call this row one. Now, you don't have to add the comment. I'm just trying to make it more clear for you. So, we're going to go two 0 2 one. And we have eight lines in total that we need to write out. Keep in mind there's many ways to do this, but this is just one way that I want to show you because it's common uh in certain programs. So, now that we do the rows, we're going to do the columns. So, now we're just going to switch it a little bit. It's going to go 0 0 and then we need to do this one. So, we're going to have 1 0 and then 2 0. Okay, that's going to be column 0. Now, we need to make sure that we have our commas cuz if we don't have our commas, we're going to get an error. So, let's add those. And now we are going to have the next one which is going to be 1 one or sorry one. Is it 1 one? No, it's going to be 01. And then it's going to be 1 one. And then it's going to be 2 1. I think that's correct. Yeah, because we're changing or we're keeping the column the same, but the rows are being changed. Okay, column one requires a little bit of thinking here to write all of these out. Next, this is going to be 02, one, two, and two, two. Okay. And that's going to be our column two. Now, we need to do the diagonals. So, for the first diagonal, we can go uh from up to down. So, up to down will look like this. 0 0 1 1 and 2. Okay. Okay. So, that's going to be, I guess, left to right, diagonal. Okay. I mean, I guess both of them you could say are left to right. Um, let's just go diagonal one. Okay. And now, let's add the other diagonal. So, for the other diagonal, we're going to start here. So, that's going to be at 02, and then one, one, and then we're going to be in row two, position zero. I think that makes sense. So yeah, that's 02 1 1 2 0. Okay, and this will be diagonal 2. So now we have all of the lines that we could potentially win on. So I'm just going to take in one more parameter here, which is whatever the current turn is. And what I'm going to do is I'm going to essentially check if they fulfill any of this line. So I'm going to say four and this is going to be let line of lines. So I'm looping through each of the lines. Now, for each line, I'm going to check all of the positions that we have, and I'm going to see if they're equal to the term. So, we're going to make a variable, and we're going to say let win equal true. I'm then going to say four and we're going to go position. So, let position of line. Now, what that's going to do is it's going to loop through all of these arrays that are inside of this array, which is the line that we're currently looking at. So again, kind of a nested for loop, right? The first for loop is looping through all of the lines and the second for loop is looping through all of our positions. So now we need to get the position. So we're going to say const and I'm going to do something you probably haven't seen before. I'm going to do row call is equal to pause. Now what this will do is it will simply assign the first element to row and the second element to call. So this is kind of a shorthand you can use when you want to extract the elements from an array because here we have an array with two elements and we know that corresponds with the row and the column. So what we're going to do is we're going to say if the and this is going to be line or sorry not line if the board at the row column does not equal our turn then we're going to say when equals false and we're going to put this inside of a set of square brackets or curly braces, sorry. and we are going to break out of this for loop. So what I'm doing is I'm saying, okay, we're going to assume that we've fulfilled the current line. Then we're going to go and look through each position in the line. We're going to grab the row and the column and we're going to check if the row and the column. So if the uh element that's in the board at that position is equal to the player's current turn. If it's not, that means that this line is not fulfilled. So we're going to say win is equal to false and we're going to break out. Now what we can do here is we can say if when and notice this is outside of this for loop and here if when we can just return true. Okay otherwise we're going to return false. Now let's look at this return. The reason why I can do this is because if this win variable is still true after I checked the line it means that I've fulfilled one of the lines because we didn't set it to false. So it means that all of these elements were correct. They were the player's turn. So we've fulfilled a line. We've completed a line. So we can just return true. Now if it's not true, we just go and we check the next line. We just continue checking. Now if we get to the end of this for loop and we've checked every single line and none of them are fulfilled. So win never is true. It always gets set to false. That means that we haven't yet won and we simply return false. So now this will check the win for the board and for a player's turn. So what I can do is call this after the player makes a move. So we can print the board. We can console.log and then we can say const win equals check win and then we can pass the board and we can pass the current turn. Now if the player wins at this point, if win is true, then the game is over and we can print that out. So we're going to say if win then we can say console.log log and we're going to say turn has one and then we're going to break. Okay, so if they win, we just break out of the for loop. And that should actually be it. Let's kind of take a quick look at this and we can run the code and test it out. So we have a make move function. We know how that works. We simply check if the move is valid and we insert this into the board. We then have a print board where we're doing some uh you know, I wouldn't say fancy, but at least some more complex stuff to create this row string and then print out a string that looks nice for the board. And then we have our check win function which checks all of the lines and sees if all of the values in the line is equal to the player's turn. If that's the case, they won. Now, what we're doing is we're checking if we win after every single move. So, after we make the move, we check if the player when they insert in that position has won. If they won, then we can go ahead and break. Okay, the only thing we're not handling is a tie, but we'll do that in one second. So, let's go to project four and let's try to win. So, it's the X players turn, let's go in the middle, so 22. Okay, O player's turn, let's go maybe in the top corner. So, 1 one. Okay, for X, let's go in maybe one, two. Okay, for O, um I'm not going to block because I want to win. So, let's go in maybe row two, column one. Okay. And then let's go in. What is this? Three and two. And there we go. It says X has one because we fulfilled this line. Now, we could test all of the lines if we want to, but for now, I'm just going to leave it as is um because we know that this is working. And I just know that the code is going to work properly. But really, if you're writing this on your own, you should test all the lines to make sure it works. Now, the only thing we haven't handled is a tie. So, let's see what happens if we tie. So, let's go 1 one. Uh let's go 22. Let's go. Uh, what do we want to do here? Maybe 1, three. Let's go in the middle. So, this is going to be one, two. Why is this difficult to figure out? Okay, I need to block that position. So, that's going to be three, two. Then, let's go down here. So, we're going to go into one. Okay, we need to block that. So, let's go in three. Okay, we need to block now. So we're going to go in 3 three and then we're going to go in 3 1. Okay. So at this point we tied. So we didn't get any player winning. So what I can do if I want to show that is I can just say console.log tie game. Okay. Now the reason why tie game works here is because if we get to the end of nine turns uh and we haven't yet won then we must have tied, right? That's just the logic. So we must have tied. So we can just print tie game if we exit the while loop. However, actually I need to think about something here. We only want to do this if the turn count was equal to 9. So we're going to say if the turn count is equal to 9, then we can print out the tie game. And the reason why we'll do that is because we only want to show tie game if all nine turns were completed and no one won. And actually that makes me think this might not necessarily work. uh because what's going to happen is someone could win on the ninth turn. So this is me kind of thinking through and you know making some mistakes. But what I can do is make a variable. I can say let's do it up here. Let one uh like this and what we'll do is just change this to say win and or sorry let's make this win. So now I have this variable win which I've defined and we can just make this equal to false to start. Okay. So we're going to say currently no one's won. Now, we're going to keep updating this variable, and eventually at some point, if someone wins, it will become equal to true. Notice I removed the const because now I'm using this one here. Then we say, well, if someone's won, let's print this out. Otherwise, we'll go down here. We'll set then we say if someone's won, okay, go ahead and print this out and then break. And then down here, I can just say if not win like that. So if we haven't won, so if one is still equal to false once we get out of this loop, then we can just log tie game. Okay, so that should work for us. So let's see if this works for the tie game. So let's go 1 one. Let's go 2 1. Let's go 31. Okay, let's go 2. Let's We need to block here. So it's going to be 2 three. Okay, let's go. Uh, I think I've set it up so that I win no matter what. Maybe. Whose player is it? Okay, let's go three. All right, let's go with 32. Okay, we need to block. So, 33. And then we're going to go one, two. Okay, and then it says tie game. Perfect. So, that is working. What we're going to do is have a large bank of quiz questions which we're going to store in a file. Specifically, we're going to use something called JSON, which I'll show you in a second. Now, what we'll do is we'll randomly select a bunch of questions from that file and then display them. Then, what we'll do is we'll present them to the user and we'll time how long it takes for the user to answer all of the questions and we'll give them their score to see how many they got correct. So, let's start building this out. And the first thing I want to do is get a bunch of quiz questions. Now, what we're going to do is make a new file. And this file is going to be questions.json. Now JSON stands for JavaScript object notation. And inside of here, we can write an object pretty much just like we did in JavaScript. So what I'm going to do is paste in a bunch of questions here. And I'll show you what the format looks like and how you can do the same. So you can see I have this large file here. And notice that what I've done is I've made a key called questions. Now, when we're using JSON, rather than in JavaScript, we need to have double quotation marks around all of our property values. So, we have questions. This is a property. And then what I have is a big list or an array. And inside of the array, I have a bunch of objects. Now, these objects have the question. So, you can see the question is here. It then has different options. So, these are the uh kind of multiple choice answers or I guess options or choices. And then you have the answer, which in this case here for this question is Jupiter. and I have a bunch of questions. If you want these questions, you can simply download them from the link in the description. You can go to GitHub and find this file or you can use something like chat GPT to generate this sample uh questions bank. Now, that's exactly what I've done. I just went to chat GPT. I gave it something that looked like this and I said, ""Hey, generate a bunch of questions in this format that I could save in a JSON file."" It then gave me this. So again, JSON, JavaScript object notation works the exact same as in JavaScript, except you need double quotation marks on all of your property values. You can't use single quotes. It needs to be double quotes. So that's what I've done. I have my opening brace, my closing brace, I have a key, which is questions associated with an array. And then in the array, I have a bunch of questions that follow this format. So we're going to start with that. and I'm going to show you how we can load this content into our project so that we can store all of the questions here and then we just need to change this file if we want to add new questions. Okay, so let's go over to project 5. Now I've made this new file and what we're going to do here is start by uh kind of importing uh prompt sync. So we're going to say from or not from that's Python. We're going to say const prompt is equal to require and let's go here and this is going to be prompt-sync and then we're going to call this. Then we're going to import something known as the file system. So we're going to say const fs static for file system is equal to require and we're going to bring in fs. Now this allows us to actually load in files. So I'm going to show you how we do that. So, we're going to make a function called load questions. Now, what we're going to do inside of here is we're going to use a uh kind of new block that we haven't seen yet, which is a try accept block or a try catch block. So, we're going to say try and then catch. And I'm going to discuss what this does. So, the try catch here is something that we can use to attempt to run a block of code. And if it fails, we can handle any exception that occurs. So what we're going to do is attempt to load a file, but if an error happens when we're loading that file, rather than crashing our program and showing an error message, we can handle that error. So what we can do is any code we want to attempt and if we're not sure if it's going to work or not, we put it inside of this try block. Then we can have this catch block afterwards and this catch block will be triggered only if an error occurs. So if an error happens in here then the error will be handled here inside of the catch and we can do something to take care of it. Now E this will actually be whatever the error is that occurred. So we can check the error look for something specific or we could just print it out. So for example I could say console let me do this if I can find the o console.log log error occurred loading file and then I can simply print out e like this and that's just going to show me what the error message is but it's not going to crash my program. Okay, then from here I'm just going to return an empty array because if we couldn't load the questions we're just going to return an empty array. So we have this try catch. Okay, again the catch is kind of what happens if something goes wrong inside of the try. And inside of the try. Now what we'll do is we'll attempt to load our file. So we're going to say const data is equal to fs read file sync. Okay, this is going to read in a file. And what we can do is say questions.json. And then we can specify the encoding format which is UTF8. Don't worry too much about this. Uh but this is just the essentially way that this file is encoded so that JavaScript knows how to read it in. Okay. So, we put the name of the file and it's important that this file is in the same directory where our project file is. So, for example, if this was on our desktop or something, not inside of the same directory, we wouldn't be able to read it. Well, we could, but we'd have to change this code. So, we need to have it in the same directory. So, we have project 5 and then questions.json is in that same directory or folder, which is why we're able to read it. Okay. So, we're going to attempt to read it, but this could potentially break. Like, something could go wrong here if the file doesn't exist or it's corrupted. And that's why we have the catch statement so we can handle an error that occurs. Okay. Then we're going to say const questions is equal to and this is going to be JSON.parse and we're going to parse the data and attempt to grab the questions. Now like I said this is JSON which stands for JavaScript object notation. So what we need to do is we need to take this JSON file and convert this into a JavaScript object. So that's exactly what this does. It takes what is a string, which is our data when we read the file, and then it uses JSON.parse to convert this to a JavaScript object. Now that it's a JavaScript object, I can use it just like any other JavaScript object, and I can access this questions property, which gives me the array containing all of my questions. Then I can simply go here and return questions. Okay, perfect. So that's how I load my questions. So now we're going to test this out by saying conqu questions is equal to load questions and we're going to go console.log and then questions like that. Okay. So now let's test our code and make sure this works. So we're going to say node and then this is project 5.js. And you can see that it prints out all of my different questions. Amazing. Now the next thing that I want to do is I want to randomize the order of my questions. So rather than having them in the same order, I want to randomly select uh a few of them. So what we're going to do is make a function called get random questions. Okay. Now what this is going to take in is our questions and the number of questions that we want. Okay. Number of questions, sorry. So maybe we're going to get three questions, five questions, seven questions, 10 questions, doesn't matter. But we want to randomly collect a certain amount of them. Okay? So in order to do this, the first thing we need to check is to make sure the number of questions passed is not greater than the number of questions that we have. So we're going to say if the num questions is greater than questions.length, then what we're going to do is say the number of questions is equal to questions.length. Okay. The reason why we're doing this is that if you try to get more questions than we have, well, we don't have that many. So we just need to set this equal to however many questions we actually do have. Okay. Then what we're going to do is we're going to shuffle this array. And shuffling the array, what that will do is essentially randomize the order. Now to do that, we're going to say const. And this is shuffled is going to be equal to our questions dot and this is going to be sort. Now inside of sort, I'm going to pass something that we haven't yet seen which is called an arrow function. Now an arrow function looks like this. We have a set of parenthesis. We have an arrow. So an equal sign and then a greater than sign. And then we have a set of curly braces. Now the curly braces is the body of the function. So like this is is here like you know what we want to do. Do do this is inside of the curly braces. And the set of parenthesis here is uh where we accept our different parameters. So again, it's literally the exact same thing as writing a function like this. There's a few minor differences, but it's kind of a nice way to embed a function when we need to pass that as an argument to a function. I know that's a little bit weird and kind of some jargon that I threw out there, but the way the dots sort works is it takes a function that defines how we're going to sort the array. Okay, so we say questions.sort and then we pass what's known as a sorting function. So for the sorting function what we take is so for the sorting so for the sorting function what we can do is simply say return 0.5 and then this is going to be minus math dot random. Now this involves understanding how sort works. So sort in JavaScript is a bit different than in other languages. Typically what you accept in sort is two parameters a parameter A and a parameter B. Now what the way that this works is it will compare different values in the array and it will store them as a and b in this function. So pretty much what will happen is if we have like a big array and we have you know a b c d etc. What will happen is a will get compared to b will get compared to c will get compared to d and all of the elements will get compared against each other um in some order. I don't want to explain exactly how the sorting algorithm works, but the idea is that we're going to write how we should compare these elements against each other. So A and B are two elements that we're comparing. Now, if we return a positive number from this function, that means that A is greater than B. If we return a negative number, that means that B is greater than A. And if we return zero, it means that they're the same. I know it seems a little bit weird, but the sort will take that positive, negative, or zero and use that to sort the array in ascending order. We can also have it sort in descending order based on how we write this. So, what I'm doing right now is I'm going to return randomly a positive or a negative number. So, I don't need to accept A or B because I'm not actually going to use them. And what I'm going to do is I'm simply going to take 0.5 and I'm going to subtract that from math.random. Now, math.random random is going to be equal to a number between 0 and 1. So if the number is greater than 0.5, I'm going to get a negative number. If it's less than 0.5, I'm going to get a positive number. Now, what this effectively will do for me is randomly sort the values because I don't care about what the values actually are. For every single value, I simply return a random number that's positive or negative. So, I understand it's a little bit confusing, but this is a simple way to do like a randomized sort. Uh again I don't want to get too far into the sort algorithm and arrow functions and some more complex stuff uh but it is somewhat required to understand what's going on. Anyways the point is this is shuffling and sorting the array for us. So now that we have the sorted array what we want to do is just take however many number of questions from that array. So what we can do is say return and then we're going to say shuffled and we're going to say slice which is a new method we haven't seen and we're going to slice from zero to the number of questions. Now the way the dots slice works is it gives us a slice or a portion of the array. It starts at this index and it goes to this index but does not include it. So if I slice 0 to for example three that gives me the first three elements index zero, index one and index two. Okay. If I sliced from like two to the number of questions, then that gives me index two and then whatever the number of question is. So it goes like two three. If number of questions was four, then it would just return index two and index three. So it does not include the number of questions index. But when we go zero to number of questions, that effectively gives us the first number of questions element in the array. Let me do a better example cuz I know it's a bit confusing. Let's say that we do a slice of 0 to two on this. If we do that, we get one and two. If we do a slice of one to four, then we're going to get index 1 2 and three. And we're going to stop at but not include four. Okay, so that's how the slicing works. So let's go back to what we had, which is zero and number of questions. So that gives us the number of questions from our randomized array. Okay, so now let's test this out. So we're going to say const random questions is equal to and this is going to be get random questions and then we're going to pass the questions and let's just pass maybe four and then we can console.log the random questions. Okay, so let's test this. And you see that we get 1 2 3 four random questions. If we change this to just be maybe two and we run this now, you'll see that we just get two random questions. And if we keep running this, you'll see we get different questions because it's randomized. Okay, amazing. So that is that we now have the questions. We have the random questions, but we need a way to display the questions and see if the user got them correct. So let's write a function that asks the user a question. We're going to say function ask question and we're going to take in a question. Okay. Now what we're going to do is display the question and then display the different options for the question and ask the user to enter a valid option. So we're going to say console.log and what we'll do is say question dotquest. Okay. Because again we have each question which is one of these objects and then we have the question which is some text. So we're going to display that question and then we're going to display the options. So we're going to say four and we're going to go with let option of question dot options. Okay. Now actually we're not going to do that because I need to know the number so that we can have the uh index of each question. So I'm going to say for let I equal zero I is less than question do options and then I ++ we're going to say const option is equal to question do options at index i. And then we're going to print out the index and then the uh option so that we can see we have you know option one, option two, option three, etc. Okay, so how are we going to do that? Well, I'm going to show you something new that we haven't yet seen. So I'm going to say console.log and this time I'm going to use my back ticks. So rather than using the single quotes, the double quotes, I'm using back ticks which are on the same key as the tilda typically on the top left hand side of your keyboard underneath the escape key. Now, when we use these back ticks, it allows us to embed variables inside of a string. So, what I can do is put a dollar sign and put a set of curly braces. When I do this, this denotes that I'm going to put a variable directly inside of here. So, this means I don't need to use kind of the plus sign notation or string concatenation. I can instead directly embed variables inside of the string. So, I'm going to say I + one. And I'm adding one because I don't want to show option zero. I want to start by listing option one. I'm then going to do a dot and then I'm going to embed another variable and this is going to be the option. Okay, so I get the option and then I have the index associated with that option. I'm just adding one to it and I'm going to list it and display that out. Okay, so before we go any further, let's just test this. We're going to say const ask or sorry not const, we're going to say ask question. Okay. And we're going to pass random questions at index zero just to see if this works properly. Okay. So, let's go here and run. And it says, what is the hardest natural substance on Earth? Okay. And what is the issue here? Question.options. For some reason, this didn't actually run. Uh, that's weird to me. So, maybe we called this something else. Options. And we have question.options. Hm. Okay. Okay, so what could be the issue here? Let's try to debug this together. So we have random questions zero. We ask the question by printing out console.log question.quest and then we say let i equal z. I is less than question. options i ++. We then get the option and we print it. But for some reason this for loop's not running uh because it's not showing us any options. Let's run this one more time. And yeah, same thing. We're getting this issue here. So I is less than question.op options. Aha, that's because we need to add.length. So I forgot to add the llength. So we're comparing I to question.op options, which is kind of weird and that didn't work. So if we add the length, then we get the number of options that we have. And that should fix the problem. So let's try this now. And there you go. We can see now that we get the question and we can ask multiple questions. Perfect. So now let's try to get the user's answer. So we're going to get some input. So we're going to say con and we'll say choice is equal to prompt and we'll say enter the number maybe. Okay. So we're going to ask the user to enter the number and we're just going to check if it's equal to the correct option. So the correct option is going to be found in the answer. So we need to essentially take whatever the user's uh index is that they inputed, check what choice it was, and then compare that to the answer. So we're going to say const choice value is equal to and we need to first parse this as an int. Okay, so we're going to parse this as an int and then we're going to say that this is going to be question dot options and then we're going to find the choice minus one. Okay, so question.options options and then choice minus one. That looks good. And then we need to compare that to the correct answer. So we're going to say const correct is equal to the choice value. And this is going to be equal to the question dot answer. Okay. So there's a few more things that we need to add. But for now, if the user gives us a valid number, so 1 through 4, what we do is convert that to an int. And then we take whatever the number is that they give us. So whether it's four, three, whatever, and we subtract one to change the choice that they selected to the correct corresponding index because since we're adding one here, we need to subtract one when the user types in a value. Then we actually get whatever that option is. So the value of it, and we compare that to the correct answer. Okay, the only thing we need to add here is we need to make sure they do give us a valid number because if they don't then this line will give us an issue. So what we're going to do is the following. We're going to say if is nan choice or choice is less than one or choice is greater than and this will be the question. So let's do this. If we can type this correctly do options.length then that means that this was invalid. So we are going to say console.log and we'll say invalid incorrect choice and then we are going to return false. So my idea is from this function we'll return false if the user got the answer wrong and true if they got it correct. So now what I can do is rather than having just correct here I can simply return this expression which will either be true or false depending on if they get it right or wrong. And then down here what I can do is keep track of the number of correct answers. Okay. So now we've asked the question and I'm just going to say const correct is equal to this and I'm going to say console.log log correct just so we can see if they got it right or wrong. Okay, so we're printing out the question, we're printing out the options, we're converting the user's choice to a number, we're making sure that number is valid so that it's within the bounds of the choices and it's not not a number. Um, and if it's wrong, we're just going to say, okay, it's invalid choice and return false. Otherwise, we're going to check if it's correct. We're going to get the choice value, compare that to the answer. If it's correct, we return true. If it's false, or if it's incorrect, we return false. Okay, so let's run this now and let's enter the year. I think it's 1912 and we get false. Okay, so I guess it was in 1912. Uh, let's go. Oh, I entered 1912 when I needed to enter the correct choice. Uh, what does it say? Which planet is closest to the sun? I don't know this. Let's go with two. Okay, false. Let's try to get one correct. Uh, which is the largest planet? Jupiter, right? True. Okay, and then we got that one correct. Great. You're going to see I'm quite bad at these quiz questions, but that's okay. All right, so this is working. We have our three functions. We load the question, we get random questions, and then we ask the question. And we just tested that out down here with a few lines of code. Now, what we want to do is we want to actually kind of play the game. So, we need like a while loop that's going to go through and run through all of our questions. So, let's do that. Let's get rid of these lines and let's remove the number here. And let's actually start by asking the user to enter a number of questions. So we're going to say const and we'll say num questions is equal to a prompt and we'll say enter the number of questions. Okay. Now we're just going to assume that they give us valid input here. Okay. So we're going to say parse int. And then what we're going to do is pass that to our random questions. Now, we could validate this if we want, but I'm not going to do that because I've showed you how to do that many times now. Okay, so we have random questions now generated based on what the user gives us. Now, what I want to do is track how many they get correct. So, I'm going to say let correct equal zero. What I also want to do is track how long it takes them to answer this. So, I'm going to start a timer. Now, to start a timer, I'm going to say const start time is equal to and I'm going to grab the current date. To do that I can say date dot now. Now this is going to give me the current time and what I can do is simply check when they finish and subtract it from this and it will give me the number of seconds that have elapsed. Okay. So we have that we have the start time. We have the number of correct and now we need to loop through all of their questions. So we're going to say four and we'll say let question of random questions because we're going to loop through all of the questions that they have and we're going to start asking it to them. So we're going to say correct or const is correct is equal to and then this is going to be ask question and then we'll pass the question. Okay, then we're going to say if is correct, then what we will do is we'll say correct plus+. So if they got this question correct, add one to the number of correct questions. Then at the bottom here, we're going to calculate the time. So we're going to say const finish time is equal to or we can say I guess total time is equal to the date dot now which will be greater than the start date minus the start time. So what this will do is take the current time and subtract that from when we started and then that will give us the total amount of time elapsed. So now we can say console.log and we can say correct colon and then show the correct count. We can say console.log log time and we can show the total time and then if we want we can show maybe their average. So we can say console.log maybe score and then we can show a percent. So if we want to show a percent what we can do is we can take the correct we can divide that by the number of questions and then we can multiply that by 100. Okay. So, let's do this. And then let's take all of this and let's round it so that we get a nice even value. So, we'll say math dot round like that. And we'll just round this to two decimal places. So, I know this looks weird, but what I have is correct over number of questions. We're taking that and multiplying it by 100. We're rounding that as the first argument to math. And then we're rounding this to two decimal places. I believe that's how round works. Uh, actually, no. Sorry, I need to remove this. That's how it works in Python. But we just take this number and we'll round it. And then we can add a percent sign. So we want to add a percent sign. We can just say plus the string percent. And that should work. Okay. There's probably some things that I'm missing here. Uh but I think that's okay for now. And let's just do something and add a console.log here just there's a bit of space when we ask the question. Okay. So all I did here is write these lines of code. We're tracking how many are correct. We're tracking the start time. We're looping through all of the random questions that we have. For each question, we're going to ask it and check if it's correct. We're then going to place uh like kind of a separator so that we can separate the questions. And we are going to check if it's correct and then increment the correct variable. Okay. So, let's try this. Enter number of questions. Let's go with four. Uh which planet is close to the sun? I don't know if did we get this one correct? Uh what did I put? Mercury. Okay. In which year did the Titanic sink? Uh, let's go two. What is the hardest natural substance? Diamonds. Uh, who wrote To Kill a Mockingbird? I have no idea who wrote this. Let's go four. And it says we got three correct. The time was this, which is in milliseconds. So, I'm going to show you how we convert that to seconds. And we scored 75%. Cool. Okay. So, let's convert this, which is in milliseconds, to be seconds. Should be 18.3 seconds. Uh, to do that, we can divide it by 1,00. So we can take the total time and divide it by 1,00. And same thing, we can round this. So we can say math.round the total time over 1,000. And let's run this again. Okay. Uh let's just go two questions this time. What is the chemical symbol for O? Pretty sure that's oxygen. Uh the planet closest to the sun. Did we get that right? I don't know. Let's go Mercury. And we got two correct. The time was 9 and we scored 100%. Now we might just want to put seconds. So, what we can do is first let's remove these spaces so that it doesn't look weird. And let's just go plus and s. So, if we do plus s here, that'll just represent seconds. Let's run this one more time. Okay. To what is the capital of Canada? Ottawa. I lived in Canada, so I know that. What year did the Titanic sink? 1912. Correct. Two time 7 seconds. And score 100%. [Music] All right, so let's dive into the project. Now, the first thing to mention here is I do not at all support gambling. I'm just doing this project because it's a really good one for beginners and to really dive into code and kind of see how to create a complete project. But please do not gamble. I don't gamble myself and I would never encourage anyone to do that. Regardless, I'm going to quickly explain to you how a slot machine works in case you haven't seen it before. If you already understand, feel free to skip through. But here, we're going to do like a simplified version of one just to make it a bit easier for us. So, I have the whiteboard in front of me, and I'm just going to draw out in a very messy manner here kind of the idea behind what we're creating. So, we're going to imagine here that we have three reels. Now, in each of the reels, we're going to have three symbols. So, maybe we have something like a b c a b c. And then maybe we just do a a. Now, excuse my handwriting here. This is with my mouse. Now, what we're going to have here for our slot machine is three lines. Now, whenever you play a slot machine, there's a certain number of lines that you can win on. Usually, it's like 80 lines or 60 lines or a stupid amount. Uh, in our case, we're just going to do three, and they're just going to be each row. Okay? So, these are the three possible lines that you could win on. Now, you only win when you have three symbols that match in a row. So, in this case, we would have a win, but we would not have a win in either of these two rows cuz we don't have three symbols. Now, each symbol will have a varying multiplier. So, if I bet, say, $1 on the line, and the symbol had a multiplier of five, then that would mean that we won $5 on that specific line. And we're going to allow the user to bet on a certain number of lines. So, if they bet on one line, they just bet on this. So, they need to have something in this section. If they bet on two lines, then they're going to be betting on both of these lines. If they bet on three lines, then they bet on all three of these. And whatever bet amount they make is going to be multiplied by the number of lines that they bet on. So if they bet $1 on three lines, then they bet $3 in total. And if they get symbols in any one of the rows, then they're going to win a certain amount of money based on what the multiplier is for that symbol. [Music] All right, so let's dive into it here. First, we just have a little bit of setup. I'm using Node.js, so make sure you download Node.js. I can leave a link for that in the description. And then I'm using Visual Studio Code. Feel free to write your code wherever you want. Now, I've opened up a folder here on my desktop where I'm going to be writing the code. And the first thing I'm going to do is create a new file. So, I'm going to say project.js. Uh, this is my JavaScript file. Then, I need to set up a uh kind of node directory here because I'm going to install one package, which is going to allow us to get some user input. So I'm going to go here to my terminal. Notice I'm inside of the directory where I'm going to be working and I'm going to type npm init. Now this command will only work once you've installed Node.js. If for some reason it's not working and you installed Node.js, then restart VS Code or your terminal or restart your computer. Come back in and then the command hopefully should work for you. Okay. So when I type npm innit, it's going to walk me through kind of setting up all of this information. You can fill it in if you want, but you don't have to. I'm just going to click enter through all of this. And now you're going to see that we have a package.json file inside of our directory. Now that we have that, I have the ability to install my package which I need which is called prompt and then sync. So npm i prompt-sync. This is what we're going to use to collect user input. So go ahead and run that command. Again, just installing that package. To do this again, you need no.js installed. Need to be in some directory. And whenever you're in the directory, type npm init npmi or npm install prompt sync. Have some JavaScript file ready to go. And now we can start writing our code. [Music] So the first thing I'm going to show you how to do here in JavaScript is collect user input. But before I do that, I quickly want to explain kind of the steps that we need to go through uh so that we understand what it is that we're going to be building before we start writing any code. This is an important step whenever you're working on a project. You want to kind of break it down into some subcomponents so that you know what it is that you actually have to do and then you can prioritize those tasks. So let's do some comments here. I keep thinking I'm in Python using the pound symbol. But the first thing that we need to do here when we're setting up a slot machine is we need to know how much money the user has to play with. They're going to deposit or put some money into the slot machine. So the first thing we need to do is deposit some money. Okay. Next thing we need to do is determine how much the user is betting on the slot machine. So we need to collect a bet amount. But before we do that, before we determine the bet, we probably need to know the number of lines that they want to bet on. Do they want to bet on one line, two line, or all of the lines, which in our case is three? So, I'm going to make another comment here to uh determine number of lines to bet on. Okay. And then three is collect the bet amount. Now, next, we need to actually roll the uh slot machine or spin the slot machine and then see if the user won. So, we're going to say spin the slot machine and then five, check if the user won. And then lastly, after we check if they win, we need to then give them the money, right? So give the user their winnings or in the case where they lost, then we would take their bet, right? And then lastly, we probably need to play again or handle a situation where the user has no money left. Okay, so those are our seven steps. So what I like to do now that I have these steps and I've kind of thought through the program a little bit is start going through them one by one. it doesn't really matter the order that I complete them in. Uh but kind of creating little pieces of code or functions that implement each step or each thing that we're doing. So let's start with step one that kind of makes sense where we're going to collect a deposit from the user. So to collect a deposit, we're going to create a function. A function is a reusable block of code that you can call that's going to do something for you. So don't worry about it too much if you haven't seen functions before. There's two ways to create them in JavaScript. The first way is to write function and then to give the function a name. In our case, the name of the function is going to be, if I could spell this correctly, deposit. Then you're going to do two parenthesis like this. Any arguments or parameters you have for the function are going to go inside of here. These are things that the function may need to handle that you're going to pass in to the function for it to use while it's doing some code. In our case, we don't have any of those. We just want to get a deposit. And then we're going to open two curly braces like this or open a curly brace and close a curly brace. And then inside of these is going to be the body of our function which will run when we call this function. So I can call the function by writing the name of the function and then putting two parenthesis like this. That's going to call the function trigger it to run. Function's going to do whatever is inside of the curly braces or the body of the function. And then we have the ability to return something from the function. So for example I could return one. If I return that, it's going to be returned to where the function was called. So in this case, if I had a variable and I said const x equals deposit, then what that means is that if I return one, the variable x is going to be equal to one because that's what this function call returned. Hopefully that makes sense. But that is your 202 lesson on how functions work. Now this is the first way to make a function. The next way to make a function is to do the ES6 style, which is to write a variable. So, in this case, I'm going to do const, which stands for constant, meaning this variable does not change. That's going to be the case for our function. I'm going to give it a name. Uh, I can't name it deposit because that's what this one is named, but that's fine. I'm going to get rid of this. So, let's comment that out. Then, I'm going to say this is equal to and then a set of parenthesis. Then, I'm going to kind of make an arrow here. So, an equal sign and then a greater than sign. Then, I'm going to open my curly braces. And this is exactly the same as this function right here. At least that's the way that you can think of it. So in fact we're going to use this style of function because this is kind of the newer style that most people are using. Works the exact same way is called the same way and we can return stuff from this function. Okay. So inside of the deposit function, what we need to ask the user to do is to enter a certain amount. So how we're going to get the user input is using the package that we installed called prompt sync. So the way that we're going to do that is import the package. So we're going to say const which stands for constant. We're going to say prompt, which is going to be the name of the function we're going to use in a second. This is equal to, and then this is going to be require, and then prompt sync like that. And then make sure you add another set of parenthesis here because what we actually need to do is require this package or this module that we're using that kind of imports it into the program. Then when you call this um with these parenthesis here, it's going to give you access to a function. I know it's a bit confusing that you can use to get user input. Okay, so now that we have prompt here, we're going to say const and then we're going to say uh let's go with deposit amount is equal to and then this is going to be prompt and then inside of parenthesis we're going to put a string which we do two quotation marks for and we're going to say uh kind of what we want to ask the user. So, I'm going to say enter a deposit amount. Then I'm going to do a colon and a space. I'm just doing a space so that when the user starts typing, they have a little bit of space from the colon. If I didn't do a space, they'd kind of be typing their deposit amount right beside the colon. We don't want that. We want them to have a little bit of space. Okay. And then I'm going to come here and just for testing purposes, I'm going to call the deposit function. Okay. Okay, so I know if you're new to programming, this might be a little bit overwhelming, but all we're doing here is asking the user to enter a deposit amount, storing that in this variable, and then I'm calling the function. So when I call the function, it's going to run the code inside of here, and then it's going to ask the user to input something. They're going to input something, and that's all we have for the program right now. So how do we run this code? Well, we're going to use NodeJS. So we're going to go to our terminal. Make sure you're in the directory where your uh project file is or where your code is. and you're going to run node and then the name of your file, which in this case is project.js. So it says enter a deposit amount. And then notice my cursor is here and I can start typing. So I'm going to type something like 100. Perfect. I've now entered my deposit. Okay. So now that we have the deposit amount, what we need to do is convert this deposit amount to an integer or to a number type in JavaScript because by default, what's going to be returned here by the prompt is a string. A string is anything that's inside of double or single quotation marks. So, we're going to convert this to a number. And the reason we want to do that is because we're going to have to be subtracting from it, adding from it, etc. And we also want to make sure the user entered a valid number. For example, if they enter, then they have no balance and well, they can't play. So, the way that we convert this to a number is the following. We're going to say const number deposit amount is equal to and then this is going to be parse float and then deposit amount. Now this parse float function is just going to take a string and it's going to convert it into its floating point value. So if I had a string that was like 17.2 then that function is going to give us 17.2. Pretty straightforward. Now if we have a string that is not a number so a string like hello and we use this parse float function it's going to give us something called not a number so nan like that and if we get not a number that means that they didn't enter a valid deposit amount and we need to ask them to do that again or we can just quit the program and they would have to try again. Kind of up to you what you want to do there. I'm going to make it so they have to enter the number again. All right. Sorry for the cut there. My cat was going a bit crazy so I had to deal with that. Anyways what we're going to right now what we're going to do now is check if this is a valid number. So to do that we're going to say if and then we're going to use a function called is nan. Now is nan checks if something is not a number. So I'm going to say if is nan number deposit amount or and you represent or with the two pipes here two vertical lines on the keyboard or number deposit amount is less than or equal to zero. Then we're going to say console.log log uh invalid deposit amount. Try again. Okay, so we're just simply checking is it not a number. If it's not a number or the number is a number but it's less than or equal to zero, then this is invalid. So we need to tell the user that. Hopefully that makes sense. I don't think I need to explain that much more. Okay, so let's quickly run the code and just make sure this works. So I'm going to say node project.js. I'm going to enter hello. And then notice I get invalid deposit. Try again. Now if I enter a number like 10, all is good. If I enter a number like negative 10, then same thing. I get an invalid number. Okay, perfect. Now next, what we need to do is return the number from this function. And we also need to make the user enter a number again if it's invalid. So the way we do that is the following. We're going to say while true. And then we are going to put all of the code that we just wrote inside of this while statement. Now this while statement is a loop. This here is the condition for when we should continue looping. So right now I'm saying while true, which just means forever. So it's essentially an infinite loop. We're going to continue to do this. So we're going to ask the user to enter deposit amount, convert it, and then we're going to check this. Now, in the case in which this is a valid number, so in the else case here, we're simply going to return the number deposit amount, which is going to break this while loop. Hopefully that makes a bit of sense, but we're looping forever. Okay, so we're just going to continue to keep looping. We do this. We check if it's an invalid deposit amount. If it is, we're going to console.log this, and then we're just going to ask the user to do this again and continue asking them until they give us a valid amount. Now, otherwise, which is where this else statement comes in. So if this is not the case, then we're going to go in this else statement and we're going to return the number deposit amount to this deposit function call. So to show you this, I'm going to say const deposit amount is equal to deposit. By the way, I've said this before, but const stands for constant, and it's how you declare a variable. So constant deposit amount is equal to deposit. And then I'm going to say console.log and then the deposit amount. Okay, so now let's go here and let's run our code and check this out. So node project.js. Enter a deposit amount. Let's go. Hello, invalid. Enter again. -10 invalid 10. And then it prints out 10 because that's a valid amount. All right, so we've just finished step one here to deposit some money. I realized I spelled this wrong, but that's okay. Now that we've determined uh what the user has deposited, the next thing that we're going to do is write a function to get the number of lines that they want to bet on. And then we're going to collect the bet. So let's go ahead and do this. We're going to say const get number of lines. And notice that all of these different tasks I'm putting in a function. So that's very clear where that code lives. it's easy to go change it, find it later on. It just makes the code very structured and easy to understand. Okay, number of lines. Uh, let's do this. We're going to ask the user to input number of lines that they want to bet on. So, we can really do the same thing that we did here. We can kind of copy all of this code and paste it in, but rather than a deposit amount, this is going to be number of lines. The prompt is going to be enter the number of lines to bet on. And then we can just kind of hardcode in here between one to three. Okay. Then we're going to say uh actually let's just do lines for this. And then this can be number of lines. And then here we can go and change this to lines. Okay. So already we're doing the exact same thing we did before. We're getting the number of lines they want to bet on between 1 and three. We're then saying const number of lines equal to this. And same thing, we want to check if the number of lines is not a number or the number of lines is less than or equal to zero or the number of lines is less than or equal to three because these are the uh lines they could possibly bet on. So actually sorry if it's no not if it's less than or equal three sorry if it's greater than three. My apologies I'll reexplain that. So we're checking if is what they entered not number. If it is, okay, that's invalid. Uh, is what they entered less than or equal to zero? If it is, that's invalid. Is what they entered greater than three? If it is, it's invalid. Now, we just need to change the message. We're going to say invalid number of lines. Try again. And then here, we're going to return the number of lines. Now, I went a bit faster here just because I've already kind of explained how a lot of this code works. Just note here that you can combine as many conditions as you want, and you're just going to go through and check one by one. So we check is this true? No. Is this true? No. Is this true? No. Okay, we go to the else statement. If any one of these three are true, it's invalid. We print that and then we try again. Okay, so now let's get the number of lines. So I'm going to say const number of lines is equal to get number of lines like that. And now we can run the code. So first it's going to ask us for our deposit because we did that first. Then it's going to ask us for our number of lines. And notice that I'm kind of writing these functions in the order in which I have them here. Doesn't really matter where I put them so long as I place them above where I'm using them. So, they need to be defined before I call them. All right, let's run our code. So, clear node project.js. Enter deposit amount. Let's do 100. And then we're going to have to fix this prompt, but enter the number of lines to bet on. Let's do four. Invalid. Let's do three. All is good. We can bet on three lines. Okay. So, let's move on here after I fix this prompt. All right, what is next? Collect a bet amount. So, we need to figure out how much the user is betting. Now, the amount that the user can bet is going to be based on whatever their current balance is, right? They're going to have some kind of balance and that's going to be based on whatever they deposited. So, rather than having the const deposit amount here, let's actually change this variable and let's say that this is let balance equal deposit. Now, that's because the starting balance is going to be equal to whatever they start by depositing. And then we're going to adjust the balance based on what they're betting and what they're winning. Now, notice that's why I change the type of this variable here to be let. Rather than having a constant, I'm changing it to let. Now, what lets me do is adjust the value of this variable. So, later on, I can say add to the variable, subtract it, I can change what it's storing. Whereas, if I have a constant, I can't do that. I can't change the value of a constant because it's constant. But a variable using a let you can change the value of it. So that's why I needed to change the variable type here. Okay. So we have the balance, we have the number of lines, and now we're going to write a function that allows us to get the total bet. So we're going to say const get bet. And the bet is going to be based on the balance that the user has because they can't have a bet that is more than their current balance. So, I'm going to take balance as what's known as a parameter. What that means is I need to pass a balance to this function when I call it. And now inside of the function, we can use this balance variable uh to determine what the maximum bet is. So, same thing here. I'm going to copy this code. Really, we could probably write a function that, you know, reworks this. But for our case, it's fine to kind of copy it and just adjust it. So, I'm going to have again while true. Now this time I'm going to have const bet is equal to enter the total bet like that. We're going to have number bet just cuz I'm converting it. Now here we're going to put bet. Then again we just need to change a few of these things. So, we're going to say number bet number bet. And then we're going to say number bet is greater than the balance this time because now the maximum they have is the balance, not a fixed number like three. And then here we're going to say invalid bet. Try again. And then we're going to return the number bet. So, I know this is fairly repetitive. That's kind of why I'm going through it quickly, but you get the idea. These are three kind of input functions. Get the deposit, get the number of lines, get the bet, make sure all of those are valid. Once we have all of that, we can kind of do the more interesting stuff, which is spinning the slot machine and calculating how much the user won. So now let's call this bet function. So we're going to say const and then we're going to say bet is equal to and then this is going to be get the bet and the bet is going to be based on the balance. Perfect. So let's test this out and make sure it's working. clear node project. Okay, let's enter deposit like 100. Let's do three lines. Enter the total bet and let's bet two. Okay, great. Now, while I was doing this, I just realized that the bet that you're going to have is going to be multiplied by the number of lines. So, this is actually not quite correct because right now, we're only allowing you to uh we're allowing you to bet based on your balance, but not based on the number of lines. Really, the maximum bet you can make is whatever your balance is divided by the number of lines that you're going to bet on because that's how many uh places you're going to place the bet. If you bet two, really your total bet's going to be six cuz you're placing that on three lines. So, I'm going to change this here to say enter the bet per line. Okay? And then we're going to now take in the number of lines and here we're going to pass the number of lines. Now, we're going to make sure that the number is not greater than the balance multiplied by the lines. Uh, sorry, not multiplied, divided by the lines. And just to make this clear, we're going to put these in parenthesis. Uh, I guess actually we don't need the parenthesis. It just removed it for me. So, that's fine. Hopefully, you're getting what I'm saying there. Since the bet is distributed between multiple lines based on the number of lines you bet on, that's going to affect what the maximum bet can be. Okay, now that we have this, let's just try this one more time. Okay, so here, enter deposit. Let's enter 50. Number of lines is three. Now, let's try to bet say 40. Invalid bet. Try again because that's going to be over based on the number of lines that we have. Now, if we try 20, same thing. It's invalid. It's going to be over based on the number of lines. If we do 15, that's fine. We can bet 15 per line. Okay, perfect. So, we've done the first three things here, which is deposit some money, determine the number of lines, collect a bet amount. Now, we need to spin the slot machine. This is where it gets a little bit more challenging, but that's okay. Let's dive into it. All right. So, as we dive into building the slot machine here, I'm going to give myself a bit of room at the top of the program because I'm going to start defining some variables that are going to depict how big the slot machine is and how many symbols we can potentially have uh in each row. So first let's just define the number of rows and columns we want to have. So really the number of reels and the number of symbols that will will appear in each reel. Then we need to know what symbols we have in total. So do we have five different symbols, seven different symbols, etc. And what is the value of each symbol as well as the quantity of each of them in the reel. That's what's going to define uh kind of the payout structure, the probability, etc. I'm not going to make this balanced. I don't really know what I'm picking here. It's a little bit random, but I like to declare all of these as what I refer to as global variables. And I do all of my global variables at the very top of the program. So that's very easy to see them and to change them. So all I need to do if I want to adjust say the slice size of the slot machine is go to the very top of the program, change a clearly named variable to say four, five, some larger number. And now all of a sudden I have a bigger slot machine and my entire program will work. You'll see what I mean. But let's define these variables. So, first of all, you're you'll notice I'm going to do this beneath where I have my prompt. So, the typical tradition is you want to have all of your imports and kind of libraries at the top of your program, then your global variables, then your classes and functions, and then the main line or the other aspects of your program, which is kind of what I'm following right now. So, I'm going to say const because all of these are going to be constants. And the first variable I'm going to have is rows. Now, I don't need to make this a constant, but it's typically a practice of any of your global variables that are constants are in all capitals. I know it seems a little bit weird, but that's what we're doing here. So, I'm going to say const rows. We're going to have three rows and const calls is going to be equal to three. Okay. Next thing we need to define is the symbols. So, first of all, we need to know um what symbols we're going to have and how many of them we can have in each real. So, each column. And then we need to know what the value of each symbol is, which is just going to be some multiplier based on your bet. So we're going to create a map. Uh, and the way we can do this is the following. Uh, actually we're going to create an object. It's kind of similar, but you'll see. We're going to say const symbols is equal to, and actually I'm going to say symbols count. You'll notice that I'm going with snake case here, which uses an underscore for kind of a space separator rather than camelc case. And that's because I'm doing this in all capitals. And that's the convention. Anyways, for my symbols, I'm going to have A's, which will be my most valuable symbol. And we'll say there's only two A's in each reel. Okay, I'm going to have B's. We'll say there's four of those. We're going to have C's. We can say there's six of those. And then D's, we can say that there is eight of them. Again, I don't know if this is going to be balanced or not, but these are the symbols that you can possibly have in each real or each column. And we're going to randomly select from these number of symbols. Okay. Now this object allows me to have keys mapped with different values. So I have a key A here mapped with the value two. So that means if I were to do something like symbols count at A, this would give me the value which is two. Hopefully that makes a bit of sense. Uh but that's like a very quick introduction to objects in JavaScript allow you to have keys or properties or attributes associated with values. Okay. All right. Next, we're going to have our symbol values. Okay, now the values are going to be similar here, but we're going to say A is 5, B is 4, C is three, and D is two. Now, this means if I get a line of A's, I'm going to multiply the bet by five. That's going to be the payout because of that line. If I get a line of B's, I'm going to multiply the bet by four, etc. So this is the multiplier or the value of each symbol uh relative to what we're going to multiply it by. Okay. So now that we have our constants, what we need to do is create a function that kind of spins a slot machine. Now really spinning the slot machine is just going to be randomly selecting based on these counts what symbols we have in each reel. Then we need to determine if the user won anything. Okay. So let's do this. We're going to say const and we're going to say spin. Okay. Now, for the spin, we don't need to take in any parameters. We can just generate uh the different reels. So, to generate the reels, the first thing that we need to do is figure out how many symbols we have. Now, we know that based on this. But what I'm going to do here is I'm going to put all of the possible symbols that we could use inside of a list or inside of an array. And then I'm going to randomly select them out of the array and remove them from the array every single time that we use them while we're generating uh each reel. So we're going to generate individual columns, right? That's what we need to do. Um yeah, let's let's generate the columns and then you'll see what I mean. All right, so as I was saying, let's generate an array that contains all of the possible symbols that we could have. So, I'm going to say const and then this is going to be symbols is equal to and then an empty array. Now, notice that even though we're going to be adding elements into this array, I still made this variable type a constant. That's because I'm not going to change the value of the array. I'm not going to actually change what array I'm using. I'm instead just going to be adding elements inside of it. I know that seems a little bit misleading or a little bit confusing. This is something to note in JavaScript. an array is what's known as a reference data type, which means I can manipulate what's inside of the array without changing the reference to the array uh itself. So, I don't need to assign a new value to symbols. I can just add stuff inside of this array. And that's not going to violate the principle of this being a constant variable. It's a little bit strange. A lot of people get confused by that. Uh hopefully that gives you a bit of an explanation. So, what I need to do now is I need to loop through all of the different entries that I have inside of my symbols object or my symbols uh count here. Okay. Now, notice that it got rid of my quotation marks. Uh you don't actually need quotation marks for your keys or for your properties or attributes in JavaScript. You do in Python. Hence why I added them because I thought we're in Python, but no, we're in JavaScript. Okay. So, I'm going to make a for loop here. I'm going to say for and then this is going to be symbol of and then I'm going to say this is object dot entries of and then our symbol_c count. Okay, so the way that you loop through all of the different uh entries inside of an object and our entries are going to be this, right? So A2 B4 C6 D8 uh is you use this right use symbol of object entries and actually we're going to say symbol and count of object entries and we need to put these inside an array and we need to put our const here. Okay, sorry I'm getting a little confused just cuz I usually work in Python and it's a bit different but we're going to say constant and then inside an array we're going to say symbol and count of object entries. that's going to loop through all of the different entries in our symbol count and it's going to give us first of all what the key is or what the symbol is and then what the value is associated with each of those. So to quickly illustrate that I'm just going to console.log the symbol and the count and I'm just going to call this spin function here uh just so you can see how the looping works before we go any further. So let's quickly run this and notice I get A2, B4, C6 and D8. Okay, so I'm looping through all of them. And now I'm just going to get out of this. Uh, I guess I need to just enter some values here. Okay, perfect. So now we're out of that. All right, so that's how the looping works. Now that we have the symbol and the count, we're going to add that many symbols into our symbols array. So we're going to do another for loop and we're going to say for I'm going to say let I equal zero. I is less than and this is going to be count. Then I'm going to say I plus+ and then I'm going to say symbols.push and I'm going to push the symbol into the array. Now this is just going to add however many symbols we have. So in this case if we had two A's, it's going to add two A's into this symbols array. The way that you add them in is by pushing them into the array. So typically in other languages you'll see append. In JavaScript it's pushed. That's how you insert a new element inside of an array. And an array is just a collection of multiple elements. So I could have a a b like that inside of the array. Okay, hopefully that is clear. So for every single symbol and for the count of those symbols, we're going to have another for loop and we're going to insert that many symbols into the array. So now again, just quickly before we go any further, let's print out what the symbols array looks like after we run this code. So let's call the spin function. Let's go here and run it. And notice that this is our array. Okay, so we have two A's, four B's, six C's, and eight D's. The point of doing that is now that we are going to be able to uh one sec, let me get out of this here. Randomly select elements from the symbols array when we are inserting them in our reels. Okay, so let's do this. We're going to say const reels is equal to and then we're going to create three nested arrays. Now, this is simply an array inside of an array. You can do that. it's valid. Just like we had elements inside of here, we can have arrays inside of arrays. And each one of these arrays is going to represent a column inside of our uh slot machine. Okay? So if we had a a a really you'd visualize that like a a a. Okay. So each one of these kind of nested arrays is a column and we're going to generate what's inside of them using this symbols array. Okay. How do we do that? Well, we need to go through each one of our reels. So we're going to say four and then this is going to be let i and actually yeah we'll say let i equals z i is less than and this will be the number of columns that we have and then we're going to say i ++. So this first for loop here is going to be for each one of our reels. So for every single reel that we have or every single column that we have we need to generate what's inside of it. Then for every single column we need to pick the three elements or the x elements whatever the number of rows is that we have that are inside. So then we're going to say four and we're going to say let j equals z j is less than rows and then j++ like this. So we have a nested for loop. The reason we need that is because we have nested arrays. So for every single array, generate the number of rows, the number of elements that need to go inside of that array or inside of each reel. Hopefully that's making a bit of sense, but that's kind of what we're doing here. Now, in case you're confused by this syntax, the way this works is we define some counter variable that we can use while we're running through this for loop to keep track of how many more iterations or loops we need to perform. We then set how many loops we want to do. So we say while I is less than the number of columns, that's what this means. It means while I is less than the number of columns, keep looping. As soon as it's equal to or greater than, we're going to stop. Then we have what's referred to as our increment. We're saying every time we do this loop one time, increment the variable I by one, allowing us to keep looping, keep track of what loop we're on, and then eventually exit the for loop. So obviously, same thing is happening here. Uh for J, I'm just using a different variable because we can't have the same variable for both of our loops. All right. Now, inside of here, we need to randomly select elements from our symbols. But remember that the elements that we can have or the symbols we can have in each reel are for each reel. So, what I actually need to do here is create another variable. I'm going to say const real. Yeah, we'll say real symbols is equal to and then this is going to be an array. Now, actually, what this is going to be is an array and we're going to say dot dot dot and then symbols. Now, what this is going to do is just copy the symbols that we have available to choose for each reel into another array. The reason we're doing that is because for every single one of our reels, these are all the available symbols that we have. So, what I'm going to do is randomly select a symbol and then I'm going to add that into the reel and I'm going to remove it from the available symbols to continue to select. So, if I already used two A's in one reel, I can't have any more A's. I need to remove them so I don't pick them again. But when we move on to the next reel, we have to have those A's available for the next reel. So I can't be removing elements from this symbols list, I need to remove them from one that's specific to each reel. So inside of our for loop, remember this is for every one of the reels that we have. We generate the available symbols. Then we're going to remove from them as we add the symbols into each reel. I know this is a bit confusing and I said reel probably a 100 times there. Uh hopefully it's a little bit clear why we're doing that, but it's because each reel has their own symbols that they can pick from. So we need to have a copy of the available symbols that we're manipulating inside of the for loop. Okay, let's continue here. I'm going to say that our symbol so I'm going to say const selected symbol is equal to and then I need to randomly select an element from this array. Now the way I randomly select an element from array is I randomly choose an index or a position in the array. So quick recap here. If we have some things in our array, say we have a b c. Each one of these things has an index in the array. Now the first index is zero. The next is one and the last is two. So you always start at zero, you count up by one. Fairly straightforward. So what I want to do is randomly select one of these indices or indexes and then choose the element there, remove it from the existing array and insert it into my reel. That's what we need to do. So we need to randomly pick one of the indices. Now how do we randomly select an index? Well, we need to use our random function. So we are going to say uh actually this is going to be real symbols at the index. Now the way that you access elements at a specific index is you write square brackets and then you put 0 1 2 3 whatever the index is. So if we're accessing the fourth element we put index 3. Now the question is what is the random index? So we can go here and say const random index is equal to and then in all capitals we're going to type math dot random and we're going to multiply this by whatever the length of our real symbols is. So we're going to say real symbols dotlength and then we're going to put around this math floor. Okay. Then here this is going to be random index like that. All right. What are we doing? Well, we are generating a random index. Now what I've done is I've taken math.random and math.random is going to generate a random number between 0 and one. So it's a floating floatingoint value between 0 and one. Then we take that number and we multiply it by whatever the length of our symbols is. That means that the maximum possible number that this expression is going to generate for us is going to be however many symbols we have. It's the maximum possible number. Then we're going to say math.floor. Now, the reason we're doing math.floor is we're going to round this number down to the nearest or to the lowest whole number. So, if we had like 1.9, we're going to round it to 9. The reason we do that is because really the possible numbers that we can pick from, the possible indices we can pick from is the length of our array minus one. So, we don't want to round up because that would give us an index that's possibly out of the array. we need to round down so we get one that is less than the real symbols.length. So again, just to kind of clarify what's happening here, this is going to generate a random number between zero and then whatever the length of our reels is minus one. And then we can use that to select the element or the symbol from our real symbols array. I know it's a bit complicated here, but that's why I wanted to do this project to give you a bit of a challenge. So now that we have our selected symbol and we know the random index, we're going to first say reels and then this is going to be at index i. Now index i is going to represent the reel that we're currently working on. So if we're working on the first reel, I is zero. So it's index zero. If it's the first reel or sorry the second reel, then I is one. So it's index one. So I'm going to say reels I do. push. So I'm pushing into the interior array the selected symbol. Okay, we're almost done. Last thing we need to do is remove this symbol so we can't select it again while we generate this reel. So we say reels symbols do splice and we're going to splice at whatever the random index is that we selected because that's the position that this element existed at or this symbol existed at. And then we're going to put one. Now one just means remove one element. So that's all we need for that. And random index is the position at which we're removing that element. So, we're selecting the symbol at this index. We're adding it into this uh array here, and then we're removing it so we don't select it again when we continue generating this reel. And that's all we need for generating our reels. Now, we can return the reels like that. Now, I just want to quickly uh print out what we're going to get for our reel. So, I'm going to say const reels is equal to spin just to make sure this is working before I go on to explain uh too much more stuff. I will walk you through this again, but let's just quickly run this. So, I'm going to say node project.js. And then notice this is what we get for our reels. So, c d a d. Now, notice we get a lot of D's because we have eight of them available in our symbols cap. If I run it again, so let's just get out of this. Okay. And run it one more time. Uh, notice that we get different values here in our reel. So, it is indeed random. Okay. So that means now that we have completed these four deposit some money, determine the number of lines, collect a bet amount, spin the slot machine. Now we need to check if they won, which is fairly simple. We need to give the user their winnings and we need to play again. Let me quickly recap what we did here. Then we'll get into those steps. So we started by generating an array of all of the available symbols that we can pick from when we are going to uh choose what's inside of each reel. Randomly choose. So this contains all of the available symbols. Then we create an array here, kind of temporary array that we're going to add to that has all of the different reels. So we have one reel, second reel, third reel. We loop through all of the reels that we have, which is represented by the number of columns. Now really, I just realized uh it's a little bit flawed what we're doing here because if the number of columns is different than three, we're going to get a bit of an error here. So I'm just going to quickly fix this even though I don't love changing this all right now by saying reals.push push and then I'm going to push an array here. And now we can remove this. The reason that's going to work is because for every single reel or column we have, we add one inside of here. Okay? And then once we add it, we can now push elements inside of that reel. Hopefully that fix uh makes a bit of sense. Anyways, once we do that, we then copy all of the available symbols that we have. So we now have kind of a unique array to pick from for this specific reel. Then we loop through all of the rows. all of the rows is the number of symbols we're going to have in each reel and we randomly generate one of the available uh symbols. So we pick one of the symbols that are available and we insert that into our reel. So we say our random index is this. We get our selected symbol. So that's going to be whatever the symbol is at that index. We push that into the current reel that we're working on which is represented by i. And then we remove that from the available symbol so we don't select that again. Perfect. Okay. Then we return reals and we are all good. Let's continue now and work on generating or checking if the user won anything. All right, so let's go ahead and continue. Now, first thing to mention here is that with our reels, and by the way, I'm just going to take these and move them down because that's kind of the logical order we need here. Uh, our reels look like this when we get them. So, we have arrays, right? And each one of our arrays, let's just do a b c maybe d uh a a uh these are our kind of vertical um columns, right? These are yeah, our columns. Now, what we want to be doing when we're checking if a user is winning is we want to check in the rows. Now, right now, based on the way that we have our data, it's going to be a little bit difficult to check each row and see if every element in the row is um is the same. So, what we're going to do is we're going to transpose this array into all of the rows. So, again, I know this is a little bit weird, but these right now are our columns. What we want to have is an array that has all of our rows. Once we have the rows, we can then check who's uh who's winning or what row is winning, and we can then present that to the user. So, when we're looking at this, right, we have these as our columns, but we want to instead have it like this, where we have rows. So, our rows would look like this. A D A and notice I'm taking A D A because that's what's going to be in row one. These are all in unique columns. Then we're going to have B D A and then we're going to have C D A. Again, if we look at row two here, that's B D A. We look at row three, C D A. So we need to turn our data into this format. And then once we have that, we can continue. Now, this is called transposing a matrix or transposing a 2D array, whatever you want to refer to it as. So, we're going to write some code that does that. We're going to get the transposed um kind of matrix reels, whatever you want to call it. Then, we can check who's winning or what rows are winning. Uh how much money they won, etc., and we can continue from there. So, let's write a function here. Uh let's actually just call it const. And we're going to say transpose. Again, this is going to give us the rows. So, we're going to take in our reals and we're going to transpose them. So, how do we transpose? Well, first we need a new array. So, we're going to say const uh we'll just call this rows like that. And for our rows, uh that's fine for now. So, what we're going to do here is we're going to create a for loop that goes through the number of rows that we have for each row. So, row 0, row one, row two, or row 1 2 3, whatever you want to refer to them as. We're going to collect all of the elements from our columns that are in that row and then push that into the rows array. So we're going to say for let i equals z i is less than and then this is going to be the number of rows and then i ++. Okay. Then what we're going to do is say rows push and we're going to push a new row because for every single row we need to have an array that represents that. So we push those inside of here. Then we're going to say for let J equal zero. J is less than and then this is going to be the number of calls and then J++ like this. So for every single row loop through every single column. So now for every column that we have, we're going to grab the uh the element that's in the first row in that column and push it into our rows array. So we're going to say that rows at row i because that's the current row that we're building dot push and then we're going to push the reals at and then this is going to be column j at row i. I know seems a little bit weird but we're accessing each of the individual columns. So we're going through the three columns that we have or however many columns that we have. So we're accessing that column. Then for each one of those columns, we're getting the element in the row that we're currently building, which is represented by I. Okay? Then we can simply return our rows. And that's how you transpose it. Now, I'm going to print this out, and you'll see what the transposition looks like, and then it'll make this a bit more clear. Okay? So, we have our reals. Now, I'm going to say const uh let's call it rows is equal to transpose. Okay? And then we're going to transpose the reels. Now we're going to just console.log the reals and then we're going to console.log the rows and you'll see the difference and how that transposition occurs. So let's run this. Say node project.js. Okay, let's run through this. And here we go. So we can see that we have all of our individual columns. So C I C D C D B D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D. Now let's look at our first row. Remember, this is kind of flipped. So for our first row, we have C, C, and then D. That's what we want. For our second row, we have A, D, and then B. Okay. And then for our third row, we have D, C, B. So now that we have those, what we can do is simply print those out. Uh, and we can kind of represent to the user what it is that they actually spun. Okay. So, we're going to make another function here that's going to print our rows. So, we're going to say const print uh we could say print slot machine or print rows is fine. And we're going to take in our rows and we're just going to print out all of these elements in some kind of styled way. Okay. So, we're going to loop through every single one of our rows. Uh and then print. We're going to say four and we're going to say let I actually do we need to go I I think we can say for const row of rows. Okay. Then we want to loop through every single row and kind of build a string that represents that row and then print that out. So I'm going to say let row string equal. This is going to be an empty string. And essentially what I want is this like a pipe b pipe c. And we're going to build that uh using a for loop going through each of the elements in our row. Now, by the way, this is iterating by item, which means that I'm going to get an array here. So, I'm looping through every array, every nested array or every row inside of my rows array. Remember, it's a two dimensional array. So, this will be an array that I can then loop through and get each of the elements. Okay, so we have our row string here, and I'm going to say for and this time I need to do um a different style for loop here. I'm going to say for const and then we're going to go with I symbol of row dot entries. I think I can access entries on an array. We're going to see if that works. Then we're going to do the following. We're going to say row string plus equals and then this is going to be the symbol. So when you do plus equals, you're kind of concatenating a string. So you're adding elements into the string. So if I go plus equals a to my empty string, I get a. If I go a plus a, then I get a a. So that's what we're building here. Okay, that's what we're doing with the concatenation. Then we need to determine if we're going to add our pipe operator or not. Now, we're only going to add the pipe operator if it's not the last symbol that we have because again, we have a b c. We don't want to have a pipe here. So we need to make sure we don't add that. So we're going to say if I does not equal rows.length minus one because this is the maximum possible value I can be equal to then what we will do is we'll say row string and then this is going to be plus equals plus equals sorry and then we're going to add a space and a pipe and a space. I think that is correct. And then in terms of this here, sorry, I'm just going to change this to say row entries. And then this is going to say row.length. I don't want to use rows. We're already doing that here. We want to loop through our individual row. Now that we have the row string, we're going to say console.log log, sorry, the row string. And now we're going to print each of our individual rows. And they'll be nicely laid out, and we'll kind of see each of the elements that's in each row and call. Hopefully that's making a bit of sense. Again, we're going through every single row in our rows. That's going to give us an array representing the elements in that row. We're then going to loop through both the index and the element that exists in this row. So, if we have rows like a b c, then what we're going to be getting here is zero. So, zero a 1 b 2 c because it gives us the index as well as the element. We're then checking okay is the index the last index or the last element. If it is then we are going to not put the pipe. If it isn't then we're going to put the pipe and the separator in this string. So we build this string up and then we can print it out here. And that's fine for printing the rows. So let's go print rows rows like that. Let's go here and clear and rerun. Okay. Let's do this here. And there we go. we get our nicely printed slot machine. Now, in this case, we didn't win at all. Uh but if we did win, well, that's what we're going to handle next. Seeing if user won, giving them their bet amount, uh or whatever they won, etc. Okay, so let's just quickly recap here. We've done depositing some money, determining the number of lines, collecting a bet amount, spinning the slot machine. We then transpose the slot machine. Now that we have it transposed, it's going to be really easy to check if the user won. We're going to do that, and then we need to determine their winnings uh to get back to them, right? Okay. So let's go ahead and do that. So we're going to say const get winnings. All right. Now to do this, we're going to take the rows, we're going to take the bet amount, and we're going to take the lines that the user bet on. That's what we need to know to be able to determine what they want. If they only bet on one line, we're only checking the first row. They bet on two, checking both those rows. If they bet on three, then we're checking all of the rows. Okay, so let's go through this. So we're gonna begin by saying let winnings equal zero and then we'll add to that whenever they win something. All right, so to do this, we're going to loop through all of the lines, which is really the row indices that we want to be checking. So we're going to say four, and we can say let row equal zero, row is less than lines, row ++. Now, the reason this for loop is going to work for us is if lines is one, that means we're only ever going to look at row at index zero. If lines is two, we're going to look at index zero and index one, which would be the first two rows. If it's three, we look at 0, 1, and two, and that means that we're going to look at all of the rows that are inside of our well rows. Okay? So, now we're going to say const um symbols is equal to and then this is going to be rows at whatever the row index is. All right. So, now that we have all of the symbols, we just need to check if all of them are the same. So, I'm going to create a variable here, and I'm going to say let all same equal true. Now, what we're going to do is if we find that one of the symbols is not the same, we're going to make this variable false. We're then going to use that later to determine if the user won uh in this specific row. Okay. So we're going to go four and then we're going to say const symbol of symbols. Again iterating by item here looking at each of the individual symbols. All we're going to do here is we're going to say if the symbol does not equal symbols at index zero, then we're going to say all same equals false and we're going to break out of the for loop. Now there's a bunch of different ways to go about doing this. what I'm doing is not necessarily the most efficient because we're going to be repeating a certain check, but it's fine for the purposes of this tutorial. So, the reason I'm doing this is I'm saying, okay, I'm going to loop through every single one of the symbols that I have. Now, if every single symbol that I have is the same as the first symbol, all of them are going to be the same. So, I'm just using the first symbol as what it is that I'm going to compare against. And again, if all of them are the same as the first symbol, then all of them must be the same. So in the situation where one of them is not the same, so symbol does not equal uh symbols at index zero, then I'm going to say all same equals false. And then I'm going to break out of this for loop because there's no reason to continue looking uh if one of the symbols is not the same. Now this break keyword, as I just described, is simply going to exit the for loop. So it doesn't matter what iteration you're at. If you see this break keyword, boom, you're done iterating. So we're setting all same equal to false. And that means we did not win in this specific line or in this specific row. So now we come down here after we've iterated through and if all the same is false, we didn't win. All same is true, we did win because if it's true, that means we got through here. This was never the case and that means that all of the symbols are the same. So we're going to say if all same then winnings and this is going to be plus equal the bet multiplied by and then this is going to be the not rows sorry the symbol values at symbols at index zero. I know uh a little complex here, but remember symbol values is what we have all the way up here. We have 5 4 3 2, right? This is the multiplier. So, we need to find that multiplier and multiply that by our bet. So, if we had a row of A's, then we're going to take whatever our bet is and we're going to multiply it by five. Again, we're only doing that if all of the symbols were the same. We're determining what the symbol is that we want to look for the multiplier for by just grabbing the first symbol in the row. At this point, we know that all of them are the same. So, we could really grab any index from the row, but we know we're always going to have at least one symbol. Uh, so this is fine to do. Okay. So, that's actually all we need for this. Now, we're going to return our winnings. All right. Uh, hopefully that is all clear. I think that that is correct. If I made any mistake, of course, I will fix that. Uh, also, let me just get rid of this. Actually, no. We want the const log. Sorry. I don't know why I was going to remove that. All right. So now after we print our rows, we want to determine what the uh the winnings is. We're going to say const winnings is equal to get and did I call this winnings? Yes. And then what do I need to pass here? My rows, my bet, and my lines. So we're going to say rows. We're going to say bet. And then we're going to say lines. Now, I just want to confirm here what the bet is actually going to be because if the bet is the total bet, that's not what we want. We want the bet per line. So, let's look at get bet. Okay. So, get bet uh return number bet. Yes. Okay. So, it looks like the bet that we're returning here is the bet that we have per line, which is what we want uh because that's what we're multiplying by if we have an entire line. Okay. So, now we have our winnings. Now I'm just going to print U1 and then we can say comma and a dollar sign and then we can say plus and sorry this is not print this is console.log I'm writing in Python right now and then we can say plus winnings and I don't know if we have to do two string or not uh but I'm going to put this two string. Okay, so we have const winnings equals get winnings rows bets lines. It tells us how much money we won. So, we're going to get that and we're going to print out U1 and then whatever that dollar amount is. Then we're going to have to kind of continue this game a little bit. But for now, this should give us one round or one spin of the slot machine. So, let's try this. Okay. Enter a deposit amount. Let's deposit 100. Let's bet on all three lines. Let's enter the bet per line of maybe $10. And we got an error here. It says lines is not defined. Okay, so that's at line 144. uh lines here. Ah, that's because we need number of lines. Okay, so that was the issue. Let's quickly fix that. Let's come back here and run. 100 3 and then 10. And we won $0. Okay, let's try it again. 100 310. You won $0. Uh, okay. Hopefully, we're going to win something. So, let's see here. 310. You won $20. Okay, perfect. And the reason we won 20 is because we uh bet $10 on three lines and we won with this line here giving us $20 cuz we had a two times multiplier with the D's. Now, if we wanted multiple lines, of course, we'd get the winnings for all of them. All right, so that is really the core logic for our game. Now, what was the last thing we need to do here? We need to give the user their winnings and we need to play the game again. So, let's work on that. Uh and once we do that, then we're going to be finished this game. All right. So, how are we going to turn this into a fully functioning game? We have the core logic here, but after we determine what the user wins, we need to give them those winnings. We also need to subtract whatever their bet is um from their balance, right? So, let's make a function. Let's say define or not define again. I keep writing in Python. Sorry, guys. We're going to call this game. Now, this will just be one round. Uh will this be one round of the game? No, it's okay. This can be the entire game. So, we're going to go game and then we're going to call the game function down here. Uh, just to kind of clarify where everything is for our code. Okay. So, we start by determining the balance. That's fine. Then we get the number of lines, the bet, the reels, the rows, etc. Now, all of this stuff here, we're going to do no matter what, right? We're just going to keep playing if the user wants to continue playing. So, I'm going to say while true here, and then I'm going to do all of this. Okay. Now, we're going to add some more code obviously, but we're going to keep doing this. If they run out of money, then we are going to break or if they say they don't want to play anymore, then we're going to break the while loop and kind of get out of it. So, we start get the number of lines, we get the bet, we get the reels, we get the rows, we print this out, we get the winnings. Now, let's start handling some logic here. So, after we collect what the user's bet is, we are going to take the balance and we're going to subtract. So minus equals this means take the balance and subtract from it whatever the bet is multiplied by the number of lines because this bet is per line. So whatever number of lines they bet on that's what we're removing. Okay? So we remove that from the balance subtract it. Then we generate our reels. We print the rows. We tell the user what they won. And then we have to add this to their winnings. So, we're going to say balance plus equals winnings. Perfect. Now, at the top here, we should probably always tell them what their balance is so they know what it is before they spin again. So, we're going to say print you have a balance of and then we're going to do a dollar sign and then we're going to do a plus and then we're going to put the balance so that it looks like it's money. Okay, so we print what their balance is. Sorry, this needs to be console.log. I'm going to keep making that mistake. We have the winnings and now all we need to do down here is we need to check if they have $0 left. If they do, then we are going to quit the game or we're going to ask them, do you want to walk away? Do you want to stop gambling, etc. If they say yes, then we're going to break. So, I'm going to go here. I'm going to say if the balance is, we can say less than or equal to zero. But really, it's never going to be able to be at that. But that's fine. We'll just say if it's less than or equal to zero, then we're going to break. But first, we'll go console.log, you ran out of money exclamation point. Okay. And then we're going to say after this we're going to ask the user if they want to play again. So we're going to say const play again is equal to prompt. Do you want to play again? Question mark. And then we're going to accept as an answer either Y or N. And if they type anything other than Y, then we are going to quit. So, I'm going to say if play again does not equal Y, then we can simply break. Notice that when you're just doing a oneline um kind of if statement or you have a oneline body, you don't actually have to add the curly braces here. You can just write it directly after the if statement. So, if they didn't type yes to wanting to play again, then we're just going to break and leave the game. Otherwise, we just keep playing. So, if they run out of money, we quit. Or if they tell us they want to leave, then we break. Okay? Hopefully that's clear. Let's test our game. Make sure everything's working. Uh, and then that's going to pretty much wrap up this project. So, let's go here. Node project.js. Let's deposit 100. We have a balance of $100. Enter the number of lines to bet on. Let's bet on two lines. Enter the bet per line. Let's do $5. You won $0. Okay. Do you want to play again? Yes. You have a balance of $90. Enter the number of lines to bet on. Let's bet on three lines. Bet per line of $10. You won $0. Do you want to play again? All right. This isn't going too well for us. You have a balance of $60. And so the number of lines to bet on. Three bet per line. Two, we won $6. So I guess we had a three times multiplier there with our C's. Play again. And you get the idea. We can continue playing this. Obviously, we could clean up the terminal a little bit, make it a bit cleaner and uh kind of easier to understand. Let me just go through this here so I can quit and exit. But I think that is going to do it for now. All right, so let's quickly run through everything one last time. I'll just like kind of highle overview the code and everything that we did. By the way, all of this code will be available from GitHub. Then we're going to wrap up the video. So, first of all, we have prompts. We're requiring this module so we can get some user input. We define some global variables here. We do them in all capitals just so it's clear. They are constants and they're at the top of our program. Okay, we have our function deposit. Talked about that. Continue. Ask the user for a valid deposit. Get number of lines. get the number of lines or rows in this case that the user wants to bet on. Get the bet. Same thing. We're going to get a valid bet amount per line based on the balance uh that they have and the number of lines they are betting on. Next, we are going to spin the slot machine. To do this, we need to generate all of the possible symbols in each reel. We then need to randomly select them, put them on a reel, uh and that's what we've done. Okay. Then we have transpose. This is kind of a helper function that's going to convert all of our columns into all of our rows. So, we can better use this information. It's easier for us to check if the user won anything. Uh, and it's easy for us to kind of print out this information. Next, we have print rows. Again, this is just going to print out all of our rows in kind of nice fancy formatting. Then, we have get winnings, determining all of the winnings a user won from the specific rows or reels uh that they had in the slot machine. Lastly, we have our game function where we continually play the game until the user runs out of money or until they tell us they don't want to play anymore. [Music]",unknown
YLjopoEnPi8,"In this video, I'll give you a complete tutorial on how to use Lovable. I'll assume that you're a complete beginner, that you're not an expert programmer, and I'll walk you through everything step by step. So, by the end of the video, you know all of the core features, and you're comfortable using this tool to build some really cool applications. Now, I'm going to show you advanced debugging, so what happens if something goes wrong? I'm going to show you advanced features that you probably haven't seen before and how to create both a front end, that's the user interface that you would see and interact with, as well as a backend that can handle some more complex operations like authentication, data, etc. This is going to be super cool. Let's hop onto the computer and get into the tutorial. So, let's start by discussing what Lovable is. Now, this is an AI tool. It's free to use. You don't need to pay for it. You can get some free credits. And this allows you to build full stack web applications using AI. Now, while you can go in and you can modify the code yourself and you can really get as advanced as you want, you don't need to know how to code to use a tool like this. Really, what you do is you write a prompt. So, you just tell this AI model what it is that you want to build and then it can go and build that for you. That's what lovable does. That's the tool and it can build some really cool applications. And if you scroll down on their website, you'll see a bunch of examples of apps that people have built and deployed with Lovable. So, this is a great tool and I'm happy to say that Lovable has actually sponsored this video. And that means that if you do decide to use this more and you want to buy more credits, I have a 20% discount code that you can use that I'll link in the description. So, anytime you buy credits for the next 30 days, that's how long it's valid for, you can use this code and get that discount. That said, it's free. For right now, I'm just going to use the free version of the tools that what I'm using is the same as what you'll be able to use. And I'm going to show you how to create some cool applications using this. Okay, so we're on the Lovable website. In order to get started, that's where you need to go, right? Lovable.dev. I'll leave that link in the description. Like I mentioned, it's free, but you do need to make an account. So, you can just make an account, sign into that, and then you should see the number of credits that you have. Lovable has given me some more for this video, but you'll see that I don't have the pro account, which means there's a few features I don't have access to, but it's fine. We can still use this tool. And again, you'll get more credits every single day. And the way this works is whenever you ask Lovable to do something, it's going to cost a certain number of credits. That'll depend on how complex the task is. If you wanted to build something completely from scratch, that's going to cost a few more credits than if you wanted to change the color of a title or something along those lines. So in terms of getting started with this, the first thing that we need to do is figure out what it is that we want to build. So you need to come up with some kind of idea and I recommend thinking through this pretty carefully. You get the best use of these tools and of lovable when you know what it is that you want. If you're kind of just guessing or you're just trying to make something cool, you can get some great results from this, but it might not be exactly what you want because the more specific you can be, just the better results you're going to get. So in my case, I want to create a kind of fitness tracking application. I'm going to start with something really simple, which is just a macro calculator. So determining the amount of calories, fat, protein that someone should get every single day. And then I'm going to slowly make it more advanced. And I suggest going with an approach like that where you plan out what you want your entire project to look like first. You can do that in like a Google doc or something. and then build it step by step. Rather than giving a super detailed prompt at the beginning and asking it to build a million things, get it to build one feature at a time. And I'm almost sure that you're always going to get a better result doing that. So, with that said, we can come here to this prompt window and I can just write what I want. But there's a few other ways to create a project that I want to quickly make you aware of. So, if you press this plus button here, you'll see that it says import from Figma. Now, if you're a designer and you've used Figma before, then this is great. You can just import a Figma design that you've already built out and you can just have Lovable create the application for you. If you don't know what this is, don't worry, it doesn't apply for you. You also can attach an image. So maybe you sketch something out on your tablet or maybe you have just like an example of a website that you want to build. What you can do is you can press attach and you can add images to the prompt here and tell Lovable to reference those images and to build something that looks like that. So, if you're a good artist, which I am definitely not, you can just draw something out and you can give it to Lovable and it will then copy that. Now, you also have the ability to remix an existing project. So, whether it's a project you've already worked on or a project that you've seen from the community here that you want to build another version of, you can press on this remix button and then you'll create a new project with Lovable based off of this project. So, that's kind of like the template that you're starting with and then you can go crazy and do whatever you want to make any um kind of modifications. In my case, I'm just going to come up with an original prompt. I'm actually going to use my voice to do this because I find the voice dictation. It's just a lot easier for me to give a detailed prompt. And I'm going to do that by simply using this tool called Whisper that I have installed on my computer. You can use anything you want. You don't have to use this. You can use the built-in dictation. What I'm going to do now is just kind of speak out what I want and you'll see the way that I structure my prompt. Please create a simple macro tracking application that eventually I will build into a larger fitness app that allows users to enter their gender, their height, their weight and other thing like their preferences if they want to lose weight, gain weight, maintain their weight, also the amount of calories maybe they burn in a day or their athletic activity and then recommends to them the macros or nutrition they should be getting every day. So, the calories, the fat, the protein, and any other information that you think is valuable. I also suggest that we give them the number of meals that we think they should be eating, especially if they need to get a lot of calories in in that one day. I want this to be really simple. I want it to be easy to use and intuitive. I want the user interface to be clean and easy to navigate, and I'd like to use an orange and black color theme. Keep it simple. Don't do anything too complicated. Let's get a working version first and then later we'll add some more features. Okay, so I've just dictated that now um to the model and you can see that it kind of has written this out for me using this whisper tool which is quite cool. And anyways, I'm going to go ahead and press enter now and we're going to start generating the project. Now again, I'm keeping it simple. I'm building one step at a time. I know I want to add more to this later, but I'm not going to get ahead of myself yet because if I do that, it's going to take a lot longer to get the result and then I'm going to have to do probably a lot more revisions. So, I'm going to keep going over best practices when it comes to prompting here. But, while this is spinning up, I also want to make you aware that Lovable has some really good documentation that talks specifically about prompting best practices. I'm going to link this in the description. You can see it's extremely long. Obviously, I'm not going to go over all of it right now, but it gives you a lot of examples of how to prompt. And if you're really new to using these AI tools, I suggest reading through this because it's going to give you a lot of insight. Now, anyways, I'll cover some of these points, the important ones in this video, but obviously this is a much more in-depth guide than I can give you right here. Okay, so we're back to the lovable interface, and you'll see what's happening right now is that it's kind of thinking through this, and it's actually writing a bunch of code for us. I'm going to start going over the interface and just explaining to you some of the different buttons and features that you see. And as the video progresses, we'll get more and more advanced and you'll learn more about how to use this. So on the left side, this is your kind of interface with lovable. Right? This is where you're going to be working most of the time. And realistically, you're probably just going to be typing prompts here. Prompt is just you telling the model what you want it to do. Right? Now down here, you'll see a bunch of other stuff. For example, you have the ability to add GitHub history knowledge. We'll talk about that later on. Or to attach images. You also have this mode selector. So you'll see where it says chat. And if you toggle this on or off, you can determine whether Lovable is actually going to make a change for you and act like an AI agent, which I'll discuss in a second, or if it's going to respond to you. So right now, we have it in the default mode, which means it's actually going to be able to modify files, write code, and create the project for us. But sometimes we actually just want to ask a question. We don't want it to go make a change. We want clarification, or we want to just talk with Lovable. If that's the case, we enable the chat mode. And then when we start talking, we've kind of turned on the safety where it's not going to automatically go and change something that we didn't want it to change. So, that's an important button right here. We have chat mode or default mode. Okay. Now, Lovables just pinged me here with that kind of uh notification, the audio notification saying that it's kind of completed the first version of my project. And you'll see that we get a live preview popping up on the right hand side of my screen. Now, you'll see that you have the left side, right, which is where you prompt the model. On the right side, you have the preview. So, it's showing you what the finished website looks like. And then up here, you'll see that this acts kind of like our web browser. So, if you want to refresh the page, you can press this refresh button, and it's going to refresh the website that Lovable has created. If you want to pop this out into a new tab, you can press this button right here, and it will open a separate preview. So, you can have it full screen in a different window. If you want to change the page that you're on, you can press right here. You'll see right now we just have one page, which is the homepage or the root page. So slash, which is always the default page of a website. But later as we make this website bigger, we'll have more pages we can navigate to. And then we can toggle this and change it into tablet mode or into um what do you call it? Kind of phone mode and see what it looks like so that we can test kind of the responsiveness of our design and if this will work on a smaller device. Anyways, I want to test this out now and see if it's working because obviously sometimes it can make mistakes. So, let's go here. Let's select our gender, our age. For some reason, it knows like pretty much all of my stats because this is almost exactly correct. Our goal, let's go to gain weight and let's go activity level. We'll say no, lightly active. It's going to calculate our macros. And then you see it gives me my macro targets. So, 28156 84 g recommends four meals per day. And then it says start tracking. That doesn't do anything right now. And then calculate again, which brings me back to the calculator. So, for a first pass, that's really good. And that's pretty much exactly what I wanted. But obviously, we want to add more stuff to this. So, we'll do that in 1 second. Okay. Now, if you're someone who's a little bit more technical here, uh, like me, for example, who's a software engineer, then you may be interested in this button. If you press this button right here, it's going to allow you to view all of the code that Lovable has generated for you. Takes a second, so we just need to wait for it to spin up. But you'll see that we can actually go in here and we can view everything that it's created and we can actually go directly to the code browser and we can start typing and modifying the code. Now, that's a premium feature, which means you need to pay for a lovable subscription or a paid plan in order to access that. In my case, I'm just on the free plan, so I'm not going to touch that right now, but I want to make you aware that you can do that. Okay? So you can export this code, you can modify the code, you can do pretty much whatever you want with this code um as if it was like, you know, a proper coding project. Okay. Also, we have this button right here. This just collapses the left sidebar where you have the kind of lovable prompt window. So if you wanted to just be viewing the code, which maybe if you're more advanced, you want, then you can do that there. Okay. So I'm going to close the code viewer. We're going to go back to the live preview. And what I want to do now is start making some edits. Now, before I go crazy and I prompt this and ask it to do a bunch of other stuff, I want to show you the way that we can edit this because there's a few different methods which are really interesting and I haven't seen in some other AI tools. Okay, so let's say I press this edit button right here. It says select toit. This allows you to actually select the different components on your website and directly make a targeted change to them. So here, for example, we have macro calculator. Maybe I don't really like the um what do you call it? the font that we have here. Maybe I want it to be underlined or something. Well, I can just select it. I can say underline this, okay, in orange. Now, when I do that, Lovable knows the exact um kind of target that it needs to make a change on. So, it's going to be a lot more accurate in the changes that it does make. It's not going to go out there and kind of hallucinate and fix a bunch of stuff that we didn't want. And you can see here that it just changed this and added the underline directly to this component. Now, of course, this doesn't always work. Sometimes, you know, there'll be mistakes and things will go wrong, but you see that we were able to really quickly make that very targeted change, which is a feature I personally love of lovable. Now, at this point, we have two changes, right? So, we did that kind of first big build where we created the whole project and then we did this underline. Now, if for some reason we don't like this underline, we can actually always revert back to a previous change that we made. Now, in order to do that, we can find the uh last kind of change that was made. So we can click on it right here and we can press restore. Now if I press restore, this is just going to bring me back to that state. So anything past that will be removed because it's tracking what it's doing and it will bring me back to that previous state. And you can see now the underline is gone. Okay. And if we wanted to, we can actually restore forward. So now because we removed that state, I can go back here and I can restore the new state and it will bring me back to that that point in time essentially. Okay. And then if I wanted to see the code that was actually changed, um, then you can press on code and you can actually see what's called a diff. A diff just tells you where something was changed. So in this case, we see the red, so that was removed. And then the green was added. Again, it's probably not relevant to a lot of you. Uh, but in my case, as a software engineer, that's something that's important to be able to see. Okay. Now, we also have this history button up here. If we press this, we'll see all of the history of our project and the different stages that we've been in. So, we created the macro tracking app. We added the orange underline. We then restored and restored again. And we have all these different changes that are saved. So we can really clearly see kind of the progression of our project. All right. So this is cool. But the next thing I want to do is make a little bit of a larger change. I actually want to add a landing page to my application so that when we come, we don't just see the calculator. We see like a nice um kind of marketing landing page. So let's ask Lovable to do that. Can you please create a stylish landing page for me and name my application Tim's macro app? Yeah, let's go with that. Uh, and give me a kind of cool, nice, modern landing page that convinces people to use my calculator and have one clear button they can press to kind of enter the application or start the app. Now, you'll notice I'm not being super clear in what I'm saying because I don't really know exactly what I want. I'm kind of just coming up with it on the spot. But obviously what we would want to do is have a more detailed plan. Think through this carefully beforehand and then we go step by step. We start with the calculator. We add the landing page. We add the next page, the next page, the next page. And we already know what it is that we want to build. So we're not kind of guessing along the way. So I've just told it, okay, you know, go ahead and do this. Let's see how it does. And then I'm going to show you some more advanced ways that we can prompt this that can give give us some better results um after this change is made. Sweet. So it just finished. And you see that we now have this kind of landing page here. Looks pretty good. It's using my theme somewhat. And I'm just going to zoom out a little bit just so we can see this a little bit more clear. And now you'll notice if we go up here, we have two pages. We have the slash page and the /calc page. Because I told it to make a new page, it knew, okay, the landing page should be on the homepage or the slash page and then calculator should be here. And if I press the /calc page, it will bring me over to this route. So let's wait a second for it to load. And you see the calculator appears. So, let's go back here to the homepage, and I'm going to show you that more advanced way of prompting that I was discussing before. So, what I'm going to do is I'm going to go into chat mode here. Now, let's say that I want to ask Lovable to do something, but I don't know the best way to ask it to do that. What I can do is I can kind of just rant and ramble off my thoughts as I normally do into the uh into Lovable here, and then I can do it in chat mode. And I can tell it at the end of that, you know, kind of thought dump, turn this into a prompt that is good for an AI model, right? Or that works with lovable and will help me, you know, be clear and concise in what I want to say. So, I'm going to give you an example of that. But essentially, if you turn on the chat mode now, lovable is not going to touch your project. It's not going to modify any code. So, you can do what I think is referred to as metaprompting where you prompt the model to help you prompt the model, right? Or in this case, prompt lovable to help you prompt lovable. So, let's say that I want to add a dark mode and a light mode kind of toggle for my website. I might not know how to clearly ask Lovable to do that. So, I'm just going to ask Lovable to help me ask Lovable to do that. Okay, so let's do that. I'm going to say the following. I want to add a dark and light mode toggle feature to my website. I want the user to be able to press a button and either turn it into light or dark mode. I know this requires a lot of changes to my code and it's something that we need to write properly. can you help me come up with a clear, concise, and well-defined prompt that I can pass to an AI model that would be able to make these changes without messing up my project? So, we've asked that and we're in chat mode. Again, make sure this is toggled. You'll know it's toggled if it's blue. We're going to hit enter and then it should give us that new prompt. We're then just going to copy that and pass that to lovable. Okay, cool. So, it says it's going to help us do that. Now, the advantage here as well is that because this has access to our project and the context of our project, it can read through all of the files as you're seeing it doing right now. So, it knows what we're using and kind of the approach it will need to follow in order to do this. So, it says, okay, here's the prompt. So, we have context, we have the current setup, we have the requirements, and we can pass this now, and it will follow this very, you know, detailed kind of process that we've given it. Okay, so let's copy this prompt. All right, let's go up here and copy. Let's take it out of chat mode and let's paste this in and let's see if we get that feature. So, it looks like it finished here. I now have this kind of toggle and it seems to be working pretty well. Let's press this. Let's toggle this. And yeah, the light and dark mode is functioning. The home button works. Okay, sweet. So, there we go. All right. Now, at this point, we've created a basic front end, but I want to go a little bit further and I want to show you how we can add some fancy animations to this because there's actually a pretty cool thing that we can do using this tool called 21st.dev. Okay, or just 21st. Now, I'm not going to get into all of the details of this, but essentially this is a conglomeration of all of the different component libraries that exist out there that already have all of this advanced kind of UI functionality built for you. So, for example, you may have seen those like really cool websites where you have this like, you know, mouse moving thing, right? Or whatever, all these animations. And for you to be able to describe that to lovable is going to be a little bit difficult. So, rather than doing that, you can go to this website, which I'll link in the description, and you can just look for any of these designs that you like, right? So, in my case, I want to find one for kind of like a landing page. So, you know what? Let's try this one. It's going to be interesting if this actually works because this is very complex. But what we're going to do is we're just going to click this design and I'm going to press copy prompt. Now what this does is it gives us a really detailed prompt that describes how to do this that we can then pass to lovable so we can implement this. So now that we've got that prompt, I'm just going to go back to my app and I'm literally just going to paste the prompt in. Now you'll see that it's very long, right? Because it's explaining like exactly what to do with the code sample. But this just says the following. You know, you're given a task to integrate an existing React component in the codebase. And then it says how to do this. I'm going to scroll to the very bottom and I'm just going to make sure that I say do this for the home slash landing page. Now, one thing you should know about prompting is that what you put at the beginning of the prompt and at the end of the prompt always carries more weight than what's in the middle. So if you want the model to do something and you want to be really specific and you want it to have more weight in that instruction, either ask it at the very beginning or at the very end and it will usually take that in more into account essentially. So in this case I asked to do a bunch of stuff but then because at the very end I say do this for the home/landing page. It should know to do that for the homelanding page. So let's try this. I have no idea if this is going to work. In fact if it doesn't work that might actually be good so I can show you kind of how to fix these things. But let's give it a shot and let's see if we can add this animation. This is the component library or you know collection of component libraries that Lovable actually recommends in their documentation which is why I'm showing it to you. And it's really cool if you want to make some really interesting kind of UI elements and components. All right, so this is pretty funny. I mean it's working. It obviously is a little bit ridiculous for this type of application, but you can see that it does work um in the live preview, which I think is pretty cool. And then when I go here, obviously it goes away, which which was intended. So, okay, that's pretty interesting. Um, I'm actually really surprised that worked on the first time, but we got it going. Okay, so that's animations. Next thing we need to talk about is knowledge. Now, this is something that Lovable talks a lot about in the documentation and that I can attest is very important. Now, if you go here to this kind of plus button right here, what you're going to see is a few tabs. You'll see history. We've already gone over that, and you'll see knowledge. Now, what we're going to do is we're going to click into knowledge here. This should open up kind of a settings window for us. So let's wait one second. And this is a place where we're going to be able to put essentially context that will always be included anytime we talk to lovable. So you see the knowledge page here. It gives us some quick kind of context, right? Set project specific rules or best practices. Set coding style preferences. Include external documentation or style guides. Doesn't matter. The point is anything that you don't want to have to keep repeating and that you want lovable to always look at and be aware of, you can put inside of the knowledge. So for example, we can say something like always design each component so it has a light and dark theme and ensure that integrates with the dark and light theme selector that we have in our project. Okay, so that's one rule that I've added. Now it's good for the rules if you do them in kind of point form. Another thing that I'm going to say, always keep everything as simple as possible. Don't over complicate things and make sure the UI is clean and easy to understand. And you can just go through here, right? And you can add as many rules as you want. And if there's something that you want this to always do or always apply, you put it inside of the rules file. So right now we might not have that many rules to add, but as the project gets larger and more complex, we'll start adding more stuff to knowledge so that it always gets read and picked up by lovable. Okay, so we're going to save this here. You also of course can even ask Lovable in chat mode to help you come up with the knowledge file and kind of create this meta knowledge file where you're adjusting it using a lovable. And then of course just because we're in project settings here, you'll see that we have analytics. If we publish the project, then we'll be able to see this. We can give other people access. We can set up different domains. There's also just some general project settings here like renaming the project, remixing it, giving it a category, etc. Let's give it website. You guys get the idea. Okay. And just so you know, when you create these projects and you don't have a paid account, by default, this is public, which mean other people can view what you're building. If you want this to be private, then you do need to upgrade your plan as it says here, right? So, we have workspace or personal. Right now, it's just public. Okay, let's get back into here and let's make some more changes. So, what I want to talk about now is Git and GitHub, which is version control, which I'll explain to you, and then we're going to get into more complex stuff where we're going to set up a backend. We're going to have user accounts, and I'm going to show you how we really can create something quite powerful with lovable. Okay, so Git and GitHub, you've probably heard of this before, but if you haven't, essentially these are tools that we use to save our project consistently and also to allow other people to work on it with us. Now, Lovable makes it very easy to integrate with Git and GitHub and just like lovable stores kind of a history of our project, Git and GitHub will do that as well, but in a little bit more of an advanced way. Git is a local tool, something that runs on your own computer or in this case on our lovable project. GitHub is a place where our project can kind of live and other people can access it and they can view the code that we have. They can make changes to it. I don't want to get too in-d depth, but the point is we kind of need to use this as our project gets larger. I'm going to put a video on screen right now that explains this more in depth in case you're interested, but I'm going to show you how to add kind of an integration to GitHub here so that it automatically gets saved for you. Okay. So, what we're going to do is we're going to go to this little button up here that says sync your project to GitHub. So, what we're going to do is we're going to connect our GitHub account. Again, GitHub is free. It's actually supported by Microsoft right now. So, you will need to make an account if you don't already have one. So, what I'm going to do is go ahead and press on connect GitHub. I should already be signed in here. If I'm not, then I'll sign in and I'll connect Lovable to GitHub. Okay. So, I've just made that connection. Now, I just need to add an organization here. I believe you can just add an organization, which is just you. So, in my case, I have some GitHub organizations, but I'm just going to add my personal organization, which is my name. For you guys, you probably just have one. And I'm just going to give this access to all of my repositories. And then of course I'm going to have to do the off for this. So let me fix that. Okay. So the organization is added. So I'll go ahead and press continue. And then just connect this here. And what's going to happen now is that I'm going to have my project being synced with GitHub. So you'll see this kind of button pressed up or appeared. Sorry. And if I press view, it's going to bring me to a GitHub repository which contains all of the code that my lovable project has written so far or that lovable has written. So now what I can do is maybe I'm working on another computer. Maybe I'm working in a different account. Maybe I'm working locally. I don't have access to lovable. I can make changes to this GitHub repository here. Like I can go in and I can actually modify the code if I know what I'm doing obviously. And then this will automatically sync with lovable. So if I were to make a change here and then I were to go back to lovable here, I'm going to have to fix this. So I'll show you this in one second. The change would be applied here. And then same thing if I make a change in Lovable, it will automatically sync back to GitHub. Now, for some reason after I did the sync here, something kind of messed up inside of Lovable and it's saying that I have this blank project. So, I'm just going to go to the prompt and I'm just going to tell it to fix this. I'm going to say the following. I just connected my Loveable project to GitHub. And now it's saying that I have a blank application and I'm not able to view my app in the live preview. Can you fix this for me and make sure that my app is still working and that I can view it? Okay. So, we'll give that a second. go ahead and press enter and hopefully that will fix it for us. So it just made a few changes here and you can see that now everything is working and I can view the live preview. So I think there was just some kind of like caching issue or something maybe because of the fact that we synced with GitHub and again as I was saying like now any changes that we make here apply on GitHub and then vice versa. Okay. So, what we've done is we've connected Git. We've created a pretty cool application already. But this is just um kind of working locally, right? What that means is that we're not really storing any data. We just have a basic calculator. But what if we want to go a little bit further? So, what I want to do now is I want to enhance this application and I want to add a feature for user accounts so that users can create an account, they can sign in and then we'll do something basic where they can essentially store the calculations. So anytime they press calculate, we'll just keep a log of those calculations that they've made. So we're just storing it and associating it with those users. Sure, it's not super complex, but again, I want to start small. I want to work on the backend features and explain to you what that looks like, and then we'll keep going. Now, I want to just explain what I mean by backend. Anytime you want to have user related data or you want to have information that's not always publicly available like you want to have an account or you want to have comments or posts or something associated with one person and just that person or a group of people then you're going to need to create a backend. Now lovable will do this for you automatically using something called superbase. Superbase is the default back-end integration for Lovable. And when you need to do that, so when you ask for something that requires that, Lovable should automatically detect that for you and prompt you to set up the Superbase integration. I'm going to explain it more in depth as we go through here, but I'm going to explain the feature to lovable that I want to add. It should then know, okay, I need to set this up. And then we're going to go through those steps. This is slightly more advanced. I'm just warning you right now, but it's obviously important and it's something you need to learn how to do to really take kind of full advantage of this tool. Okay, so let's ask this. All right, I want to make my application more advanced now. I want to allow users to sign in and to create in a new a new account. I then want to store all of the calculations that they type in the calculator in some kind of log. So anytime they press calculate, I want to store what they calculated and just keep some kind of log of all of those calculations that's stored under their account. Again, keep it simple and do not allow my users to access the calculator page unless they've signed into an account. Okay, so I'm asking it to do this here. We should have the dictation pop up. We're going to go ahead and press enter. And now we're just going to wait a second. And it should detect that it needs that backend feature because we're dealing with authentication. And I suggest whenever you're building these back-end features for an application that you start with the authentication, which is kind of what we're doing here, and then you get into more features after that. Okay, so it's actually telling me what I need to do here. It says click the green superbase button in the top right of lovable. Connect to Superbase. You need to create an account if you don't have one. And once it's connected, I'll help you do this. Okay. So, we're going to go here to this green button, which is the Superbase button. And we're going to connect Superbase. If you're not familiar with Suabase, I'm going to press this button right here. This is an all-in-one back-end platform that allows you to handle databases, authentication, uh, functions, which we'll talk about in a second. So, what I'm going to do is just continue here with GitHub, which is what I would recommend that you do to sign in. And we're going to give it access to my organization, which is called Dev Launch. Okay. So, let's do that. We'll just run through this flow. And then we'll go back to Lovable. And you'll see, okay, we've added the organization. So, let's press continue. And I'm just going to create a new project. Okay. So, I'm going to make new project here. We go in our free organization. I'm going to call this lovable. Okay. We'll go with the Singapore region. That's fine. For the password, type something in that you are not going to forget and that ideally is a strong password. And there's a bunch of other stuff here. Don't worry about that. You can just leave this as the default and make your new Superbase project. Okay. And I'm going to save that password for now. All right. So, we've done that. We're going to go back to Lovable now and we're going to connect to this new project that we created. So, we're going to go ahead and press on connect and then it should start spinning this stuff up. So, the project is connected. So, we're going to go back to the chat window here. It says our app is now connected and it's going to tell us what we need to do. So, it's going to do user accounts, all of this kind of stuff. So, what's next? Just keep building. For any questions, just ask. Okay, cool. So, let me read this again. Enable signin signup options. Okay. So, what I'm going to do is I'm just going to copy the the previous prompt that I had because it looks like it didn't really apply all of that. And I'm just going to ask it to do this again now that we've connected to Superbase. So, we should have that backend functionality and hopefully now it's able to make these changes. I believe sometimes we do need to manually do something in Superbase, which it will prompt us to do, but overall lovable should handle most of these operations. So, it's asked us this question and then it's gone and it's written essentially a database operation that's going to apply to set up the database for us. Again, you don't need to worry too much about what this is doing. But before you apply this, it's always a good idea to make sure this is correct because any application you make or change you make to the database can be a little bit tricky later on to fix. So, what I'm going to do is I'm just going to answer this question. Do you want to store additional user profile data like usernames or avatars? I'm just going to say no, I just care about their name and email. Okay. So, I'm just going to tell it that and then I think it's going to go and make a new um kind of database migration file for us essentially that we can apply. Now, at this point, a lot of the stuff you're going to start seeing is going to look a little bit complicated if you're not a programmer, right? So, if you're confused, change into the chat mode and ask it what is it doing? What does this mean? Explain it to me. Don't just blindly trust everything that Lovable gives you here. You want to be um pretty kind of skeptical of what it's doing, especially when it comes to the backend stuff so you don't mess anything up too badly, right? Okay. So, it's done this here. We can read through this. Users can update their own profile. It's created a few rules for us. Okay. All right. Let's go ahead and press apply changes for now and let's see what happens next. So, it looks like it finished here. And now we have this kind of sign in to start button. So, let's press that. we get this kind of field. Okay, so I just filled this in. Let's go create account. Um, and timgmail.com is invalid. Okay, let's try a different email. Okay, and interestingly, it actually sent me a confirmation email, which I didn't even ask it to do, but that's pretty cool. So, I'm going to confirm my email address here by pressing that button. And it looks like it's bringing me back to the application, which I guess is a good sign. And then we're signed in. Okay, that's pretty cool. So, I'm going to go to calculator and let's mess with this now because I've signed in. So, 25 175 71. Okay, let's go gain weight. And we got the calculation. And then it says calculations saved. Okay, that's pretty cool. So now I'm going to go back to home. Let's go calculate my macros. And it looks like it saved my calculation, but I'm not seeing where those logs are. So, what I'm doing now is I'm going back to Lovable and I'm going to just tell it that, okay, this is working, but I'm not seeing a log of my calculations. So, let's ask it to fix that. The authentication seems to be working. However, there's no place where I can see a log of the calculations that I've made. Can you either add a new page or add it to the calculator page and create a simple layout that allows me to view all of the calculations that I've made previously? Okay, so let's get it to do that. Just wait for the dictation to pop in here. All right. So, it says it's added this. Let me sign back in from this page here and see if it works. Okay. So, I'm going to scroll down. I'm going to go to history. And then there we go. We can see that we have the kind of log of what it is that we created. And it gives us this information. All right. That is pretty cool. Now, those are most of the features that I wanted to add to this application. Of course, there's a lot more stuff that we could do, but I wanted to just show you how we add the backend implementation, how we build this out, how we go step by step, kind of the prompting flow. Now, at this point, if we want, we can actually publish this application. So, if we press publish, we can actually publish it. So, we can review the security as well, but I'm not going to do that right now. And when we publish this out, then we'll be able to view it on this domain right here. Now, we also could add custom domains to this, but I'm not going to walk through that process because I assume most of you probably don't already have a domain. And we can set up like search engine optimization, all that kind of stuff. But now if I go to the URL that it just gave me, then we should have this kind of finished, lovable application that users can actually mess around with and view. Now, is this really ready for us to sell and make a billion dollars? Probably not yet. But, you know, it's a good starting point. And in a relatively short amount of time, we've built a pretty cool app. We've got this great animation feature. We have back-end functionality. And we didn't really run into many errors. Now, look, this worked pretty well. I haven't done this before. This was the first run in this video and the reason why I got good results is because I was going slowly and not trying to do too many things at once. It is very possible that mistakes will happen. The bugs will appear. Right? If that's the case, be patient. Slow down. Try to solve the problems one by one. Give as much information as you possibly can to the model or to Loveable in this case. You can take images of what's going wrong. You can attach it into the prompt. You can explain it step by step. You can ask Leovable to break down what it thinks and to attempt one solution at a time and just be creative in the way that you're debugging and I'm sure that you will eventually, you know, kind of come up with a solution. If you guys enjoyed this video, please leave a like, subscribe to the channel, let me know if you want more lovable content. I'd be happy to make some more and I look forward to seeing you in another video. [Music]",unknown
aDdr_DKRo4M,"Most experienced software engineers still can't pass even basic coding interviews. And it's not because they haven't grinded 300 lead code questions. It's simply because they were never taught the process that I'm going to walk you through in this video. Problem visualization. Now, this is not always possible, but I highly recommend when you can and you're given the opportunity to draw out the problem. Now this is very useful especially if you have a graph-based problem or a matrix problem or something where you can actually visualize it right where you have nodes where you have connections. This helps you first of all to actually see what's going on but it also demonstrates to the interviewer that you're trying to understand the problem more before you dive into a solution. Right now again we're in this kind of planning and design phase where you want to demonstrate how you think critically. That's what this is about. So, if you can visualize the problem, that's always just helpful to me to be honest to solve the problem, but also allows the interviewer to see what you're doing and to kind of unlock that visualization into your thought process.",unknown
cO7fTLTSHoo,"Most experienced software engineers still can't pass even basic coding interviews. And it's not because they haven't grinded 300 lead code questions. It's simply because they were never taught the process that I'm going to walk you through in this video. Now, the first thing that you need to do is to always clarify the question. Now, most coding interviews will start with someone reading out some question to you. Usually, it's two or three sentences and they might say something like given an array of integers, you know, reverse that array, giving you a very, very basic question. Now, this is almost never enough for you to actually be able to solve the problem. What they're expecting you to do in this situation is to really break down what you were asked and then ask a bunch of clarifying questions about it. Now, these questions are almost always going to be related to the input that you're given and then the expected output.",unknown
